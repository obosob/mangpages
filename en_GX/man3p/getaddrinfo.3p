.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "FREEADDRINFO" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" freeaddrinfo 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
freeaddrinfo, getaddrinfo \- git address shiznit
.SH SYNOPSIS
.LP
\fB#include <sys/socket.h>
.br
#include <netdb.h>
.br
.sp
void freeaddrinfo(struct addrinfo *\fP\fIai\fP\fB);
.br
int getaddrinfo(const char *restrict\fP \fInodename\fP\fB,
.br
\ \ \ \ \ \  const char *restrict\fP \fIservname\fP\fB,
.br
\ \ \ \ \ \  const struct addrinfo *restrict\fP \fIhints\fP\fB,
.br
\ \ \ \ \ \  struct addrinfo **restrict\fP \fIres\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
Da \fIfreeaddrinfo\fP() function shall free one or mo' \fBaddrinfo\fP
structures returned by \fIgetaddrinfo\fP(), along
with any additionizzle storage associated wit dem structures. If the
\fIai_next\fP field of tha structure aint null, tha entire
list of structures shall be freed. Y'all KNOW dat shit, muthafucka! Da \fIfreeaddrinfo\fP() function
shall support tha freein of arbitrary sublistz of an
\fBaddrinfo\fP list originally returned by \fIgetaddrinfo\fP().
.LP
Da \fIgetaddrinfo\fP() function shall translate tha name of a service
location (for example, a host name) and/or a service
name n' shall return a set of socket addresses n' associated shiznit
to be used up in bustin a socket wit which ta address
the specified service. 
.TP 7
\fBNote:\fP
In nuff cases it is implemented by tha Domain Name System, as documented
in RFC\ 1034, RFC\ 1035, and
RFC\ 1886.
.sp
.LP
Da \fIfreeaddrinfo\fP() n' \fIgetaddrinfo\fP() functions shall be
thread-safe.
.LP
Da \fInodename\fP n' \fIservname\fP arguments is either null pointers
or pointas ta null-terminated strings. One or both
of these two arguments shall be supplied by tha application as a non-null
pointer.
.LP
Da format of a valid name dependz on tha address crew or crews.
If a specific crew aint given n' tha name could be
interpreted as valid within multiple supported crews, tha implementation
shall attempt ta resolve tha name up in all supported
families and, up in absence of errors, one or mo' thangs up in dis biatch shall be returned.
.LP
If tha \fInodename\fP argument aint null, it can be a thugged-out descriptive
name or can be a address string. If tha specified address
family is AF_INET,  AF_INET6,  or AF_UNSPEC, valid
descriptizzle names include host names. If tha specified address crew
is AF_INET or AF_UNSPEC, address strings rockin Internet
standard dot notation as specified up in \fIinet_addr\fP() is valid.
.LP
If tha specified address crew is AF_INET6 or AF_UNSPEC, standard
IPv6 text forms busted lyrics bout up in \fIinet_ntop\fP() is valid. Y'all KNOW dat shit, muthafucka! 
.LP
If \fInodename\fP aint null, tha axed steez location is named
by \fInodename\fP; otherwise, tha axed service
location is local ta tha caller.
.LP
If \fIservname\fP is null, tha call shall return network-level addresses
for tha specified \fInodename.\fP If \fIservname\fP
is not null, it aint nuthin but a null-terminated characta strang identifying
the axed service. This can be either a thugged-out descriptizzle name or a
numeric representation suitable fo' use wit tha address crew or
families. Put ya muthafuckin choppers up if ya feel dis! If tha specified address crew is AF_INET,  
\ AF_INET6,  or AF_UNSPEC, tha steez can be specified as a
strin specifyin a thugged-out decimal port number.
.LP
If tha \fIhints\fP argument aint null, it refers ta a structure
containin input joints dat may direct tha operation by
providin options n' by limitin tha returned shiznit ta a specific
socket type, address crew, and/or protocol. In this
\fIhints\fP structure every last muthafuckin member other than \fIai_flags\fP, \fIai_family\fP,
\fIai_socktype\fP, n' \fIai_protocol\fP shall
be set ta zero or a null pointer n' shiznit fo' realz. A value of AF_UNSPEC fo' \fIai_family\fP
means dat tha calla shall accept any address crew.
A value of zero fo' \fIai_socktype\fP means dat tha calla shall
accept any socket type fo' realz. A value of zero fo' \fIai_protocol\fP
means dat tha calla shall accept any protocol. If \fIhints\fP is
a null pointer, tha behavior shall be as if it referred ta a
structure containin tha value zero fo' tha \fIai_flags\fP, \fIai_socktype\fP,
and \fIai_protocol\fP fields, n' AF_UNSPEC for
the \fIai_family\fP field.
.LP
Da \fIai_flags\fP field ta which tha \fIhints\fP parameta points
shall be set ta zero or be tha bitwise-inclusive OR of one
or mo' of tha joints AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST, AI_NUMERICSERV,
AI_V4MAPPED, AI_ALL, n' AI_ADDRCONFIG.
.LP
If tha AI_PASSIVE flag is specified, tha returned address shiznit
shall be suitable fo' use up in bindin a socket for
acceptin incomin connections fo' tha specified service. In this
case, if tha \fInodename\fP argument is null, then tha IP
address portion of tha socket address structure shall be set ta INADDR_ANY
for a IPv4 address or IN6ADDR_ANY_INIT fo' a IPv6
address. If tha AI_PASSIVE flag aint specified, tha returned address
information shall be suitable fo' a cold-ass lil call ta \fIconnect\fP() (for a
connection-mode protocol) or fo' a cold-ass lil call ta \fIconnect\fP(), \fIsendto\fP(),
or \fIsendmsg\fP() (for a cold-ass lil connectionless protocol). In dis case,
if tha \fInodename\fP argument is
null, then tha IP address portion of tha socket address structure
shall be set ta tha loopback address. Da AI_PASSIVE flag shall
be ignored if tha \fInodename\fP argument aint null.
.LP
If tha AI_CANONNAME flag is specified n' tha \fInodename\fP argument
is not null, tha function shall attempt ta determine the
canonical name correspondin ta \fInodename\fP (for example, if \fInodename\fP
is a alias or shorthand notation fo' a cold-ass lil complete
name). 
.TP 7
\fBNote:\fP
Since different implementations use different conceptual models, the
terms ``canonical name'' n' ``alias'' cannot be precisely
defined fo' tha general case. But fuck dat shiznit yo, tha word on tha street is dat Domain Name System implementations
are sposed ta fuckin interpret dem as they is used in
RFC\ 1034. 
.LP
A numeric host address strang aint a ``name'', n' thus do not
have a ``canonical name'' form; no address ta host name
translation is performed. Y'all KNOW dat shit, muthafucka! See below fo' handlin of tha case where
a canonical name cannot be obtained.
.sp
.LP
If tha AI_NUMERICHOST flag is specified, then a non-null \fInodename\fP
strin supplied shall be a numeric host address string.
Otherwise, a [EAI_NONAME] error is returned. Y'all KNOW dat shit, muthafucka! This flag shall prevent
any type of name resolution steez (for example, tha DNS)
from bein invoked.
.LP
If tha AI_NUMERICSERV flag is specified, then a non-null \fIservname\fP
strin supplied shall be a numeric port string.
Otherwise, a [EAI_NONAME] error shall be returned. Y'all KNOW dat shit, muthafucka! This flag shall
prevent any type of name resolution steez (for example, NIS+)
from bein invoked.
.LP
If tha AI_V4MAPPED flag is specified along wit a \fIai_family\fP
of AF_INET6, then \fIgetaddrinfo\fP() shall return IPv4-mapped
IPv6 addresses on findin no matchin IPv6 addresses ( \fIai_addrlen\fP
shall be 16). Da AI_V4MAPPED flag shall be ignored unless
\fIai_family\fP equals AF_INET6. If tha AI_ALL flag is used wit the
AI_V4MAPPED flag, then \fIgetaddrinfo\fP() shall return all
matchin IPv6 n' IPv4 addresses. Da AI_ALL flag without tha AI_V4MAPPED
flag is ignored. Y'all KNOW dat shit, muthafucka! 
.LP
If tha AI_ADDRCONFIG flag is specified, IPv4 addresses shall be returned
only if a IPv4 address is configured on tha local
system,  n' IPv6 addresses shall be returned only if a IPv6 address
is configured on tha local system. 
.LP
Da \fIai_socktype\fP field ta which argument \fIhints\fP points specifies
the socket type fo' tha service, as defined up in \fIsocket\fP(). If
a specific socket type aint given (for example, a value of zero)
and tha steez name
could be interpreted as valid wit multiple supported socket types,
the implementation shall attempt ta resolve tha steez name
for all supported socket types and, up in tha absence of errors, all
possible thangs up in dis biatch shall be returned. Y'all KNOW dat shit, muthafucka! A non-zero socket type value
shall limit tha returned shiznit ta joints wit tha specified
socket type.
.LP
If tha \fIai_family\fP field ta which \fIhints\fP points has tha value
AF_UNSPEC, addresses shall be returned fo' use wit any
address crew dat can be used wit tha specified \fInodename\fP
and/or \fIservname\fP. Otherwise, addresses shall be returned
for use only wit tha specified address crew. If \fIai_family\fP
is not AF_UNSPEC n' \fIai_protocol\fP aint zero, then
addresses is returned fo' use only wit tha specified address crew
and protocol; tha value of \fIai_protocol\fP shall be
interpreted as up in a cold-ass lil call ta tha \fIsocket\fP() function wit tha corresponding
values of
\fIai_family\fP n' \fIai_protocol\fP.
.SH RETURN VALUE
.LP
A zero return value fo' \fIgetaddrinfo\fP() indicates successful completion;
a non-zero return value indicates failure. The
possible joints fo' tha failures is listed up in tha ERRORS section.
.LP
Upon successful return of \fIgetaddrinfo\fP(), tha location ta which
\fIres\fP points shall refer ta a linked list of
\fBaddrinfo\fP structures, each of which shall specify a socket address
and shiznit fo' use up in bustin a socket wit which to
use dat socket address. Da list shall include at least one \fBaddrinfo\fP
structure. Da \fIai_next\fP field of each structure
gotz nuff a pointa ta tha next structure on tha list, or a null pointer
if it is tha last structure on tha list. Each structure on
the list shall include joints fo' use wit a cold-ass lil call ta tha \fIsocket\fP()
function, n' a
socket address fo' use wit tha \fIconnect\fP() function or, if the
AI_PASSIVE flag was
specified, fo' use wit tha \fIbind\fP() function. I aint talkin' bout chicken n' gravy biatch. Da fieldz \fIai_family\fP,
\fIai_socktype\fP, n' \fIai_protocol\fP shall be usable as tha arguments
to tha \fIsocket\fP() function ta create a socket suitable fo' use
with tha returned address. Da fields
\fIai_addr\fP n' \fIai_addrlen\fP is usable as tha arguments to
the \fIconnect\fP() or
\fIbind\fP() functions wit such a socket, accordin ta tha AI_PASSIVE
flag.
.LP
If \fInodename\fP aint null, n' if axed by tha AI_CANONNAME
flag, tha \fIai_canonname\fP field of tha straight-up original gangsta returned
\fBaddrinfo\fP structure shall point ta a null-terminated strang containing
the canonical name correspondin ta tha input
\fInodename\fP; if tha canonical name aint available, then \fIai_canonname\fP
shall refer ta tha \fInodename\fP argument or a
strin wit tha same contents, n' you can put dat on yo' toast. Da contentz of tha \fIai_flags\fP
field of tha returned structures is undefined.
.LP
All fieldz up in socket address structures returned by \fIgetaddrinfo\fP()
that is not filled up in all up in a explicit argument
(for example, \fIsin6_flowinfo\fP) shall be set ta zero. 
.TP 7
\fBNote:\fP
This make it easier ta compare socket address structures.
.sp
.SH ERRORS
.LP
Da \fIgetaddrinfo\fP() function shall fail n' return tha corresponding
value if:
.TP 7
.B EAI_AGAIN
Da name could not be resolved at dis time. Future attempts may succeed.
.TP 7
.B EAI_BADFLAGS
.sp
Da \fIflags\fP parameta had a invalid value.
.TP 7
.B EAI_FAIL
A non-recoverable error occurred when attemptin ta resolve tha name.
.TP 7
.B EAI_FAMILY
Da address crew was not recognized.
.TP 7
.B EAI_MEMORY
There was a memory allocation failure when tryin ta allocate storage
for tha return value.
.TP 7
.B EAI_NONAME
Da name do not resolve fo' tha supplied parameters. 
.LP
Neither \fInodename\fP nor \fIservname\fP was supplied. Y'all KNOW dat shit, muthafucka! At least
one of these shall be supplied.
.TP 7
.B EAI_SERVICE
Da steez passed was not recognized fo' tha specified socket type.
.TP 7
.B EAI_SOCKTYPE
.sp
Da intended socket type was not recognized.
.TP 7
.B EAI_SYSTEM
A system error occurred; tha error code can be found up in \fIerrno\fP.
.TP 7
.B EAI_OVERFLOW
.sp
An argument buffer overflowed.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
If tha calla handlez only TCP n' not UDP, fo' example, then the
\fIai_protocol\fP gangmember of tha \fIhints\fP structure should
be set ta IPPROTO_TCP when \fIgetaddrinfo\fP() is called.
.LP
If tha calla handlez only IPv4 n' not IPv6, then tha \fIai_family\fP
gangmember of tha \fIhints\fP structure should be set to
AF_INET when \fIgetaddrinfo\fP() is called.
.LP
Da term ``canonical name'' is misleading; it is taken from tha Domain
Name System (RFC\ 2181). Well shiiiit, it should be noted dat the
canonical name be a result of alias processing, n' not necessarily
a unique attribute of a host, address, or set of addresses. Right back up in yo muthafuckin ass. See
RFC\ 2181 fo' mo' rap of dis up in tha Domain Name System context.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIconnect\fP(), \fIgai_strerror\fP(), \fIgethostbyaddr\fP(), \fIgetnameinfo\fP(),
\fIgetservbyname\fP(), \fIsocket\fP(), tha Base Definitions volume
of
IEEE\ Std\ 1003.1-2001, \fI<netdb.h>\fP, \fI<sys/socket.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
