.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "FPRINTF" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" fprintf 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
fprintf, printf, snprintf, sprintf \- print formatted output
.SH SYNOPSIS
.LP
\fB#include <stdio.h>
.br
.sp
int fprintf(FILE *restrict\fP \fIstream\fP\fB, const char *restrict\fP
\fIformat\fP\fB, ...);
.br
int printf(const char *restrict\fP \fIformat\fP\fB, ...);
.br
int snprintf(char *restrict\fP \fIs\fP\fB, size_t\fP \fIn\fP\fB,
.br
\ \ \ \ \ \  const char *restrict\fP \fIformat\fP\fB, ...);
.br
int sprintf(char *restrict\fP \fIs\fP\fB, const char *restrict\fP
\fIformat\fP\fB, ...);
.br
\fP
.SH DESCRIPTION
.LP
Da \fIfprintf\fP() function shall place output on tha named output
\fIstream\fP. Da \fIprintf\fP() function shall place
output on tha standard output stream \fIstdout\fP. Da \fIsprintf\fP()
function shall place output followed by tha null byte,
\fB'\\0'\fP, up in consecutizzle bytes startin at *\fIs\fP; it is the
userz responsibilitizzle ta ensure dat enough space is
available.
.LP
Da \fIsnprintf\fP() function shall be equivalent ta \fIsprintf\fP(),
with tha addizzle of tha \fIn\fP argument which states
the size of tha buffer referred ta by \fIs\fP. If \fIn\fP is zero,
nothang shall be freestyled n' \fIs\fP may be a null pointer.
Otherwise, output bytes beyond tha \fIn\fP-1st shall be discarded
instead of bein freestyled ta tha array, n' a null byte is
written all up in tha end of tha bytes straight-up freestyled tha fuck into tha array.
.LP
If copyin takes place between objects dat overlap as a result of
a call ta \fIsprintf\fP() or \fIsnprintf\fP(), tha thangs up in dis biatch
are undefined.
.LP
Each of these functions converts, formats, n' prints its arguments
under control of tha \fIformat\fP. Da \fIformat\fP be a
characta string, beginnin n' endin up in its initial shift state,
if any. Da \fIformat\fP is composed of zero or more
directives: \fIordinary characters\fP, which is simply copied to
the output stream, n' \fIconversion justifications\fP, each of
which shall result up in tha fetchin of zero or mo' arguments, n' you can put dat on yo' toast. The
results is undefined if there be insufficient arguments fo' the
\fIformat\fP. If tha \fIformat\fP is exhausted while arguments remain,
the excess arguments shall be evaluated but is otherwise
ignored.
.LP
Conversions can be applied ta tha \fIn\fPth argument afta tha \fIformat\fP
in tha argument list, rather than ta tha next unused
argument. In dis case, tha conversion specifier characta \fB%\fP
(see below) is replaced by tha sequence
\fB"%\fP\fIn\fP\fB$"\fP, where \fIn\fP be a thugged-out decimal integer up in the
range [1,{NL_ARGMAX}], givin tha posizzle of the
argument up in tha argument list. This feature serves up fo' tha definition
of format strings dat select arguments up in a order
appropriate ta specific languages (see tha EXAMPLES section).
.LP
Da \fIformat\fP can contain either numbered argument conversion justifications
(that is, \fB"%\fP\fIn\fP\fB$"\fP and
\fB"*\fP\fIm\fP\fB$"\fP), or unnumbered argument conversion justifications
(that is, \fB%\fP n' \fB*\fP ) yo, but not
both. Da only exception ta dis is dat \fB%%\fP can be mixed with
the \fB"%\fP\fIn\fP\fB$"\fP form. Da thangs up in dis biatch of
mixin numbered n' unnumbered argument justifications up in a \fIformat\fP
strin is undefined. Y'all KNOW dat shit, muthafucka! When numbered argument
specifications is used, specifyin tha \fIN\fPth argument requires
that all tha leadin arguments, from tha straight-up original gangsta ta the
(\fIN-1\fP)th, is specified up in tha format string.
.LP
In format strings containin tha \fB"%\fP\fIn\fP\fB$"\fP form of conversion
specification, numbered arguments up in the
argument list can be referenced from tha format strang as nuff times
as required. Y'all KNOW dat shit, muthafucka! 
.LP
In format strings containin tha \fB%\fP form of conversion justification,
each conversion justification uses tha first
unused argument up in tha argument list.
.LP
All
formz of tha \fIfprintf\fP() functions allow fo' tha insertion of
a language-dependent radix characta up in tha output string. The
radix characta is defined up in tha programz locale (category \fILC_NUMERIC
).\fP In tha POSIX locale, or up in a locale where the
radix characta aint defined, tha radix characta shall default
to a period ( \fB'.'\fP ). 
.LP
Each conversion justification is introduced by tha \fB'%'\fP character
\ or by the
characta sequence \fB"%\fP\fIn\fP\fB$"\fP,  afta which the
followin step tha fuck up in sequence:
.IP " *" 3
Zero or mo' \fIflags\fP (in any order), which modify tha meaning
of tha conversion justification.
.LP
.IP " *" 3
An optionizzle minimum \fIfield width\fP. If tha converted value has
fewer bytes than tha field width, it shall be padded with
spaces by default on tha left; it shall be padded on tha right if
the left-adjustment flag ( \fB'-'\fP ), busted lyrics bout below, is
given ta tha field width. Da field width takes tha form of a asterisk
( \fB'*'\fP ), busted lyrics bout below, or a thugged-out decimal
integer.
.LP
.IP " *" 3
An optionizzle \fIprecision\fP dat gives tha minimum number of digits
to step tha fuck up fo' tha \fBd\fP, \fBi\fP, \fBo\fP,
\fBu\fP, \fBx\fP, n' \fBX\fP conversion specifiers; tha number
of digits ta step tha fuck up afta tha radix characta fo' the
\fBa\fP, \fBA\fP, \fBe\fP, \fBE\fP, \fBf\fP, n' \fBF\fP conversion
specifiers; tha maximum number of
significant digits fo' tha \fBg\fP n' \fBG\fP conversion specifiers;
or tha maximum number of bytes ta be printed from a
strin up in tha \fBs\fP  n' \fBS\fP  \ conversion
specifiers. Da precision takes tha form of a period ( \fB'.'\fP )
followed either by a asterisk ( \fB'*'\fP ), busted lyrics about
below, or a optionizzle decimal digit string, where a null digit string
is treated as zero. If a precision appears wit any other
conversion specifier, tha behavior is undefined.
.LP
.IP " *" 3
An optionizzle length modifier dat specifies tha size of tha argument.
.LP
.IP " *" 3
A \fIconversion specifier\fP characta dat indicates tha type of
conversion ta be applied.
.LP
.LP
A field width, or precision, or both, may be indicated by a asterisk
( \fB'*'\fP ). In dis case a argument of type
\fBint\fP supplies tha field width or precision. I aint talkin' bout chicken n' gravy biatch fo' realz. Applications shall
ensure dat arguments specifyin field width, or precision, or
both step tha fuck up in dat order before tha argument, if any, ta be converted.
A wack field width is taken as a \fB'-'\fP flag
followed by a positizzle field width fo' realz. A wack precision is taken
as if tha precision was omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In format
strings containin tha \fB"%\fP\fIn\fP\fB$"\fP form of a cold-ass lil conversion
specification, a gangbangin' field width or precision may be
indicated by tha sequence \fB"*\fP\fIm\fP\fB$"\fP, where \fIm\fP is
a decimal integer up in tha range [1,{NL_ARGMAX}] giving
the posizzle up in tha argument list (afta tha \fIformat\fP argument)
of a integer argument containin tha field width or
precision, fo' example:
.sp
.RS
.nf

\fBprintf("%1$d:%2$.*3$d:%4$.*3$d\\n", hour, min, precision, sec);
\fP
.fi
.RE
.LP
Da flag charactas n' they meanings are:
.TP 7
\fB'\fP
Da integer portion of tha result of a thugged-out decimal conversion ( \fB%i\fP,
\fB%d\fP, \fB%u\fP, \fB%f\fP, \fB%F\fP,
\fB%g\fP, or \fB%G\fP ) shall be formatted wit thousands' grouping
characters. For other conversions tha behavior is
undefined. Y'all KNOW dat shit, muthafucka! Da non-monetary groupin characta is used. Y'all KNOW dat shit, muthafucka! 
.TP 7
\fB-\fP
Da result of tha conversion shall be left-justified within tha field.
Da conversion is right-justified if dis flag is not
specified.
.TP 7
\fB+\fP
Da result of a signed conversion shall always begin wit a sign (
\fB'+'\fP or \fB'-'\fP ). Da conversion shall begin
with a sign only when a wack value is converted if dis flag is
not specified.
.TP 7
<space>
If tha straight-up original gangsta characta of a signed conversion aint a sign or if
a signed conversion thangs up in dis biatch up in no characters, a <space>
shall be prefixed ta tha result. This means dat if tha <space> and
\fB'+'\fP flags both appear, tha <space> flag
shall be ignored.
.TP 7
\fB#\fP
Specifies dat tha value is ta be converted ta a alternatizzle form.
For \fBo\fP conversion, it increases tha precision (if
necessary) ta force tha straight-up original gangsta digit of tha result ta be zero. For
\fBx\fP or \fBX\fP conversion specifiers, a non-zero result
shall have 0x (or 0X) prefixed ta dat shit. For \fBa\fP, \fBA\fP, \fBe\fP,
\fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP,
and \fBG\fP conversion specifiers, tha result shall always contain
a radix character, even if no digits follow tha radix
character n' shit. Without dis flag, a radix characta appears up in tha result
of these conversions only if a gangbangin' finger-lickin' digit bigs up dat shit. For
\fBg\fP n' \fBG\fP conversion specifiers, trailin zeros shall \fInot\fP
be removed from tha result as they normally are.
For other conversion specifiers, tha behavior is undefined.
.TP 7
\fB0\fP
For \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP, \fBX\fP, \fBa\fP,
\fBA\fP, \fBe\fP,
\fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP, n' \fBG\fP conversion specifiers,
leadin zeros (followin any indication
of sign or base) is used ta pad ta tha field width; no space padding
is performed. Y'all KNOW dat shit, muthafucka! If tha \fB'0'\fP n' \fB'-'\fP flags both
appear, tha \fB'0'\fP flag is ignored. Y'all KNOW dat shit, muthafucka! For \fBd\fP, \fBi\fP, \fBo\fP,
\fBu\fP, \fBx\fP, n' \fBX\fP
conversion specifiers, if a precision is specified, tha \fB'0'\fP
flag is ignored. Y'all KNOW dat shit, muthafucka!  If the
\fB'0'\fP n' \fB'"\fP flags both appear, tha groupin characters
are banged before zero padding. For other conversions,
the behavior is undefined. Y'all KNOW dat shit, muthafucka! 
.sp
.LP
Da length modifiers n' they meanings are:
.TP 7
\fBhh\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBsigned char\fP or \fBunsigned char\fP argument (the
argument gonna git been promoted accordin ta tha integer
promotions yo, but its value shall be converted ta \fBsigned char\fP
or \fBunsigned char\fP before printing); or dat a gangbangin' following
\fBn\fP conversion specifier applies ta a pointa ta a \fBsigned char\fP
argument.
.TP 7
\fBh\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBshort\fP or \fBunsigned short\fP argument (the argument
will done been promoted accordin ta tha integer
promotions yo, but its value shall be converted ta \fBshort\fP or \fBunsigned
short\fP before printing); or dat a gangbangin' following
\fBn\fP conversion specifier applies ta a pointa ta a \fBshort\fP
argument.
.TP 7
\fBl\fP\ (ell)
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBlong\fP or \fBunsigned long\fP argument; dat a gangbangin' following
\fBn\fP conversion specifier applies ta a pointa to
a \fBlong\fP argument; dat a gangbangin' followin \fBc\fP conversion specifier
applies ta a \fBwint_t\fP argument; dat a gangbangin' following
\fBs\fP conversion specifier applies ta a pointa ta a \fBwchar_t\fP
argument; or has no effect on a gangbangin' followin \fBa\fP,
\fBA\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP, or \fBG\fP
conversion specifier.
.TP 7
\fBll\fP\ (ell-ell)
.sp
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBlong long\fP or \fBunsigned long long\fP argument;
or dat a gangbangin' followin \fBn\fP conversion specifier applies to
a pointa ta a \fBlong long\fP argument.
.TP 7
\fBj\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBintmax_t\fP or \fBuintmax_t\fP argument; or that
a followin \fBn\fP conversion specifier applies ta a
pointa ta a \fBintmax_t\fP argument.
.TP 7
\fBz\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBsize_t\fP or tha correspondin signed integer type
argument; or dat a gangbangin' followin \fBn\fP conversion specifier
applies ta a pointa ta a signed integer type correspondin ta a \fBsize_t\fP
argument.
.TP 7
\fBt\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBptrdiff_t\fP or tha correspondin \fBunsigned\fP type
argument; or dat a gangbangin' followin \fBn\fP conversion
specifier applies ta a pointa ta a \fBptrdiff_t\fP argument.
.TP 7
\fBL\fP
Specifies dat a gangbangin' followin \fBa\fP, \fBA\fP, \fBe\fP, \fBE\fP,
\fBf\fP, \fBF\fP, \fBg\fP, or
\fBG\fP conversion specifier applies ta a \fBlong double\fP argument.
.sp
.LP
If a length modifier appears wit any conversion specifier other than
as specified above, tha behavior is undefined.
.LP
Da conversion specifiers n' they meanings are:
.TP 7
\fBd\fP,\ \fBi\fP
Da \fBint\fP argument shall be converted ta a signed decimal up in the
style \fB"[-]\fP\fIdddd\fP\fB"\fP. Da precision
specifies tha minimum number of digits ta appear; if tha value being
converted can be represented up in fewer digits, it shall be
expanded wit leadin zeros. Da default precision is 1. Da result
of convertin zero wit a explicit precision of zero shall be
no characters.
.TP 7
\fBo\fP
Da \fBunsigned\fP argument shall be converted ta unsigned octal format
in tha steez \fB"\fP\fIdddd\fP\fB"\fP. The
precision specifies tha minimum number of digits ta appear; if the
value bein converted can be represented up in fewer digits, it
shall be expanded wit leadin zeros. Da default precision is 1.
Da result of convertin zero wit a explicit precision of zero
shall be no characters.
.TP 7
\fBu\fP
Da \fBunsigned\fP argument shall be converted ta unsigned decimal
format up in tha steez \fB"\fP\fIdddd\fP\fB"\fP. The
precision specifies tha minimum number of digits ta appear; if the
value bein converted can be represented up in fewer digits, it
shall be expanded wit leadin zeros. Da default precision is 1.
Da result of convertin zero wit a explicit precision of zero
shall be no characters.
.TP 7
\fBx\fP
Da \fBunsigned\fP argument shall be converted ta unsigned hexadecimal
format up in tha steez \fB"\fP\fIdddd\fP\fB"\fP;
the lettas \fB"abcdef"\fP is used. Y'all KNOW dat shit, muthafucka! Da precision specifies tha minimum
number of digits ta appear; if tha value being
converted can be represented up in fewer digits, it shall be expanded
with leadin zeros. Da default precision is 1. Da result of
convertin zero wit a explicit precision of zero shall be no characters.
.TP 7
\fBX\fP
Equivalent ta tha \fBx\fP conversion specifier, except dat letters
\fB"ABCDEF"\fP is used instead of \fB"abcdef"\fP
\&.
.TP 7
\fBf\fP,\ \fBF\fP
Da \fBdouble\fP argument shall be converted ta decimal notation in
the style
\fB"[-]\fP\fIddd\fP\fB.\fP\fIddd\fP\fB"\fP, where tha number of digits
afta tha radix characta is equal ta the
precision justification. I aint talkin' bout chicken n' gravy biatch. If tha precision is missing, it shall be
taken as 6; if tha precision is explicitly zero n' no
\fB'#'\fP flag is present, no radix characta shall appear. Shiiit, dis aint no joke. If a radix
characta appears, at least one digit appears before dat shit.
Da low-order digit shall be rounded up in a implementation-defined
manner n' shit. 
.LP
A \fBdouble\fP argument representin a infinitizzle shall be converted
in one of tha stylez \fB"[-]inf"\fP or
\fB"[-]infinity"\fP ; which steez is implementation-defined. Y'all KNOW dat shit, muthafucka! A \fBdouble\fP
argument representin a NaN shall be converted in
one of tha stylez \fB"[-]nan(\fP\fIn-char-sequence\fP\fB)"\fP or \fB"[-]nan"\fP
; which style, n' tha meanin of any
\fIn-char-sequence\fP, is implementation-defined. Y'all KNOW dat shit, muthafucka! Da \fBF\fP conversion
specifier produces \fB"INF"\fP,
\fB"INFINITY"\fP, or \fB"NAN"\fP instead of \fB"inf"\fP, \fB"infinity"\fP,
or \fB"nan"\fP, respectively.
.TP 7
\fBe\fP,\ \fBE\fP
Da \fBdouble\fP argument shall be converted up in tha style
\fB"[-]\fP\fId\fP\fB.\fP\fIddd\fP\fBe\(+-\fP\fIdd\fP\fB"\fP, where
there is one digit before tha radix character
(which is non-zero if tha argument is non-zero) n' tha number of
digits afta it is equal ta tha precision; if tha precision is
missing, it shall be taken as 6; if tha precision is zero n' no \fB'#'\fP
flag is present, no radix characta shall appear. Shiiit, dis aint no joke. The
low-order digit shall be rounded up in a implementation-defined manner.
Da \fBE\fP conversion specifier shall produce a number
with \fB'E'\fP instead of \fB'e'\fP introducin tha exponent. The
exponent shall always contain at least two digits, n' you can put dat on yo' toast. If the
value is zero, tha exponent shall be zero. 
.LP
A \fBdouble\fP argument representin a infinitizzle or NaN shall be converted
in tha steez of a \fBf\fP or \fBF\fP
conversion specifier.
.TP 7
\fBg\fP,\ \fBG\fP
Da \fBdouble\fP argument shall be converted up in tha steez \fBf\fP
or \fBe\fP (or up in tha steez \fBF\fP or \fBE\fP
in tha case of a \fBG\fP conversion specifier), wit tha precision
specifyin tha number of dope digits, n' you can put dat on yo' toast. If a explicit
precision is zero, it shall be taken as 1. Da steez used depends
on tha value converted; steez \fBe\fP (or \fBE\fP ) shall
be used only if tha exponent resultin from such a cold-ass lil conversion is less
than -4 or pimped outa than or equal ta tha precision. I aint talkin' bout chicken n' gravy biatch. Trailing
zeros shall be removed from tha fractionizzle portion of tha result;
a radix characta shall step tha fuck up only if it is followed by a gangbangin' finger-lickin' digit
or a \fB'#'\fP flag is present. 
.LP
A \fBdouble\fP argument representin a infinitizzle or NaN shall be converted
in tha steez of a \fBf\fP or \fBF\fP
conversion specifier.
.TP 7
\fBa\fP,\ \fBA\fP
A \fBdouble\fP argument representin a gangbangin' floating-point number shall
be converted up in tha style
\fB"[-]0x\fP\fIh\fP\fB.\fP\fIhhhh\fP\fBp\(+-\fP\fId\fP\fB"\fP, where
there is one hexadecimal digit (which shall
be non-zero if tha argument be a normalized floating-point number
and is otherwise unspecified) before tha decimal-point character
and tha number of hexadecimal digits afta it is equal ta tha precision;
if tha precision is missin n' FLT_RADIX be a juice of 2,
then tha precision shall be sufficient fo' a exact representation
of tha value; if tha precision is missin n' FLT_RADIX aint a
power of 2, then tha precision shall be sufficient ta distinguish
valuez of type \fBdouble\fP, except dat trailin zeros may be
omitted; if tha precision is zero n' tha \fB'#'\fP flag aint specified,
no decimal-point characta shall appear. Shiiit, dis aint no joke. Da letters
\fB"abcdef"\fP shall be used fo' \fBa\fP conversion n' tha letters
\fB"ABCDEF"\fP fo' \fBA\fP conversion. I aint talkin' bout chicken n' gravy biatch. The
\fBA\fP conversion specifier produces a number wit \fB'X'\fP and
\fB'P'\fP instead of \fB'x'\fP n' \fB'p'\fP . The
exponent shall always contain at least one digit, n' only as many
more digits as necessary ta represent tha decimal exponent of 2.
If tha value is zero, tha exponent shall be zero. 
.LP
A \fBdouble\fP argument representin a infinitizzle or NaN shall be converted
in tha steez of a \fBf\fP or \fBF\fP
conversion specifier.
.TP 7
\fBc\fP
Da \fBint\fP argument shall be converted ta a \fBunsigned char\fP,
and tha resultin byte shall be written. I aint talkin' bout chicken n' gravy biatch. 
.LP
If a \fBl\fP (ell) qualifier is present, tha \fBwint_t\fP argument
shall be converted as if by a \fBls\fP conversion
specification wit no precision n' a argument dat points ta a two-element
array of type \fBwchar_t\fP, tha straight-up original gangsta element of
which gotz nuff tha \fBwint_t\fP argument ta tha \fBls\fP conversion
specification n' tha second element gotz nuff a null wide
character.
.TP 7
\fBs\fP
Da argument shall be a pointa ta a array of \fBchar\fP. Bytes from
the array shall be freestyled up ta (but not including) any
terminatin null byte. If tha precision is specified, no mo' than
that nuff bytes shall be written. I aint talkin' bout chicken n' gravy biatch. If tha precision is not
specified or is pimped outa than tha size of tha array, tha application
shall ensure dat tha array gotz nuff a null byte. 
.LP
If a \fBl\fP (ell) qualifier is present, tha argument shall be a
pointa ta a array of type \fBwchar_t\fP. Wide characters
from tha array shall be converted ta charactas (each as if by a cold-ass lil call
to tha \fIwcrtomb\fP() function, wit tha conversion state busted lyrics about
by a \fBmbstate_t\fP object
initialized ta zero before tha straight-up original gangsta wide characta is converted)
up ta n' includin a terminatin null wide character n' shit. The
resultin charactas shall be freestyled up ta (but not including) the
terminatin null characta (byte). If no precision is
specified, tha application shall ensure dat tha array gotz nuff a
null wide character n' shit. If a precision is specified, no mo' than
that nuff charactas (bytes) shall be freestyled (includin shift sequences,
if any), n' tha array shall contain a null wide
characta if, ta equal tha characta sequence length given by the
precision, tha function would need ta access a wide characta one
past tha end of tha array. In no case shall a partial characta be
written.
.TP 7
\fBp\fP
Da argument shall be a pointa ta \fBvoid\fP. Da value of tha pointer
is converted ta a sequence of printable characters, in
an implementation-defined manner.
.TP 7
\fBn\fP
Da argument shall be a pointa ta a integer tha fuck into which is written
the number of bytes freestyled ta tha output so far by this
call ta one of tha \fIfprintf\fP() functions. No argument is converted.
.TP 7
\fBC\fP
Equivalent ta \fBlc\fP . 
.TP 7
\fBS\fP
Equivalent ta \fBls\fP . 
.TP 7
\fB%\fP
Print a \fB'%'\fP character; no argument is converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da complete
conversion justification shall be \fB%%\fP .
.sp
.LP
If a cold-ass lil conversion justification do not match one of tha above forms,
the behavior is undefined. Y'all KNOW dat shit, muthafucka! If any argument aint the
correct type fo' tha correspondin conversion justification, tha behavior
is undefined.
.LP
In no case shall a nonexistent or lil' small-ass field width cause truncation
of a gangbangin' field; if tha result of a cold-ass lil conversion is wider than the
field width, tha field shall be expanded ta contain tha conversion
result. Charactas generated by \fIfprintf\fP() and
\fIprintf\fP() is printed as if \fIfputc\fP() had been called.
.LP
For tha \fBa\fP n' \fBA\fP conversion specifiers, if FLT_RADIX is
a juice of 2, tha value shall be erectly rounded ta a
hexadecimal floatin number wit tha given precision.
.LP
For \fBa\fP n' \fBA\fP conversions, if FLT_RADIX aint a juice of
2 n' tha result aint exactly representable up in the
given precision, tha result should be one of tha two adjacent numbers
in hexadecimal floatin steez wit tha given precision, with
the extra stipulation dat tha error should gotz a cold-ass lil erect sign for
the current roundin direction.
.LP
For tha \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP, n' \fBG\fP
conversion specifiers, if tha number of
significant decimal digits be at most DECIMAL_DIG, then tha result
should be erectly rounded. Y'all KNOW dat shit, muthafucka! If tha number of significant
decimal digits is mo' than DECIMAL_DIG but tha source value is exactly
representable wit DECIMAL_DIG digits, then tha result
should be a exact representation wit trailin zeros. Otherwise,
the source value is bounded by two adjacent decimal strings
\fIL\fP < \fIU\fP, both havin DECIMAL_DIG dope digits; the
value of tha resultant decimal strang \fID\fP should
satisfy \fIL\fP <= \fID\fP <= \fIU\fP, wit tha extra stipulation
that tha error should gotz a cold-ass lil erect sign fo' the
current roundin direction.
.LP
The
\fIst_ctime\fP n' \fIst_mtime\fP fieldz of tha file shall be marked
for update between tha call ta a successful execution of
\fIfprintf\fP() or \fIprintf\fP() n' tha next successful completion
of a cold-ass lil call ta \fIfflush\fP() or \fIfclose\fP() on tha same stream or
a
call ta \fIexit\fP() or \fIabort\fP(). 
.SH RETURN VALUE
.LP
Upon successful completion, tha \fIfprintf\fP() n' \fIprintf\fP()
functions shall return tha number of bytes transmitted.
.LP
Upon successful completion, tha \fIsprintf\fP() function shall return
the number of bytes freestyled ta \fIs\fP, excludin the
terminatin null byte.
.LP
Upon successful completion, tha \fIsnprintf\fP() function shall return
the number of bytes dat would be freestyled ta \fIs\fP
had \fIn\fP been sufficiently big-ass excludin tha terminatin null
byte.
.LP
If a output error was encountered, these functions shall return a
negatizzle value.
.LP
If tha value of \fIn\fP is zero on a cold-ass lil call ta \fIsnprintf\fP(), nothing
shall be written, tha number of bytes dat would have
been freestyled had \fIn\fP been sufficiently big-ass excludin tha terminating
null shall be returned, n' \fIs\fP may be a null
pointer.
.SH ERRORS
.LP
For tha conditions under which \fIfprintf\fP() n' \fIprintf\fP()
fail n' may fail, refer ta \fIfputc\fP() or \fIfputwc\fP().
.LP
In addition, all formz of \fIfprintf\fP() may fail if:
.TP 7
.B EILSEQ
A wide-characta code dat do not correspond ta a valid character
has been detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
.TP 7
.B EINVAL
There is insufficient arguments, n' you can put dat on yo' toast. 
.sp
.LP
Da \fIprintf\fP() n' \fIfprintf\fP() functions may fail if:
.TP 7
.B ENOMEM
Insufficient storage space be available. 
.sp
.LP
Da \fIsnprintf\fP() function shall fail if:
.TP 7
.B EOVERFLOW
Da value of \fIn\fP is pimped outa than {INT_MAX} or tha number of bytes
needed ta hold tha output excludin tha terminatin null is
greata than {INT_MAX}. 
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.SS Printin Language-Independent Date n' Time
.LP
Da followin statement can be used ta print date n' time rockin a
language-independent format:
.sp
.RS
.nf

\fBprintf(format, weekday, month, day, hour, min);
\fP
.fi
.RE
.LP
For Gangsta usage, \fIformat\fP could be a pointa ta tha following
string:
.sp
.RS
.nf

\fB"%s, %s %d, %d:%.2d\\n"
\fP
.fi
.RE
.LP
This example would produce tha followin message:
.sp
.RS
.nf

\fBSunday, July 3, 10:02
\fP
.fi
.RE
.LP
For German usage, \fIformat\fP could be a pointa ta tha following
string:
.sp
.RS
.nf

\fB"%1$s, %3$d. Y'all KNOW dat shit, muthafucka! %2$s, %4$d:%5$.2d\\n"
\fP
.fi
.RE
.LP
This definizzle of \fIformat\fP would produce tha followin message:
.sp
.RS
.nf

\fBSonntag, 3. Juli, 10:02
\fP
.fi
.RE
.SS Printin File Information
.LP
Da followin example prints shiznit bout tha type, permissions,
and number of linkz of a specific file up in a gangbangin' finger-lickin' directory.
.LP
Da first two calls ta \fIprintf\fP() use data decoded from a previous
\fIstat\fP() call.
Da user-defined \fIstrperm\fP() function shall return a strang similar
to tha one all up in tha beginnin of tha output fo' the
followin command:
.sp
.RS
.nf

\fBls -l
\fP
.fi
.RE
.LP
Da next call ta \fIprintf\fP() outputs tha ballerz name if it is
found rockin \fIgetpwuid\fP(); tha \fIgetpwuid\fP() function shall
return a \fBpasswd\fP structure from which tha name of tha user is
extracted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha user name aint found, tha program instead
prints up tha numeric value of tha user ID.
.LP
Da next call prints up tha crew name if it is found rockin \fIgetgrgid\fP();
\fIgetgrgid\fP() is straight-up similar ta \fIgetpwuid\fP() except dat it
shall return crew shiznit based on tha crew number n' shit. Once
again, if tha crew aint found, tha program prints tha numeric value
of tha crew fo' tha entry.
.LP
Da final call ta \fIprintf\fP() prints tha size of tha file.
.sp
.RS
.nf

\fB#include <stdio.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>
.sp

char *strperm (mode_t);
\&...
struct stat statbuf;
struct passwd *pwd;
struct crew *grp;
\&...
printf("%10.10s", strperm (statbuf.st_mode));
printf("%4d", statbuf.st_nlink);
.sp

if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
    printf(" %-8.8s", pwd->pw_name);
else
    printf(" %-8ld", (long) statbuf.st_uid);
.sp

if ((grp = getgrgid(statbuf.st_gid)) != NULL)
    printf(" %-8.8s", grp->gr_name);
else
    printf(" %-8ld", (long) statbuf.st_gid);
.sp

printf("%9jd", (intmax_t) statbuf.st_size);
\&...
\fP
.fi
.RE
.SS Printin a Localized Date String
.LP
Da followin example gets a localized date string. Da \fInl_langinfo\fP()
function shall return tha localized date string, which specifies the
order n' layout of tha date. Da \fIstrftime\fP() function takes
this shiznit and, rockin tha \fBtm\fP structure fo' joints,
places tha date n' time shiznit tha fuck into \fIdatestring\fP. Da \fIprintf\fP()
function then outputs \fIdatestring\fP n' the
name of tha entry.
.sp
.RS
.nf

\fB#include <stdio.h>
#include <time.h>
#include <langinfo.h>
\&...
struct dirent *dp;
struct tm *tm;
char datestring[256];
\&...
strftime(datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
.sp

printf(" %s %s\\n", datestring, dp->d_name);
\&...
\fP
.fi
.RE
.SS Printin Error Information
.LP
Da followin example uses \fIfprintf\fP() ta write error shiznit
to standard error.
.LP
In tha straight-up original gangsta crew of calls, tha program tries ta open tha password
lock file named \fBLOCKFILE\fP. If tha file already exists,
this be a error, as indicated by tha O_EXCL flag on tha \fIopen\fP()
function. I aint talkin' bout chicken n' gravy biatch. If tha call
fails, tha program assumes dat one of mah thugs is uppimpin tha password
file, n' tha program exits.
.LP
Da next crew of calls saves a freshly smoked up password file as tha current password
file by bustin a link between \fBLOCKFILE\fP and
the freshly smoked up password file \fBPASSWDFILE\fP.
.sp
.RS
.nf

\fB#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
.sp

#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
\&...
int pfd;
\&...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
    fprintf(stderr, "Cannot open /etc/ptmp. Try again n' again n' again later.\\n");
    exit(1);
}
\&...
if (link(LOCKFILE,PASSWDFILE) == -1) {
    fprintf(stderr, "Link error: %s\\n", strerror(errno));
    exit(1);
}
\&...
\fP
.fi
.RE
.SS Printin Usage Information
.LP
Da followin example checks ta make shizzle tha program has tha necessary
arguments, n' uses \fIfprintf\fP() ta print usage
information if tha expected number of arguments aint present.
.sp
.RS
.nf

\fB#include <stdio.h>
#include <stdlib.h>
\&...
char *Options = "hdbtl";
\&...
if (argc < 2) {
    fprintf(stderr, "Usage: %s -%s <file\\n", argv[0], Options); exit(1);
}
\&...
\fP
.fi
.RE
.SS Formattin a Decimal String
.LP
Da followin example prints a key n' data pair on \fIstdout\fP.
Note use of tha \fB'*'\fP (asterisk) up in tha format string;
this ensures tha erect number of decimal places fo' tha element
based on tha number of elements requested.
.sp
.RS
.nf

\fB#include <stdio.h>
\&...
long i;
char *keystr;
int elementlen, len;
\&...
while (len < elementlen) {
\&...
    printf("%s Element%0*ld\\n", keystr, elementlen, i);
\&...
}
\fP
.fi
.RE
.SS Creatin a Filename
.LP
Da followin example creates a gangbangin' filename rockin shiznit from a
previous \fIgetpwnam\fP() function dat returned tha HOME directory
of tha user.
.sp
.RS
.nf

\fB#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
\&...
char filename[PATH_MAX+1];
struct passwd *pw;
\&...
sprintf(filename, "%s/%d.out", pw->pw_dir, getpid());
\&...
\fP
.fi
.RE
.SS Reportin a Event
.LP
Da followin example loops until a event has timed out. Da \fIpause\fP()
function
waits forever unless it receives a signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da \fIfprintf\fP() statement
should never occur cuz of tha possible return joints of
\fIpause\fP().
.sp
.RS
.nf

\fB#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
\&...
while (!event_complete) {
\&...
    if (pause() != -1 || errno != EINTR)
        fprintf(stderr, "pause: unknown error: %s\\n", strerror(errno));
}
\&...
\fP
.fi
.RE
.SS Printin Monetary Information
.LP
Da followin example uses \fIstrfmon\fP() ta convert a number and
store it as a
formatted monetary strang named \fIconvbuf\fP. If tha straight-up original gangsta number
is printed, tha program prints tha format n' tha description;
otherwise, it just prints tha number.
.sp
.RS
.nf

\fB#include <monetary.h>
#include <stdio.h>
\&...
struct tblfmt {
    char *format;
    char *description;
};
.sp

struct tblfmt table[] = {
    { "%n", "default formatting" },
    { "%11n", "right align within a 11 characta field" },
    { "%#5n", "aligned columns fo' joints up ta 99999" },
    { "%=*#5n", "specify a gangbangin' fill character" },
    { "%=0#5n", "fill charactas do not use grouping" },
    { "%^#5n", "disable tha groupin separator" },
    { "%^#5.0n", "round off ta whole units" },
    { "%^#5.4n", "increase tha precision" },
    { "%(#5n", "use a alternatizzle pos/neg style" },
    { "%!(#5n", "disable tha currency symbol" },
};
\&...
float input[3];
int i, j;
char convbuf[100];
\&...
strfmon(convbuf, sizeof(convbuf), table[i].format, input[j]);
.sp

if (j == 0) {
    printf("%s  %s  %s\\n", table[i].format,
        convbuf, table[i].description);
}
else {
    printf("    %s\\n", convbuf);
}
\&...
\fP
.fi
.RE
.SS Printin Wide Characters
.LP
Da followin example prints a seriez of wide characters. Right back up in yo muthafuckin ass. Suppose
that \fB"L`@`"\fP expandz ta three bytes:
.sp
.RS
.nf

\fBwchar_t wz [3] = L"@@";       // Zero-terminated
wchar_t wn [3] = L"@@@";      // Unterminated
.sp

fprintf (stdout,"%ls", wz);   // Outputs 6 bytes
fprintf (stdout,"%ls", wn);   // Undefined cuz wn has no terminator
fprintf (stdout,"%4ls", wz);  // Outputs 3 bytes
fprintf (stdout,"%4ls", wn);  // Outputs 3 bytes; no terminator needed
fprintf (stdout,"%9ls", wz);  // Outputs 6 bytes
fprintf (stdout,"%9ls", wn);  // Outputs 9 bytes; no terminator needed
fprintf (stdout,"%10ls", wz); // Outputs 6 bytes
fprintf (stdout,"%10ls", wn); // Undefined cuz wn has no terminator
\fP
.fi
.RE
.LP
In tha last line of tha example, afta processin three characters,
nine bytes done been output. Da fourth characta must then
be examined ta determine whether it converts ta one byte or more.
If it converts ta mo' than one byte, tha output is only nine
bytes. Right back up in yo muthafuckin ass. Since there is no fourth characta up in tha array, tha behavior
is undefined.
.SH APPLICATION USAGE
.LP
If tha application callin \fIfprintf\fP() has any objectz of type
\fBwint_t\fP or \fBwchar_t\fP, it must also include tha \fI<wchar.h>\fP
header ta have these objects defined.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIfputc\fP(), \fIfscanf\fP(), \fIsetlocale\fP(), \fIstrfmon\fP(),
\fIwcrtomb\fP(),
the Base Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 7,
Locale, \fI<stdio.h>\fP, \fI<wchar.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
