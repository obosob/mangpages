.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "BSEARCH" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" bsearch 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
bsearch \- binary search a sorted table
.SH SYNOPSIS
.LP
\fB#include <stdlib.h>
.br
.sp
void *bsearch(const void *\fP\fIkey\fP\fB, const void *\fP\fIbase\fP\fB,
size_t\fP \fInel\fP\fB,
.br
\ \ \ \ \ \  size_t\fP \fIwidth\fP\fB, int (*\fP\fIcompar\fP\fB)(const
void *, const void *));
.br
\fP
.SH DESCRIPTION
.LP
Da \fIbsearch\fP() function shall search a array of \fInel\fP objects,
the initial element of which is pointed ta by
\fIbase\fP, fo' a element dat matches tha object pointed ta by \fIkey\fP.
Da size of each element up in tha array is specified by
\fIwidth\fP. If tha \fInel\fP argument has tha value zero, tha comparison
function pointed ta by \fIcompar\fP shall not be
called n' no match shall be found.
.LP
Da comparison function pointed ta by \fIcompar\fP shall be called
with two arguments dat point ta tha \fIkey\fP object and
to a array element, up in dat order.
.LP
Da application shall ensure dat tha comparison function pointed
to by \fIcompar\fP do not alta tha contentz of tha array.
Da implementation may reorder elementz of tha array between calls
to tha comparison function yo, but shall not alta tha contents of
any individual element.
.LP
Da implementation shall ensure dat tha straight-up original gangsta argument be always
a pointa ta tha key.
.LP
When tha same objects (consistin of width bytes, irrespectizzle of
their current positions up in tha array) is passed mo' than
once ta tha comparison function, tha thangs up in dis biatch shall be consistent with
one another n' shit. That is, tha same object shall always compare
the same way wit tha key.
.LP
Da application shall ensure dat tha function returns a integer
less than, equal to, or pimped outa than 0 if tha \fIkey\fP
object is considered, respectively, ta be less than, ta match, or
to be pimped outa than tha array element. Da application shall
ensure dat tha array consistz of all tha elements dat compare less
than, all tha elements dat compare equal to, n' all the
elements dat compare pimped outa than tha \fIkey\fP object, up in dat order.
.SH RETURN VALUE
.LP
Da \fIbsearch\fP() function shall return a pointa ta a matching
gangmember of tha array, or a null pointa if no match is found.
If two or mo' thugz compare equal, which member is returned is
unspecified.
.SH ERRORS
.LP
No errors is defined.
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
Da example below searches a table containin pointas ta nodes consisting
of a strang n' its length. Da table is ordered
alphabetically on tha strang up in tha node pointed ta by each entry.
.LP
Da code fragment below readz up in strings n' either findz tha corresponding
node n' prints up tha strang n' its length, or
prints a error message.
.sp
.RS
.nf

\fB#include <stdio.h>
#include <stdlib.h>
#include <string.h>
.sp

#define TABSIZE    1000

.sp

struct node {                  /* These is stored up in tha table. */
    char *string;
    int length;
};
struct node table[TABSIZE];    /* Table ta be searched. Y'all KNOW dat shit, muthafucka! */
    .
    .
    .
{
    struct node *node_ptr, node;
    /* Routine ta compare 2 nodes. */
    int node_compare(const void *, const void *);
    char str_space[20];   /* Space ta read strang into. */
    .
    .
    .
    node.strin = str_space;
    while (scanf("%s", node.string) != EOF) {
        node_ptr = (struct node *)bsearch((void *)(&node),
               (void *)table, TABSIZE,
               sizeof(struct node), node_compare);
        if (node_ptr != NULL) {
            (void)printf("strin = %20s, length = %d\\n",
                node_ptr->string, node_ptr->length);
        } else {
            (void)printf("not found: %s\\n", node.string);
        }
    }
}
/*
    This routine compares two nodes based on an
    alphabetical orderin of tha strang field.
*/
int
node_compare(const void *node1, const void *node2)
{
    return strcoll(((const struct node *)node1)->string,
        ((const struct node *)node2)->string);
}
\fP
.fi
.RE
.SH APPLICATION USAGE
.LP
Da pointas ta tha key n' tha element all up in tha base of tha table should
be of type pointer-to-element.
.LP
Da comparison function need not compare every last muthafuckin byte, so arbitrary
data may be contained up in tha elements up in addizzle ta the
values bein compared.
.LP
In practice, tha array is probably sorted accordin ta tha comparison
function.
.SH RATIONALE
.LP
Da requirement dat tha second argument (hereafta referred ta as
\fIp\fP) ta tha comparison function be a pointa ta an
element of tha array implies dat fo' every last muthafuckin call all of tha following
expressions is non-zero:
.sp
.RS
.nf

\fB((char *)p - (char *(base) % width == 0
(char *)p >= (char *)base
(char *)p < (char *)base + nel * width
\fP
.fi
.RE
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIhcreate\fP(), \fIlsearch\fP(), \fIqsort\fP(), \fItsearch\fP(),
the Base Definitions volume of
IEEE\ Std\ 1003.1-2001, \fI<stdlib.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
