.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "FWSCANF" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" fwscanf 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
fwscanf, swscanf, wscanf \- convert formatted wide-characta input
.SH SYNOPSIS
.LP
\fB#include <stdio.h>
.br
#include <wchar.h>
.br
.sp
int fwscanf(FILE *restrict\fP \fIstream\fP\fB, const wchar_t *restrict\fP
\fIformat\fP\fB, ... );
.br
int swscanf(const wchar_t *restrict\fP \fIws\fP\fB,
.br
\ \ \ \ \ \  const wchar_t *restrict\fP \fIformat\fP\fB, ... );
.br
int wscanf(const wchar_t *restrict\fP \fIformat\fP\fB, ... );
.br
\fP
.SH DESCRIPTION
.LP
Da \fIfwscanf\fP() function shall read from tha named input \fIstream\fP.
Da \fIwscanf\fP() function shall read from the
standard input stream \fIstdin\fP. Da \fIswscanf\fP() function shall
read from tha wide-characta strang \fIws\fP. Each
function readz wide characters, interprets dem accordin ta a gangbangin' format,
and stores tha thangs up in dis biatch up in its arguments, n' you can put dat on yo' toast. Each expects, as
arguments, a cold-ass lil control wide-characta strang \fIformat\fP busted lyrics about
below, n' a set of \fIpointer\fP arguments indicatin where
the converted input should be stored. Y'all KNOW dat shit, muthafucka! Da result is undefined if there
are insufficient arguments fo' tha format. If the
\fIformat\fP is exhausted while arguments remain, tha excess arguments
are evaluated but is otherwise ignored.
.LP
Conversions can be applied ta tha \fIn\fPth argument afta tha \fIformat\fP
in tha argument list, rather than ta tha next unused
argument. In dis case, tha conversion specifier wide characta \fB%\fP
(see below) is replaced by tha sequence \fB"%n$"\fP,
where \fIn\fP be a thugged-out decimal integer up in tha range [1,{NL_ARGMAX}]. This
feature serves up fo' tha definizzle of \fIformat\fP
wide-characta strings dat select arguments up in a order appropriate
to specific languages. In \fIformat\fP wide-characta strings
containin tha \fB"%\fP\fIn\fP\fB$"\fP form of conversion justifications,
it is unspecified whether numbered arguments in
the argument list can be referenced from tha \fIformat\fP wide-character
strin mo' than once.
.LP
Da \fIformat\fP can contain either form of a cold-ass lil conversion justification-that
is, \fB%\fP or \fB"%\fP\fIn\fP\fB$"\fP-
but tha two forms cannot normally be mixed within a single \fIformat\fP
wide-characta string. Da only exception ta dis is that
\fB%%\fP or \fB%*\fP can be mixed wit tha \fB"%\fP\fIn\fP\fB$"\fP
form. When numbered argument justifications are
used, specifyin tha \fIN\fPth argument requires dat all tha leading
arguments, from tha straight-up original gangsta ta tha ( \fIN\fP-1)th, are
pointers. 
.LP
The
\fIfwscanf\fP() function up in all its forms allows fo' detection of
a language-dependent radix characta up in tha input string,
encoded as a wide-characta value. Da radix characta is defined
in tha programz locale (category \fILC_NUMERIC ).\fP In the
POSIX locale, or up in a locale where tha radix characta aint defined,
the radix characta shall default ta a period ( \fB'.'\fP
). 
.LP
Da \fIformat\fP be a wide-characta strang composed of zero or more
directives. Each directizzle is composed of one of the
following: one or mo' white-space wide charactas ( <space>s, <tab>s,
<newline>s, <vertical-tab>s, or
<form-feed>s); a ordinary wide characta (neither \fB'%'\fP nor a
white-space character); or a cold-ass lil conversion justification.
Each conversion justification is introduced by a \fB'%'\fP  or
the sequence \fB"%\fP\fIn\fP\fB$"\fP  afta which tha followin appear
in sequence:
.IP " *" 3
An optionizzle assignment-suppressin characta \fB'*'\fP .
.LP
.IP " *" 3
An optionizzle non-zero decimal integer dat specifies tha maximum field
width.
.LP
.IP " *" 3
An optionizzle length modifier dat specifies tha size of tha receiving
object.
.LP
.IP " *" 3
A conversion specifier wide characta dat specifies tha type of conversion
to be applied. Y'all KNOW dat shit, muthafucka! Da valid conversion specifiers are
busted lyrics bout below.
.LP
.LP
Da \fIfwscanf\fP() functions shall execute each directizzle of the
format up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If a gangbangin' finger-lickin' directizzle fails, as detailed below, the
function shall return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Failures is busted lyrics bout as input failures (due
to tha unavailabilitizzle of input bytes) or matchin failures
(due ta inappropriate input).
.LP
A directizzle composed of one or mo' white-space wide charactas is
executed by readin input until no mo' valid input can be
read, or up ta tha straight-up original gangsta wide characta which aint a white-space
wide character, which remains unread.
.LP
A directizzle dat be a ordinary wide characta shall be executed as
bigs up. Da next wide characta is read from tha input and
compared wit tha wide characta dat comprises tha directive; if
the comparison shows dat they is not equivalent, tha directive
shall fail, n' tha differin n' subsequent wide charactas remain
unread. Y'all KNOW dat shit, muthafucka! Similarly, if end-of-file, a encodin error, or a read
error prevents a wide characta from bein read, tha directizzle shall
fail.
.LP
A directizzle dat be a cold-ass lil conversion justification defines a set of matching
input sequences, as busted lyrics bout below fo' each conversion
wide character n' shiznit fo' realz. A conversion justification is executed up in tha following
steps.
.LP
Input white-space wide charactas (as specified by \fIiswspace\fP()
) shall be skipped, unless the
conversion justification includes a \fB[\fP, \fBc\fP, or \fBn\fP
conversion specifier.
.LP
An item shall be read from tha input, unless tha conversion justification
includes a \fBn\fP conversion specifier wide
character n' shiznit fo' realz. An input item is defined as tha longest sequence of input
wide characters, not exceedin any specified field width,
which be a initial subsequence of a matchin sequence. Da first
wide character, if any, afta tha input item shall remain unread.
If tha length of tha input item is zero, tha execution of tha conversion
specification shall fail; dis condizzle be a matching
failure, unless end-of-file, a encodin error, or a read error prevented
input from tha stream, up in which case it be a input
failure.
.LP
Except up in tha case of a \fB%\fP conversion specifier, tha input item
(or, up in tha case of a \fB%n\fP conversion
specification, tha count of input wide characters) shall be converted
to a type appropriate ta tha conversion wide character n' shit. If
the input item aint a matchin sequence, tha execution of tha conversion
specification shall fail; dis condizzle be a matching
failure. Unless assignment suppression was indicated by a \fB'*'\fP,
the result of tha conversion shall be placed up in tha object
pointed ta by tha straight-up original gangsta argument followin tha \fIformat\fP argument
that has not already received a cold-ass lil conversion result if the
conversion justification is introduced by \fB%\fP,  or up in the
\fIn\fPth argument if introduced by tha wide-character
sequence \fB"%\fP\fIn\fP\fB$"\fP.  If dis object do not
have a appropriate type, or if tha result of tha conversion cannot
be represented up in tha space provided, tha behavior is
undefined.
.LP
Da length modifiers n' they meanings are:
.TP 7
\fBhh\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBsigned
char\fP or \fBunsigned char\fP.
.TP 7
\fBh\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBshort\fP
or \fBunsigned short\fP.
.TP 7
\fBl\fP\ (ell)
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBlong\fP
or \fBunsigned long\fP; dat a gangbangin' followin \fBa\fP,
\fBA\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP, or \fBG\fP
conversion specifier applies ta an
argument wit type pointa ta \fBdouble\fP; or dat a gangbangin' followin \fBc\fP,
\fBs\fP, or \fB[\fP conversion specifier
applies ta a argument wit type pointa ta \fBwchar_t\fP.
.TP 7
\fBll\fP\ (ell-ell)
.sp
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP conversion
specifier applies ta a argument wit type pointa ta \fBlong long\fP
or \fBunsigned long long\fP.
.TP 7
\fBj\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBintmax_t\fP
or \fBuintmax_t\fP.
.TP 7
\fBz\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBsize_t\fP
or tha correspondin signed integer type.
.TP 7
\fBt\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBptrdiff_t\fP
or tha correspondin \fBunsigned\fP type.
.TP 7
\fBL\fP
Specifies dat a gangbangin' followin \fBa\fP, \fBA\fP, \fBe\fP, \fBE\fP,
\fBf\fP, \fBF\fP, \fBg\fP, or
\fBG\fP conversion specifier applies ta a argument wit type pointer
to \fBlong double\fP.
.sp
.LP
If a length modifier appears wit any conversion specifier other than
as specified above, tha behavior is undefined.
.LP
Da followin conversion specifier wide charactas is valid:
.TP 7
\fBd\fP
Matches a optionally signed decimal integer, whose format is the
same as expected fo' tha subject sequence of \fIwcstol\fP() wit the
value 10 fo' tha \fIbase\fP argument. In tha absence of a size modifier,
the application shall ensure dat tha correspondin argument be a
pointa ta \fBint\fP.
.TP 7
\fBi\fP
Matches a optionally signed integer, whose format is tha same ol' dirty as
expected fo' tha subject sequence of \fIwcstol\fP() wit 0 fo' the
\fIbase\fP argument. In tha absence of a size modifier, the
application shall ensure dat tha correspondin argument be a pointer
to \fBint\fP.
.TP 7
\fBo\fP
Matches a optionally signed octal integer, whose format is tha same
as expected fo' tha subject sequence of \fIwcstoul\fP() wit tha value
8 fo' tha \fIbase\fP argument. In tha absence of a size modifier,
the application shall ensure dat tha correspondin argument be a
pointa ta \fBunsigned\fP.
.TP 7
\fBu\fP
Matches a optionally signed decimal integer, whose format is the
same as expected fo' tha subject sequence of \fIwcstoul\fP() with
the value 10 fo' tha \fIbase\fP argument. In tha absence of a size
modifier,
the application shall ensure dat tha correspondin argument be a
pointa ta \fBunsigned\fP.
.TP 7
\fBx\fP
Matches a optionally signed hexadecimal integer, whose format is
the same as expected fo' tha subject sequence of \fIwcstoul\fP() with
the value 16 fo' tha \fIbase\fP argument. In tha absence of a size
modifier,
the application shall ensure dat tha correspondin argument be a
pointa ta \fBunsigned\fP.
.TP 7
\fBa\fP,\ \fBe\fP,\ \fBf\fP,\ \fBg\fP
.sp
Matches a optionally signed floating-point number, infinity, or NaN
whose format is tha same ol' dirty as expected fo' tha subject sequence
of \fIwcstod\fP(). In tha absence of a size modifier, tha application
shall ensure dat the
correspondin argument be a pointa ta \fBfloat\fP. 
.LP
If tha \fIfwprintf\fP() crew of functions generates characta string
representations
for infinitizzle n' NaN (a symbolic entitizzle encoded up in floating-point
format) ta support IEEE\ Std\ 754-1985, the
\fIfwscanf\fP() crew of functions shall recognize dem as input.
.TP 7
\fBs\fP
Matches a sequence of non white-space wide characters. If no \fBl\fP
(ell) qualifier is present, charactas from tha input
field shall be converted as if by repeated calls ta tha \fIwcrtomb\fP()
function, wit the
conversion state busted lyrics bout by a \fBmbstate_t\fP object initialized
to zero before tha straight-up original gangsta wide characta is converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. The
application shall ensure dat tha correspondin argument be a pointer
to a cold-ass lil characta array big-ass enough ta accept tha sequence and
the terminatin null character, which shall be added automatically.
.LP
Otherwise, tha application shall ensure dat tha correspondin argument
is a pointa ta a array of \fBwchar_t\fP big-ass enough
to accept tha sequence n' tha terminatin null wide character, which
shall be added automatically.
.TP 7
\fB[\fP
Matches a non-empty sequence of wide charactas from a set of expected
wide charactas (the \fIscanset\fP). If no \fBl\fP
(ell) qualifier is present, wide charactas from tha input field shall
be converted as if by repeated calls ta tha \fIwcrtomb\fP() function,
with tha conversion state busted lyrics bout by a \fBmbstate_t\fP object
initialized ta zero before tha straight-up original gangsta wide characta is converted.
Da application shall ensure dat tha correspondin argument be a
pointa ta a cold-ass lil characta array big-ass enough ta accept tha sequence and
the terminatin null character, which shall be added
automatically. 
.LP
If a \fBl\fP (ell) qualifier is present, tha application shall ensure
that tha correspondin argument be a pointa ta an
array of \fBwchar_t\fP big-ass enough ta accept tha sequence n' the
terminatin null wide character, which shall be added
automatically.
.LP
Da conversion justification includes all subsequent wide characters
in tha \fIformat\fP strang up ta n' includin the
matchin right square bracket ( \fB']'\fP ). Da wide charactas between
the square brackets (the \fIscanlist\fP) comprise the
scanset, unless tha wide characta afta tha left square bracket is
a circumflex ( \fB'^'\fP ), up in which case tha scanset
gotz nuff all wide charactas dat do not step tha fuck up in tha scanlist between
the circumflex n' tha right square bracket. If the
conversion justification begins wit \fB"[]"\fP or \fB"[^]"\fP, the
right square bracket is included up in tha scanlist n' the
next right square bracket is tha matchin right square bracket that
endz tha conversion justification; otherwise, tha straight-up original gangsta right
square bracket is tha one dat endz tha conversion justification.
If a \fB'-'\fP is up in tha scanlist n' aint tha straight-up original gangsta wide
character, nor tha second where tha straight-up original gangsta wide characta be a \fB'^'\fP,
nor tha last wide character, tha behavior is
implementation-defined.
.TP 7
\fBc\fP
Matches a sequence of wide charactaz of exactly tha number specified
by tha field width (1 if no field width is present up in the
conversion justification). 
.LP
If no \fBl\fP (ell) length modifier is present, charactas from the
input field shall be converted as if by repeated calls to
the \fIwcrtomb\fP() function, wit tha conversion state busted lyrics about
by a \fBmbstate_t\fP
object initialized ta zero before tha straight-up original gangsta wide characta is converted.
Da correspondin argument shall be a pointa ta the
initial element of a cold-ass lil characta array big-ass enough ta accept tha sequence.
No null characta be added.
.LP
If a \fBl\fP (ell) length modifier is present, tha corresponding
argument shall be a pointa ta tha initial element of an
array of \fBwchar_t\fP big-ass enough ta accept tha sequence. No null
wide characta be added.
.LP
Otherwise, tha application shall ensure dat tha correspondin argument
is a pointa ta a array of \fBwchar_t\fP big-ass enough
to accept tha sequence. No null wide characta be added.
.TP 7
\fBp\fP
Matches a implementation-defined set of sequences, which shall be
the same as tha set of sequences dat is produced by the
\fB%p\fP conversion justification of tha correspondin \fIfwprintf\fP()
functions. The
application shall ensure dat tha correspondin argument be a pointer
to a pointa ta \fBvoid\fP. Da interpretation of tha input
item is implementation-defined. Y'all KNOW dat shit, muthafucka! If tha input item be a value converted
earlier durin tha same program execution, tha pointa that
results shall compare equal ta dat value; otherwise, tha behavior
of tha \fB%p\fP conversion is undefined.
.TP 7
\fBn\fP
No input is consumed. Y'all KNOW dat shit, muthafucka! Da application shall ensure dat tha corresponding
argument be a pointa ta tha integer tha fuck into which is to
be freestyled tha number of wide charactas read from tha input so far
by dis call ta tha \fIfwscanf\fP() functions. Execution of a
\fB%n\fP conversion justification shall not increment tha assignment
count returned all up in tha completion of execution of the
function. I aint talkin' bout chicken n' gravy biatch. No argument shall be converted yo, but one shall be consumed.
If tha conversion justification includes an
assignment-suppressin wide characta or a gangbangin' field width, tha behavior
is undefined.
.TP 7
\fBC\fP
Equivalent ta \fBlc\fP . 
.TP 7
\fBS\fP
Equivalent ta \fBls\fP . 
.TP 7
\fB%\fP
Matches a single \fB'%'\fP wide character; no conversion or assignment
shall occur. Shiiit, dis aint no joke. Da complete conversion justification
shall be \fB%%\fP .
.sp
.LP
If a cold-ass lil conversion justification is invalid, tha behavior is undefined.
.LP
Da conversion specifiers \fBA\fP, \fBE\fP, \fBF\fP, \fBG\fP,
and \fBX\fP is also valid n' shall be
equivalent to, respectively, \fBa\fP, \fBe\fP, \fBf\fP, \fBg\fP,
and \fBx\fP .
.LP
If end-of-file is encountered durin input, conversion is terminated.
If end-of-file occurs before any wide charactas matching
the current conversion justification (except fo' \fB%n\fP ) have been
read (other than leadin white-space, where permitted),
execution of tha current conversion justification shall terminate
with a input failure. Otherwise, unless execution of tha current
conversion justification is terminated wit a matchin failure, execution
of tha followin conversion justification (if any) shall
be terminated wit a input failure.
.LP
Reachin tha end of tha strang up in \fIswscanf\fP() shall be equivalent
to encounterin end-of-file fo' \fIfwscanf\fP().
.LP
If conversion terminates on a cold-ass lil conflictin input, tha offendin input
shall be left unread up in tha input fo' realz. Any trailin white space
(includin <newline>) shall be left unread unless matched by a cold-ass lil conversion
specification. I aint talkin' bout chicken n' gravy biatch. Da success of literal matches and
suppressed assignments is only directly determinable via tha \fB%n\fP
conversion justification.
.LP
The
\fIfwscanf\fP() n' \fIwscanf\fP() functions may mark tha \fIst_atime\fP
field of tha file associated wit \fIstream\fP for
update. Da \fIst_atime\fP field shall be marked fo' update by the
first successful execution of \fIfgetc\fP(), \fIfgetwc\fP(), \fIfgets\fP(),
\fIfgetws\fP(), \fIfread\fP(), \fIgetc\fP(), \fIgetwc\fP(), \fIgetchar\fP(),
\fIgetwchar\fP(), \fIgets\fP(), \fIfscanf\fP(), or \fIfwscanf\fP()
usin \fIstream\fP dat returns data not supplied by a prior
call ta \fIungetc\fP(). 
.SH RETURN VALUE
.LP
Upon successful completion, these functions shall return tha number
of successfully matched n' assigned input items; this
number can be zero up in tha event of a early matchin failure. If the
input endz before tha straight-up original gangsta matchin failure or conversion,
EOF shall be returned. Y'all KNOW dat shit, muthafucka! If a read error occurs, tha error indicator
for tha stream is set, EOF shall be returned,  and
\fIerrno\fP shall be set ta indicate tha error. Shiiit, dis aint no joke. 
.SH ERRORS
.LP
For tha conditions under which tha \fIfwscanf\fP() functions shall
fail n' may fail, refer ta \fIfgetwc\fP().
.LP
In addition, \fIfwscanf\fP() may fail if:
.TP 7
.B EILSEQ
Input byte sequence do not form a valid character n' shit. 
.TP 7
.B EINVAL
There is insufficient arguments, n' you can put dat on yo' toast. 
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
Da call:
.sp
.RS
.nf

\fBint i, n; float x; char name[50];
n = wscanf(L"%d%f%s", &i, &x, name);
\fP
.fi
.RE
.LP
with tha input line:
.sp
.RS
.nf

\fB25 54.32E-1 Hamster
\fP
.fi
.RE
.LP
assigns ta \fIn\fP tha value 3, ta \fIi\fP tha value 25, ta \fIx\fP
the value 5.432, n' \fIname\fP gotz nuff tha string
\fB"Hamster"\fP .
.LP
Da call:
.sp
.RS
.nf

\fBint i; float x; char name[50];
(void) wscanf(L"%2d%f%*d %[0123456789]", &i, &x, name);
\fP
.fi
.RE
.LP
with input:
.sp
.RS
.nf

\fB56789 0123 56a72
\fP
.fi
.RE
.LP
assigns 56 ta \fIi\fP, 789.0 ta \fIx\fP, skips 0123, n' places the
strin \fB"56\\0"\fP up in \fIname\fP. Da next call ta \fIgetchar\fP()
shall return tha characta \fB'a'\fP .
.SH APPLICATION USAGE
.LP
In format strings containin tha \fB'%'\fP form of conversion justifications,
each argument up in tha argument list is used
exactly once.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIgetwc\fP(), \fIfwprintf\fP(), \fIsetlocale\fP(), \fIwcstod\fP(),
\fIwcstol\fP(),
\fIwcstoul\fP(), \fIwcrtomb\fP(), tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Chapta 7, Locale, \fI<langinfo.h>\fP, \fI<stdio.h>\fP,
\fI<wchar.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
