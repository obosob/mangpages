.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "FCNTL" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" fcntl 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
fcntl \- file control
.SH SYNOPSIS
.LP
\fB#include <unistd.h> \fP
\fB
.br
#include <fcntl.h>
.br
.sp
int fcntl(int\fP \fIfildes\fP\fB, int\fP \fIcmd\fP\fB, ...);
.br
\fP
.SH DESCRIPTION
.LP
Da \fIfcntl\fP() function shall big-ass up tha operations busted lyrics about
below on open files. Da \fIfildes\fP argument be a gangbangin' file
descriptor.
.LP
Da available joints fo' \fIcmd\fP is defined up in \fI<fcntl.h>\fP
and is as
bigs up:
.TP 7
F_DUPFD
Return a freshly smoked up file descriptor which shall be tha lowest numbered available
(that is, not already open) file descriptor pimped outer
than or equal ta tha third argument, \fIarg\fP, taken as a integer
of type \fBint\fP. Da freshly smoked up file descriptor shall refer ta the
same open file description as tha original gangsta file descriptor, n' shall
share any locks. Da FD_CLOEXEC flag associated wit tha new
file descriptor shall be cleared ta keep tha file open across calls
to one of tha \fIexec\fP
functions.
.TP 7
F_GETFD
Git tha file descriptor flags defined up in \fI<fcntl.h>\fP dat are
associated with
the file descriptor \fIfildes\fP. File descriptor flags is associated
with a single file descriptor n' do not affect other file
descriptors dat refer ta tha same file.
.TP 7
F_SETFD
Set tha file descriptor flags defined up in \fI<fcntl.h>\fP, dat are
associated
with \fIfildes\fP, ta tha third argument, \fIarg\fP, taken as type
\fBint\fP. If tha FD_CLOEXEC flag up in tha third argument is 0,
the file shall remain open across tha \fIexec\fP functions; otherwise,
the file shall be
closed upon successful execution of one of tha \fIexec\fP functions.
.TP 7
F_GETFL
Git tha file status flags n' file access modes, defined up in \fI<fcntl.h>\fP,
for
the file description associated wit \fIfildes\fP. Da file access
modes can be extracted from tha return value rockin tha mask
O_ACCMODE, which is defined up in \fI<fcntl.h>\fP. File status flags
and file access
modes is associated wit tha file description n' do not affect other
file descriptors dat refer ta tha same file wit different
open file descriptions.
.TP 7
F_SETFL
Set tha file status flags, defined up in \fI<fcntl.h>\fP, fo' tha file
description
associated wit \fIfildes\fP from tha correspondin bits up in tha third
argument, \fIarg\fP, taken as type \fBint\fP. Bits
correspondin ta tha file access mode n' tha file creation flags,
as defined up in \fI<fcntl.h>\fP, dat is set up in \fIarg\fP shall be
ignored. Y'all KNOW dat shit, muthafucka! If any bits up in \fIarg\fP other
than dem mentioned here is chizzled by tha application, tha result
is unspecified.
.TP 7
F_GETOWN
If \fIfildes\fP refers ta a socket, git tha process or process group
ID specified ta receive SIGURG signals when out-of-band
data be available. Positizzle joints indicate a process ID; negative
values, other than -1, indicate a process crew ID. If
\fIfildes\fP do not refer ta a socket, tha thangs up in dis biatch is unspecified.
.TP 7
F_SETOWN
If \fIfildes\fP refers ta a socket, set tha process or process group
ID specified ta receive SIGURG signals when out-of-band
data be available, rockin tha value of tha third argument, \fIarg\fP,
taken as type \fBint\fP. Positizzle joints indicate a process
ID; wack joints, other than -1, indicate a process crew ID. If
\fIfildes\fP do not refer ta a socket, tha thangs up in dis biatch are
unspecified.
.sp
.LP
Da followin joints fo' \fIcmd\fP is available fo' advisory record
locking. Record lockin shall be supported fo' regular
files, n' may be supported fo' other files.
.TP 7
F_GETLK
Git tha straight-up original gangsta lock which blocks tha lock description pointed ta by
the third argument, \fIarg\fP, taken as a pointa ta type
\fBstruct flock\fP, defined up in \fI<fcntl.h>\fP. Da shiznit retrieved
shall
overwrite tha shiznit passed ta \fIfcntl\fP() up in tha structure
\fBflock\fP. If no lock is found dat would prevent dis lock
from bein pimped, then tha structure shall be left unchanged except
for tha lock type which shall be set ta F_UNLCK.
.TP 7
F_SETLK
Set or clear a gangbangin' file segment lock accordin ta tha lock description
pointed ta by tha third argument, \fIarg\fP, taken as a
pointa ta type \fBstruct flock\fP, defined up in \fI<fcntl.h>\fP. F_SETLK
can
establish shared (or read) locks (F_RDLCK) or exclusive (or write)
locks (F_WRLCK), as well as ta remove either type of lock
(F_UNLCK). F_RDLCK, F_WRLCK, n' F_UNLCK is defined up in \fI<fcntl.h>\fP.
If a gangbangin' finger-lickin' dirty-ass shared
or exclusive lock cannot be set, \fIfcntl\fP() shall return immediately
with a return value of -1.
.TP 7
F_SETLKW
This command shall be equivalent ta F_SETLK except dat if a gangbangin' finger-lickin' dirty-ass shared
or exclusive lock is blocked by other locks, tha thread
shall wait until tha request can be satisfied. Y'all KNOW dat shit, muthafucka! If a signal dat is
to be caught is received while \fIfcntl\fP() is waitin fo' a
region, \fIfcntl\fP() shall be interrupted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Upon return from tha signal
handlez, \fIfcntl\fP() shall return -1 wit \fIerrno\fP
set ta [EINTR], n' tha lock operation shall not be done.
.sp
.LP
Additionizzle implementation-defined joints fo' \fIcmd\fP may be defined
in \fI<fcntl.h>\fP. Their names shall start wit F_.
.LP
When a gangbangin' finger-lickin' dirty-ass shared lock is set on a segment of a gangbangin' file, other processes
shall be able ta set shared locks on dat segment or a portion
of it fo' realz. A shared lock prevents any other process from settin a exclusive
lock on any portion of tha protected area fo' realz. A request for
a shared lock shall fail if tha file descriptor was not opened with
read access.
.LP
An exclusive lock shall prevent any other process from settin a gangbangin' finger-lickin' dirty-ass shared
lock or a exclusive lock on any portion of the
protected area fo' realz. A request fo' a exclusive lock shall fail if the
file descriptor was not opened wit write access.
.LP
Da structure \fBflock\fP raps bout tha type ( \fIl_type\fP), starting
offset ( \fIl_whence\fP), relatizzle offset (
\fIl_start\fP), size ( \fIl_len\fP), n' process ID ( \fIl_pid\fP)
of tha segment of tha file ta be affected.
.LP
Da value of \fIl_whence\fP is SEEK_SET, SEEK_CUR, or SEEK_END, to
indicate dat tha relatizzle offset \fIl_start\fP bytes shall
be measured from tha start of tha file, current position, or end of
the file, respectively. Da value of \fIl_len\fP is tha number
of consecutizzle bytes ta be locked. Y'all KNOW dat shit, muthafucka! Da value of \fIl_len\fP may be
negatizzle (where tha definizzle of \fBoff_t\fP permits negative
valuez of \fIl_len\fP). Da \fIl_pid\fP field is only used wit F_GETLK
to return tha process ID of tha process holdin a
blockin lock fo' realz. Afta a successful F_GETLK request, when a funky-ass blocking
lock is found, tha joints returned up in tha \fBflock\fP structure
shall be as bigs up:
.TP 7
\fIl_type\fP
Type of blockin lock found.
.TP 7
\fIl_whence\fP
SEEK_SET.
.TP 7
\fIl_start\fP
Start of tha blockin lock.
.TP 7
\fIl_len\fP
Length of tha blockin lock.
.TP 7
\fIl_pid\fP
Process ID of tha process dat holdz tha blockin lock.
.sp
.LP
If tha command is F_SETLKW n' tha process must wait fo' another process
to release a lock, then tha range of bytes ta be locked
shall be determined before tha \fIfcntl\fP() function blocks. If the
file size or file descriptor seek offset chizzle while
\fIfcntl\fP() is blocked, dis shall not affect tha range of bytes
locked.
.LP
If \fIl_len\fP is positive, tha area affected shall start at \fIl_start\fP
and end at \fIl_start\fP+ \fIl_len\fP-1. If
\fIl_len\fP is negative, tha area affected shall start at \fIl_start\fP+
\fIl_len\fP n' end at \fIl_start\fP-1. Locks may
start n' extend beyond tha current end of a gangbangin' file yo, but shall not extend
before tha beginnin of tha file fo' realz. A lock shall be set to
extend ta tha phattest possible value of tha file offset fo' dat file
by settin \fIl_len\fP ta 0. If such a lock also has
\fIl_start\fP set ta 0 n' \fIl_whence\fP is set ta SEEK_SET, the
whole file shall be locked.
.LP
There shall be at most one type of lock set fo' each byte up in tha file.
Before a successful return from a F_SETLK or a F_SETLKW
request when tha callin process has previously existin locks on
bytes up in tha region specified by tha request, tha previous lock
type fo' each byte up in tha specified region shall be replaced by the
new lock type fo' realz. As specified above under tha descriptions of
shared locks n' exclusive locks, a F_SETLK or a F_SETLKW request
(respectively) shall fail or block when another process has
existin locks on bytes up in tha specified region n' tha type of any
of dem locks conflicts wit tha type specified up in the
request.
.LP
All locks associated wit a gangbangin' file fo' a given process shall be removed
when a gangbangin' file descriptor fo' dat file is closed by that
process or tha process holdin dat file descriptor terminates. Locks
are not inherited by a cold-ass lil lil pimp process.
.LP
A potential fo' deadlock occurs if a process controllin a locked
region is put ta chill by attemptin ta lock another process'
locked region. I aint talkin' bout chicken n' gravy biatch. If tha system detects dat chillin until a locked
region is unlocked would cause a thugged-out deadlock, \fIfcntl\fP() shall
fail wit a [EDEADLK] error.
.LP
An unlock (F_UNLCK) request up in which \fIl_len\fP is non-zero n' the
offset of tha last byte of tha axed segment is the
maximum value fo' a object of type \fBoff_t\fP, when tha process
has a existin lock up in which \fIl_len\fP is 0 n' which
includes tha last byte of tha axed segment, shall be treated
as a request ta unlock from tha start of tha axed segment
with a \fIl_len\fP equal ta 0. Otherwise, a unlock (F_UNLCK) request
shall attempt ta unlock only tha axed segment.
.LP
When tha file descriptor \fIfildes\fP refers ta a gangbangin' finger-lickin' dirty-ass shared memory object,
the behavior of \fIfcntl\fP() shall be tha same as fo' a
regular file except tha effect of tha followin joints fo' tha argument
\fIcmd\fP shall be unspecified: F_SETFL, F_GETLK, F_SETLK,
and F_SETLKW. 
.LP
If \fIfildes\fP refers ta a typed memory object, tha result of the
\fIfcntl\fP() function is unspecified. Y'all KNOW dat shit, muthafucka! 
.SH RETURN VALUE
.LP
Upon successful completion, tha value returned shall depend on \fIcmd\fP
as bigs up:
.TP 7
F_DUPFD
A freshly smoked up file descriptor.
.TP 7
F_GETFD
Value of flags defined up in \fI<fcntl.h>\fP. Da return value shall
not be
negative.
.TP 7
F_SETFD
Value other than -1.
.TP 7
F_GETFL
Value of file status flags n' access modes. Da return value is not
negative.
.TP 7
F_SETFL
Value other than -1.
.TP 7
F_GETLK
Value other than -1.
.TP 7
F_SETLK
Value other than -1.
.TP 7
F_SETLKW
Value other than -1.
.TP 7
F_GETOWN
Value of tha socket balla process or process group; dis will not
be -1.
.TP 7
F_SETOWN
Value other than -1.
.sp
.LP
Otherwise, -1 shall be returned n' \fIerrno\fP set ta indicate the
error.
.SH ERRORS
.LP
Da \fIfcntl\fP() function shall fail if:
.TP 7
.B EACCES \fRor\fP EAGAIN
.sp
Da \fIcmd\fP argument is F_SETLK; tha type of lock ( \fIl_type\fP)
is a gangbangin' finger-lickin' dirty-ass shared (F_RDLCK) or exclusive (F_WRLCK) lock n' the
segment of a gangbangin' file ta be locked be already exclusive-locked by another
process, or tha type be a exclusive lock n' some portion of
the segment of a gangbangin' file ta be locked be already shared-locked or exclusive-locked
by another process.
.TP 7
.B EBADF
Da \fIfildes\fP argument aint a valid open file descriptor, or
the argument \fIcmd\fP is F_SETLK or F_SETLKW, tha type of
lock, \fIl_type\fP, be a gangbangin' finger-lickin' dirty-ass shared lock (F_RDLCK), n' \fIfildes\fP is
not a valid file descriptor open fo' reading, or tha type of
lock, \fIl_type\fP, be a exclusive lock (F_WRLCK), n' \fIfildes\fP
is not a valid file descriptor open fo' writing.
.TP 7
.B EINTR
Da \fIcmd\fP argument is F_SETLKW n' tha function was interrupted
by a signal.
.TP 7
.B EINVAL
Da \fIcmd\fP argument is invalid, or tha \fIcmd\fP argument is F_DUPFD
and \fIarg\fP is wack or pimped outa than or equal
to {OPEN_MAX}, or tha \fIcmd\fP argument is F_GETLK, F_SETLK, or F_SETLKW
and tha data pointed ta by \fIarg\fP aint valid, or
\fIfildes\fP refers ta a gangbangin' file dat do not support locking.
.TP 7
.B EMFILE
Da argument \fIcmd\fP is F_DUPFD n' {OPEN_MAX} file descriptors
are currently open up in tha callin process, or no file
descriptors pimped outa than or equal ta \fIarg\fP is available.
.TP 7
.B ENOLCK
Da argument \fIcmd\fP is F_SETLK or F_SETLKW n' satisfyin tha lock
or unlock request would result up in tha number of locked
regions up in tha system exceedin a system-imposed limit.
.TP 7
.B EOVERFLOW
One of tha joints ta be returned cannot be represented erectly.
.TP 7
.B EOVERFLOW
Da \fIcmd\fP argument is F_GETLK, F_SETLK, or F_SETLKW n' tha smallest
or, if \fIl_len\fP is non-zero, tha phattest offset
of any byte up in tha axed segment cannot be represented erectly
in a object of type \fBoff_t\fP.
.sp
.LP
Da \fIfcntl\fP() function may fail if:
.TP 7
.B EDEADLK
Da \fIcmd\fP argument is F_SETLKW, tha lock is blocked by a lock
from another process, n' puttin tha callin process to
sleep ta wait fo' dat lock ta become free would cause a thugged-out deadlock.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
None.
.SH RATIONALE
.LP
Da ellipsis up in tha SYNOPSIS is tha syntax specified by tha ISO\ C
standard fo' a variable number of arguments, n' you can put dat on yo' toast. Well shiiiit, it is used
because System V uses pointas fo' tha implementation of file locking
functions.
.LP
Da \fIarg\fP joints ta F_GETFD, F_SETFD, F_GETFL, n' F_SETFL all
represent flag joints ta allow fo' future growth.
Applications rockin these functions should do a read-modify-write operation
on them, rather than assumin dat only tha joints
defined by dis volume of IEEE\ Std\ 1003.1-2001 is valid. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is
a common error ta forget this, particularly up in tha case
of F_SETFD.
.LP
This volume of IEEE\ Std\ 1003.1-2001 permits concurrent read and
write access ta file data rockin tha \fIfcntl\fP()
function; dis be a cold-ass lil chizzle from tha 1984 /usr/group standard n' early
proposals. Without concurrency controls, dis feature may
not be straight-up utilized without occasionizzle loss of data.
.LP
Data losses occur up in nuff muthafuckin ways. One case occurs when nuff muthafuckin processes
try ta update tha same record, without sequencing
controls; nuff muthafuckin thugged-out shiznit may occur up in parallel n' tha last writer
"wins" fo' realz. Another case be a funky-ass bit-tree or other internal
list-based database dat is undergoin reorganization. I aint talkin' bout chicken n' gravy biatch. Without exclusive
use ta tha tree segment by tha uppimpin process, other
readin processes chizzle gettin lost up in tha database when tha index
blocks is split, condensed, inserted, or deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. While
\fIfcntl\fP() is useful fo' nuff applications, it aint intended
to be overly general n' do not handle tha bit-tree example
well.
.LP
This facilitizzle is only required fo' regular filez cuz it is not
appropriate fo' nuff devices like fuckin terminals n' network
connections.
.LP
Since \fIfcntl\fP() works wit "any file descriptor associated with
that file, however it is obtained", tha file descriptor
may done been inherited all up in a \fIfork\fP() or \fIexec\fP operation
and thus may affect a gangbangin' file dat another process also has open.
.LP
Da use of tha open file description ta identify what tha fuck ta lock requires
extra calls n' presents problems if nuff muthafuckin processes
are pluggin a open file description yo, but there be too nuff implementations
of tha existin mechanizzle fo' dis volume of
IEEE\ Std\ 1003.1-2001 ta use different justifications.
.LP
Another consequence of dis model is dat closin any file descriptor
for a given file (whether or not it is tha same ol' dirty open file
description dat pimped tha lock) causes tha locks on dat file to
be relinquished fo' dat process. Equivalently, any close for
any file/process pair relinquishes tha locks owned on dat file for
that process. But note dat while a open file description may
be shared all up in \fIfork\fP(), locks is not inherited all up in \fIfork\fP().
Yet locks may be inherited all up in one of tha \fIexec\fP functions.
.LP
Da identification of a machine up in a network environment is outside
the scope of dis volume of IEEE\ Std\ 1003.1-2001.
Thus, a \fIl_sysid\fP member, like fuckin found up in System V, aint included
in tha lockin structure.
.LP
Changin of lock types can result up in a previously locked region being
split tha fuck into smalla regions.
.LP
Mandatory lockin was a major feature of tha 1984 /usr/group standard.
.LP
For advisory file record lockin ta be effective, all processes that
have access ta a gangbangin' file must cooperate n' use tha advisory
mechanizzle before bustin I/O on tha file. Enforcement-mode record locking
is blingin when it cannot be assumed dat all processes
are cooperating. For example, if one user uses a editor ta update
a file all up in tha same time dat a second user executes another
process dat thugged-out shiznit tha same ol' dirty file n' if only one of tha two processes
is rockin advisory locking, tha processes is not
cooperating. Enforcement-mode record lockin would protect against
accidental collisions.
.LP
Secondly, advisory record lockin requires a process rockin locking
to bracket each I/O operation wit lock (or test) n' unlock
operations. With enforcement-mode file n' record locking, a process
can lock tha file once n' unlock when all I/O operations have
been completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Enforcement-mode record lockin serves up a funky-ass base that
can be enhanced; fo' example, wit sharable locks. That is,
the mechanizzle could be enhanced ta allow a process ta lock a gangbangin' file
so other processes could read it yo, but none of dem could write
it.
.LP
Mandatory locks was omitted fo' nuff muthafuckin reasons:
.IP " 1." 4
Mandatory lock settin was done by multiplexin tha set-group-ID bit
in most implementations; dis was confusing, at best.
.LP
.IP " 2." 4
Da relationshizzle ta file truncation as supported up in 4.2 BSD was not
well specified.
.LP
.IP " 3." 4
Any publicly readable file could be locked by mah playas. Many historical
implementations keep tha password database up in a publicly
readable file fo' realz. A malicious user could thus prohibit logins fo' realz. Another
possibilitizzle would be ta hold open a long-distizzle telephone
line.
.LP
.IP " 4." 4
Some demand-paged oldschool implementations offer memory mapped files,
and enforcement cannot be done on dat type of file.
.LP
.LP
Since chillin on a region is interrupted wit any signal, \fIalarm\fP()
may be used to
provide a timeout facilitizzle up in applications requirin dat shit. This is useful
in deadlock detection. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since implementation of full
deadlock detection aint always feasible, tha [EDEADLK] error was
made optional.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIalarm\fP(), \fIclose\fP(), \fIexec\fP(), \fIopen\fP(), \fIsigaction\fP(),
the Base Definitions volume of IEEE\ Std\ 1003.1-2001, \fI<fcntl.h>\fP,
\fI<signal.h>\fP, \fI<unistd.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
