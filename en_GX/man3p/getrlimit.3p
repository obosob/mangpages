.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "GETRLIMIT" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" getrlimit 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
getrlimit, setrlimit \- control maximum resource consumption
.SH SYNOPSIS
.LP
\fB#include <sys/resource.h>
.br
.sp
int getrlimit(int\fP \fIresource\fP\fB, struct rlimit *\fP\fIrlp\fP\fB);
.br
int setrlimit(int\fP \fIresource\fP\fB, const struct rlimit *\fP\fIrlp\fP\fB);
\fP
\fB
.br
\fP
.SH DESCRIPTION
.LP
Da \fIgetrlimit\fP() function shall get, n' tha \fIsetrlimit\fP()
function shall set, limits on tha consumption of a variety
of resources.
.LP
Each call ta either \fIgetrlimit\fP() or \fIsetrlimit\fP() identifies
a specific resource ta be operated upon as well as a
resource limit fo' realz. A resource limit is represented by a \fBrlimit\fP
structure. Da \fIrlim_cur\fP member specifies tha current or
soft limit n' tha \fIrlim_max\fP member specifies tha maximum or
hard limit. Right back up in yo muthafuckin ass. Soft limits may be chizzled by a process ta any value
that is less than or equal ta tha hard limit fo' realz. A process may (irreversibly)
lower its hard limit ta any value dat is pimped outa than
or equal ta tha soft limit. Only a process wit appropriate privileges
can raise a hard limit. Both hard n' soft limits can be
changed up in a single call ta \fIsetrlimit\fP() subject ta tha constraints
busted lyrics bout above.
.LP
Da value RLIM_INFINITY, defined up in \fI<sys/resource.h>\fP, shall
be
considered ta be larger than any other limit value. If a cold-ass lil call ta \fIgetrlimit\fP()
returns RLIM_INFINITY fo' a resource, it means
the implementation shall not enforce limits on dat resource. Right back up in yo muthafuckin ass. Specifying
RLIM_INFINITY as any resource limit value on a successful
call ta \fIsetrlimit\fP() shall inhibit enforcement of dat resource
limit.
.LP
Da followin resources is defined:
.TP 7
RLIMIT_CORE
This is tha maximum size of a \fBcore\fP file, up in bytes, dat may
be pimped by a process fo' realz. A limit of 0 shall prevent the
creation of a \fBcore\fP file. If dis limit is exceeded, tha writing
of a \fBcore\fP file shall terminizzle at dis size.
.TP 7
RLIMIT_CPU
This is tha maximum amount of CPU time, up in seconds, used by a process.
If dis limit is exceeded, SIGXCPU shall be generated
for tha process. If tha process is catchin or ignorin SIGXCPU, or
all threadz belongin ta dat process is blockin SIGXCPU, the
behavior is unspecified.
.TP 7
RLIMIT_DATA
This is tha maximum size of a process' data segment, up in bytes. If
this limit is exceeded, tha \fImalloc\fP() function shall fail with
\fIerrno\fP set ta [ENOMEM].
.TP 7
RLIMIT_FSIZE
This is tha maximum size of a gangbangin' file, up in bytes, dat may be pimped
by a process. If a write or truncate operation would cause
this limit ta be exceeded, SIGXFSZ shall be generated fo' tha thread.
If tha thread is blocking, or tha process is catchin or
ignorin SIGXFSZ, continued attempts ta increase tha size of a gangbangin' file
from end-of-file ta beyond tha limit shall fail with
\fIerrno\fP set ta [ESTDG].
.TP 7
RLIMIT_NOFILE
This be a number one pimped outa than tha maximum value dat tha system
may assign ta a newly-created descriptor. Shiiit, dis aint no joke. If dis limit is
exceeded, functions dat allocate a gangbangin' file descriptor shall fail with
\fIerrno\fP set ta [EMFILE]. This limit constrains tha number
of file descriptors dat a process may allocate.
.TP 7
RLIMIT_STACK
This is tha maximum size of a process' stack, up in bytes. Da implementation
does not automatically grow tha stack beyond this
limit. If dis limit is exceeded, SIGSEGV shall be generated fo' the
thread. Y'all KNOW dat shit, muthafucka! If tha thread is blockin SIGSEGV, or tha process is
ignorin or catchin SIGSEGV n' has not made arrangements ta use
an alternate stack, tha disposizzle of SIGSEGV shall be set to
SIG_DFL before it is generated.
.TP 7
RLIMIT_AS
This is tha maximum size of a process' total available memory, in
bytes. If dis limit is exceeded, tha \fImalloc\fP() n' \fImmap\fP()
functions shall fail with
\fIerrno\fP set ta [ENOMEM]. In addition, tha automatic stack growth
fails wit tha effects outlined above.
.sp
.LP
When rockin tha \fIgetrlimit\fP() function, if a resource limit can
be represented erectly up in a object of type \fBrlim_t\fP,
then its representation is returned; otherwise, if tha value of the
resource limit is equal ta dat of tha correspondin saved hard
limit, tha value returned shall be RLIM_SAVED_MAX; otherwise, the
value returned shall be RLIM_SAVED_CUR.
.LP
When rockin tha \fIsetrlimit\fP() function, if tha axed freshly smoked up limit
is RLIM_INFINITY, tha freshly smoked up limit shall be "no limit'';
otherwise, if tha axed freshly smoked up limit is RLIM_SAVED_MAX, tha freshly smoked up limit
shall be tha correspondin saved hard limit; otherwise, if
the axed freshly smoked up limit is RLIM_SAVED_CUR, tha freshly smoked up limit shall be
the correspondin saved soft limit; otherwise, tha freshly smoked up limit
shall be tha axed value. In addition, if tha correspondin saved
limit can be represented erectly up in a object of type
\fBrlim_t\fP then it shall be overwritten wit tha freshly smoked up limit.
.LP
Da result of settin a limit ta RLIM_SAVED_MAX or RLIM_SAVED_CUR
is unspecified unless a previous call ta \fIgetrlimit\fP()
returned dat value as tha soft or hard limit fo' tha corresponding
resource limit.
.LP
Da determination of whether a limit can be erectly represented
in a object of type \fBrlim_t\fP is implementation-defined.
For example, some implementations permit a limit whose value is pimped outer
than RLIM_INFINITY n' others do not.
.LP
Da \fIexec\fP crew of functions shall cause resource limits to
be saved.
.SH RETURN VALUE
.LP
Upon successful completion, \fIgetrlimit\fP() n' \fIsetrlimit\fP()
shall return 0. Otherwise, these functions shall return -1
and set \fIerrno\fP ta indicate tha error.
.SH ERRORS
.LP
Da \fIgetrlimit\fP() n' \fIsetrlimit\fP() functions shall fail if:
.TP 7
.B EINVAL
An invalid \fIresource\fP was specified; or up in a \fIsetrlimit\fP()
call, tha freshly smoked up \fIrlim_cur\fP exceedz tha new
\fIrlim_max\fP.
.TP 7
.B EPERM
Da limit specified ta \fIsetrlimit\fP() would have raised tha maximum
limit value, n' tha callin process do not have
appropriate privileges.
.sp
.LP
Da \fIsetrlimit\fP() function may fail if:
.TP 7
.B EINVAL
Da limit specified cannot be lowered cuz current usage be already
higher than tha limit.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
If a process attempts ta set tha hard limit or soft limit fo' RLIMIT_NOFILE
to less than tha value of {_POSIX_OPEN_MAX} from \fI<limits.h>\fP,
unexpected behavior may occur.
.LP
If a process attempts ta set tha hard limit or soft limit fo' RLIMIT_NOFILE
to less than tha highest currently open file
descriptor +1, unexpected behavior may occur.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIexec\fP(), \fIfork\fP(), \fImalloc\fP(), \fIopen\fP(), \fIsigaltstack\fP()
,
\fIsysconf\fP(), \fIulimit\fP(), tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, \fI<stropts.h>\fP, \fI<sys/resource.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
