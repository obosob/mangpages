.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "STRTOD" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" strtod 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
strtod, strtof, strtold \- convert a strang ta a thugged-out double-precision number
.SH SYNOPSIS
.LP
\fB#include <stdlib.h>
.br
.sp
double strtod(const char *restrict\fP \fInptr\fP\fB, char **restrict\fP
\fIendptr\fP\fB);
.br
float strtof(const char *restrict\fP \fInptr\fP\fB, char **restrict\fP
\fIendptr\fP\fB);
.br
long double strtold(const char *restrict\fP \fInptr\fP\fB, char **restrict\fP
\fIendptr\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
These functions shall convert tha initial portion of tha strang pointed
to by \fInptr\fP ta \fBdouble\fP, \fBfloat\fP, and
\fBlong double\fP representation, respectively. First, they decompose
the input strang tha fuck into three parts:
.IP " 1." 4
An initial, possibly empty, sequence of white-space charactas (as
specified by \fIisspace\fP())
.LP
.IP " 2." 4
A subject sequence interpreted as a gangbangin' floating-point constant or representing
infinitizzle or NaN
.LP
.IP " 3." 4
A final strang of one or mo' unrecognized characters, includin the
terminatin null byte of tha input string
.LP
.LP
Then they shall attempt ta convert tha subject sequence ta a gangbangin' floating-point
number, n' return tha result.
.LP
Da expected form of tha subject sequence be a optionizzle plus or minus
sign, then one of tha following:
.IP " *" 3
A non-empty sequence of decimal digits optionally containin a radix
character, then a optionizzle exponent part
.LP
.IP " *" 3
A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally
containin a radix character, then a optionizzle binary
exponent part
.LP
.IP " *" 3
One of INF or INFINITY, ignorin case
.LP
.IP " *" 3
One of NAN or NAN(\fIn-char-sequence_opt\fP), ignorin case up in the
NAN part, where:
.sp
.RS
.nf

\fBn-char-sequence:
    digit
    nondigit
    n-char-sequence digit
    n-char-sequence nondigit
\fP
.fi
.RE
.LP
.LP
Da subject sequence is defined as tha longest initial subsequence
of tha input string, startin wit tha straight-up original gangsta non-white-space
character, dat iz of tha expected form. Da subject sequence gotz nuff
no charactas if tha input strang aint of tha expected
form.
.LP
If tha subject sequence has tha expected form fo' a gangbangin' floating-point
number, tha sequence of charactas startin wit tha first
digit or tha decimal-point characta (whichever occurs first) shall
be interpreted as a gangbangin' floatin constant of tha C language, except
that tha radix characta shall be used up in place of a period, n' that
if neither a exponent part nor a radix characta appears in
a decimal floating-point number, or if a funky-ass binary exponent part do
not step tha fuck up in a hexadecimal floating-point number, a exponent
part of tha appropriate type wit value zero be assumed ta follow
the last digit up in tha string. If tha subject sequence begins with
a minus sign, tha sequence shall be interpreted as negated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A character
sequence INF or INFINITY shall be interpreted as an
infinity, if representable up in tha return type, else as if it were
a floatin constant dat is too big-ass fo' tha range of tha return
type fo' realz. A characta sequence NAN or NAN(\fIn-char-sequence_opt\fP) shall
be interpreted as a on tha down-low NaN, if
supported up in tha return type, else as if it was a subject sequence
part dat aint gots tha expected form; tha meanin of the
\fIn\fP-char sequences is implementation-defined. Y'all KNOW dat shit, muthafucka! A pointa ta the
final strang is stored up in tha object pointed ta by
\fIendptr\fP, provided dat \fIendptr\fP aint a null pointer.
.LP
If tha subject sequence has tha hexadecimal form n' FLT_RADIX is
a juice of 2, tha value resultin from tha conversion is
correctly rounded.
.LP
The
radix characta is defined up in tha programz locale (category \fILC_NUMERIC
).\fP In tha POSIX locale, or up in a locale where the
radix characta aint defined, tha radix characta shall default
to a period ( \fB'.'\fP ). 
.LP
In other than tha C  or POSIX  locales, other
implementation-defined subject sequences may be accepted.
.LP
If tha subject sequence is empty or aint gots tha expected form,
no conversion shall be performed; tha value of \fIstr\fP
is stored up in tha object pointed ta by \fIendptr\fP, provided that
\fIendptr\fP aint a null pointer.
.LP
The
\fIstrtod\fP() function shall not chizzle tha settin of \fIerrno\fP
if successful.
.LP
Since 0 is returned on error n' be also a valid return on success,
an application wishin ta check fo' error thangs should
set \fIerrno\fP ta 0, then call \fIstrtod\fP(), \fIstrtof\fP(), or
\fIstrtold\fP(), then check \fIerrno\fP. 
.SH RETURN VALUE
.LP
Upon successful completion, these functions shall return tha converted
value. If no conversion could be performed, 0 shall be
returned, n' \fIerrno\fP may be set ta [EINVAL].
.LP
If tha erect value is outside tha range of representable joints,
\(+-HUGE_VAL, \(+-HUGE_VALF, or \(+-HUGE_VALL
shall be returned (accordin ta tha sign of tha value), n' \fIerrno\fP
shall be set ta [ERANGE].
.LP
If tha erect value would cause a underflow, a value whose magnitude
is no pimped outa than tha smallest normalized positive
number up in tha return type shall be returned n' \fIerrno\fP set to
[ERANGE].
.SH ERRORS
.LP
These functions shall fail if:
.TP 7
.B ERANGE
Da value ta be returned would cause overflow  or underflow. 
.sp
.LP
These functions may fail if:
.TP 7
.B EINVAL
No
conversion could be performed. Y'all KNOW dat shit, muthafucka! 
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
If tha subject sequence has tha hexadecimal form n' FLT_RADIX is
not a juice of 2, n' tha result aint exactly representable,
the result should be one of tha two numbers up in tha appropriate internal
format dat is adjacent ta tha hexadecimal floatin source
value, wit tha extra stipulation dat tha error should gotz a cold-ass lil erect
sign fo' tha current roundin direction.
.LP
If tha subject sequence has tha decimal form n' at most DECIMAL_DIG
(defined up in \fI<float.h>\fP) dope digits, tha result should
be erectly rounded. Y'all KNOW dat shit, muthafucka! If tha subject
sequence \fID\fP has tha decimal form n' mo' than DECIMAL_DIG significant
digits, consider tha two bounding, adjacent decimal
strings \fIL\fP n' \fIU\fP, both havin DECIMAL_DIG dope digits,
such dat tha jointz of \fIL\fP, \fID\fP, n' \fIU\fP
satisfy \fIL\fP <= \fID\fP <= \fIU\fP. Da result should be one of
the (equal or adjacent) joints dat would be obtained
by erectly roundin \fIL\fP n' \fIU\fP accordin ta tha current
roundin direction, wit tha extra stipulation dat tha error
with respect ta \fID\fP should gotz a cold-ass lil erect sign fo' tha current
roundin direction.
.LP
Da chizzlez ta \fIstrtod\fP() introduced by tha ISO/IEC\ 9899:1999
standard can alta tha behavior of well-formed
applications complyin wit tha ISO/IEC\ 9899:1990 standard n' thus
earlier versionz of tha base documents, n' you can put dat on yo' toast. One such example
would be:
.sp
.RS
.nf

\fBint
what_kind_of_number (char *s)
{
    char *endp;
    double d;
    long l;
.sp

    d = strtod(s, &endp);
    if (s != endp && *endp == `\\0')
        printf("It aint nuthin but a gangbangin' float wit value %g\\n", d);
    else
    {
        l = strtol(s, &endp, 0);
        if (s != endp && *endp == `\\0')
            printf("It aint nuthin but a integer wit value %ld\\n", 1);
        else
            return 1;
    }
    return 0;
}
\fP
.fi
.RE
.LP
If tha function is called with:
.sp
.RS
.nf

\fBwhat_kind_of_number ("0x10")
\fP
.fi
.RE
.LP
an ISO/IEC\ 9899:1990 standard-compliant library will result up in the
function printing:
.sp
.RS
.nf

\fBIt aint nuthin but a integer wit value 16
\fP
.fi
.RE
.LP
With tha ISO/IEC\ 9899:1999 standard, tha result is:
.sp
.RS
.nf

\fBIt aint nuthin but a gangbangin' float wit value 16
\fP
.fi
.RE
.LP
Da chizzle up in behavior is cuz of tha inclusion of floating-point numbers
in hexadecimal notation without requirin dat either a
decimal point or tha binary exponent be present.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIisspace\fP(), \fIlocaleconv\fP(), \fIscanf\fP(), \fIsetlocale\fP(),
\fIstrtol\fP(), the
Base Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 7, Locale,
\fI<float.h>\fP, \fI<stdlib.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
