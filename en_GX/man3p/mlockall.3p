.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "MLOCKALL" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" mlockall 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
mlockall, munlockall \- lock/unlock tha address space of a process
(\fBREALTIME\fP)
.SH SYNOPSIS
.LP
\fB#include <sys/mman.h>
.br
.sp
int mlockall(int\fP \fIflags\fP\fB);
.br
int munlockall(void); \fP
\fB
.br
\fP
.SH DESCRIPTION
.LP
Da \fImlockall\fP() function shall cause all of tha pages mapped
by tha address space of a process ta be memory-resident until
unlocked or until tha process exits or \fIexec\fPs another process
image. Da \fIflags\fP
argument determines whether tha pages ta be locked is dem currently
mapped by tha address space of tha process, dem dat are
mapped up in tha future, or both. Da \fIflags\fP argument is constructed
from tha bitwise-inclusive OR of one or mo' of the
followin symbolic constants, defined up in \fI<sys/mman.h>\fP:
.TP 7
MCL_CURRENT
Lock all of tha pages currently mapped tha fuck into tha address space of the
process.
.TP 7
MCL_FUTURE
Lock all of tha pages dat become mapped tha fuck into tha address space of
the process up in tha future, when dem mappings are
established.
.sp
.LP
If MCL_FUTURE is specified, n' tha automatic lockin of future mappings
eventually causes tha amount of locked memory ta exceed
the amount of available physical memory or any other implementation-defined
limit, tha behavior is implementation-defined. Y'all KNOW dat shit, muthafucka! The
manner up in which tha implementation informs tha application of these
situations be also implementation-defined.
.LP
Da \fImunlockall\fP() function shall unlock all currently mapped
pagez of tha address space of tha process fo' realz. Any pages that
become mapped tha fuck into tha address space of tha process afta a cold-ass lil call to
\fImunlockall\fP() shall not be locked, unless there be an
intervenin call ta \fImlockall\fP() specifyin MCL_FUTURE or a subsequent
call ta \fImlockall\fP() specifyin MCL_CURRENT. If
pages mapped tha fuck into tha address space of tha process is also mapped
into tha address spacez of other processes n' is locked by
those processes, tha locks established by tha other processes shall
be unaffected by a cold-ass lil call by dis process to
\fImunlockall\fP().
.LP
Upon successful return from tha \fImlockall\fP() function dat specifies
MCL_CURRENT, all currently mapped pagez of the
process' address space shall be memory-resident n' locked. Y'all KNOW dat shit, muthafucka! Upon return
from tha \fImunlockall\fP() function, all currently mapped
pagez of tha process' address space shall be unlocked wit respect
to tha process' address space. Da memory residency of unlocked
pages is unspecified.
.LP
Da appropriate privilege is required ta lock process memory with
\fImlockall\fP().
.SH RETURN VALUE
.LP
Upon successful completion, tha \fImlockall\fP() function shall return
a value of zero. Otherwise, no additionizzle memory shall
be locked, n' tha function shall return a value of -1 n' set \fIerrno\fP
to indicate tha error. Shiiit, dis aint no joke. Da effect of failure of
\fImlockall\fP() on previously existin locks up in tha address space
is unspecified.
.LP
If it is supported by tha implementation, tha \fImunlockall\fP() function
shall always return a value of zero. Otherwise, the
function shall return a value of -1 n' set \fIerrno\fP ta indicate
the error.
.SH ERRORS
.LP
Da \fImlockall\fP() function shall fail if:
.TP 7
.B EAGAIN
Some or all of tha memory identified by tha operation could not be
locked when tha call was made.
.TP 7
.B EINVAL
Da \fIflags\fP argument is zero, or includes unimplemented flags.
.sp
.LP
Da \fImlockall\fP() function may fail if:
.TP 7
.B ENOMEM
Lockin all of tha pages currently mapped tha fuck into tha address space of
the process would exceed a implementation-defined limit on
the amount of memory dat tha process may lock.
.TP 7
.B EPERM
Da callin process aint gots tha appropriate privilege ta perform
the axed operation.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
None.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIexec\fP(), \fIexit\fP(), \fIfork\fP(), \fImlock\fP(), \fImunmap\fP(),
the Base
Definitions volume of IEEE\ Std\ 1003.1-2001, \fI<sys/mman.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
