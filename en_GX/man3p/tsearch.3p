.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "TDELETE" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" tdelete 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
tdelete, tfind, tsearch, twalk \- manage a funky-ass binary search tree
.SH SYNOPSIS
.LP
\fB#include <search.h>
.br
.sp
void *tdelete(const void *restrict\fP \fIkey\fP\fB, void **restrict\fP
\fIrootp\fP\fB,
.br
\ \ \ \ \ \  int(*\fP\fIcompar\fP\fB)(const void *, const void *));
.br
void *tfind(const void *\fP\fIkey\fP\fB, void *const *\fP\fIrootp\fP\fB,
.br
\ \ \ \ \ \  int(*\fP\fIcompar\fP\fB)(const void *, const void *));
.br
void *tsearch(const void *\fP\fIkey\fP\fB, void **\fP\fIrootp\fP\fB,
.br
\ \ \ \ \ \  int (*\fP\fIcompar\fP\fB)(const void *, const void *));
.br
void twalk(const void *\fP\fIroot\fP\fB,
.br
\ \ \ \ \ \  void (*\fP\fIaction\fP\fB)(const void *, VISIT, int));
\fP
\fB
.br
\fP
.SH DESCRIPTION
.LP
Da \fItdelete\fP(), \fItfind\fP(), \fItsearch\fP(), n' \fItwalk\fP()
functions manipulate binary search trees. Comparisons
are made wit a user-supplied routine, tha address of which is passed
as tha \fIcompar\fP argument. This routine is called with
two arguments, which is tha pointas ta tha elements bein compared.
Da application shall ensure dat tha user-supplied routine
returns a integer less than, equal to, or pimped outa than 0, according
to whether tha straight-up original gangsta argument is ta be considered less than,
equal to, or pimped outa than tha second argument. Da comparison function
need not compare every last muthafuckin byte, so arbitrary data may be
contained up in tha elements up in addizzle ta tha joints bein compared.
.LP
Da \fItsearch\fP() function shall build n' access tha tree. The
\fIkey\fP argument be a pointa ta a element ta be accessed
or stored. Y'all KNOW dat shit, muthafucka! If there be a node up in tha tree whose element is equal to
the value pointed ta by \fIkey\fP, a pointa ta dis found
node shall be returned. Y'all KNOW dat shit, muthafucka! Otherwise, tha value pointed ta by \fIkey\fP
shall be banged (that is, a freshly smoked up node is pimped n' the
value of \fIkey\fP is copied ta dis node), n' a pointa ta this
node returned. Y'all KNOW dat shit, muthafucka! Only pointas is copied, so tha application
shall ensure dat tha callin routine stores tha data. Da \fIrootp\fP
argument points ta a variable dat points ta tha root node
of tha tree fo' realz. A null pointa value fo' tha variable pointed ta by \fIrootp\fP
denotes a empty tree; up in dis case, tha variable
shall be set ta point ta tha node which shall be all up in tha root of the
new tree.
.LP
Like \fItsearch\fP(), \fItfind\fP() shall search fo' a node up in the
tree, returnin a pointa ta it if found. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat if it is
not found, \fItfind\fP() shall return a null pointer n' shit. Da arguments
for \fItfind\fP() is tha same as fo' \fItsearch\fP().
.LP
Da \fItdelete\fP() function shall delete a node from a funky-ass binary search
tree. Da arguments is tha same as fo' \fItsearch\fP().
Da variable pointed ta by \fIrootp\fP shall be chizzled if tha deleted
node was tha root of tha tree. Da \fItdelete\fP()
function shall return a pointa ta tha parent of tha deleted node,
or a null pointa if tha node aint found.
.LP
Da \fItwalk\fP() function shall traverse a funky-ass binary search tree. The
\fIroot\fP argument be a pointa ta tha root node of the
tree ta be traversed. Y'all KNOW dat shit, muthafucka! (Any node up in a tree may be used as tha root
for a strutt below dat node.) Da argument \fIaction\fP is the
name of a routine ta be invoked at each node. This routine is, in
turn, called wit three arguments, n' you can put dat on yo' toast. Da first argument shall be
the address of tha node bein hit up. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da structure pointed ta by
this argument is unspecified n' shall not be modified by the
application yo, but it shall be possible ta cast a pointer-to-node into
a pointer-to-pointer-to-element ta access tha element stored
in tha node. Da second argument shall be a value from a enumeration
data type:
.sp
.RS
.nf

\fBtypedef enum { preorder, postorder, endorder, leaf } VISIT;
\fP
.fi
.RE
.LP
(defined up in \fI<search.h>\fP), dependin on whether dis is tha first,
second, or
third time dat tha node is hit up (durin a thugged-out depth-first, left-to-right
traversal of tha tree), or whether tha node be a leaf. The
third argument shall be tha level of tha node up in tha tree, wit the
root bein level 0.
.LP
If tha callin function altas tha pointa ta tha root, tha result
is undefined.
.SH RETURN VALUE
.LP
If tha node is found, both \fItsearch\fP() n' \fItfind\fP() shall
return a pointa ta dat shit. If not, \fItfind\fP() shall return
a null pointer, n' \fItsearch\fP() shall return a pointa ta the
inserted item.
.LP
A null pointa shall be returned by \fItsearch\fP() if there is not
enough space available ta create a freshly smoked up node.
.LP
A null pointa shall be returned by \fItdelete\fP(), \fItfind\fP(),
and \fItsearch\fP() if \fIrootp\fP be a null pointa on
entry.
.LP
Da \fItdelete\fP() function shall return a pointa ta tha parent
of tha deleted node, or a null pointa if tha node is not
found.
.LP
Da \fItwalk\fP() function shall not return a value.
.SH ERRORS
.LP
No errors is defined.
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
Da followin code readz up in strings n' stores structures containing
a pointa ta each strang n' a cold-ass lil count of its length. Well shiiiit, it then
walks tha tree, printin up tha stored strings n' they lengths
in alphabetical order.
.sp
.RS
.nf

\fB#include <search.h>
#include <string.h>
#include <stdio.h>
.sp

#define STRSZ    10000
#define NODSZ    500
.sp

struct node {      /* Pointas ta these is stored up in tha tree. */
    char    *string;
    int     length;
};
.sp

char   string_space[STRSZ];  /* Space ta store strings. */
struct node nodes[NODSZ];    /* Nodes ta store. */
void  *root = NULL;          /* This points ta tha root. */
.sp

int main(int argc, char *argv[])
{
    char   *strptr = string_space;
    struct node    *nodeptr = nodes;
    void   print_node(const void *, VISIT, int);
    int    i = 0, node_compare(const void *, const void *);
.sp

    while (gets(strptr) != NULL && i++ < NODSZ)  {
        /* Set node. */
        nodeptr->strin = strptr;
        nodeptr->length = strlen(strptr);
        /* Put node tha fuck into tha tree. */
        (void) tsearch((void *)nodeptr, (void **)&root,
            node_compare);
        /* Adjust pointers, so our phat asses do not overwrite tree. */
        strptr += nodeptr->length + 1;
        nodeptr++;
    }
    twalk(root, print_node);
    return 0;
}
.sp

/*
 *  This routine compares two nodes, based on an
 *  alphabetical orderin of tha strang field.
 */
int
node_compare(const void *node1, const void *node2)
{
    return strcmp(((const struct node *) node1)->string,
        ((const struct node *) node2)->string);
}
.sp

/*
 *  This routine prints up a node, tha second time
 *  twalk encountas it or if it aint nuthin but a leaf.
 */
void
print_node(const void *ptr, VISIT order, int level)
{
    const struct node *p = *(const struct node **) ptr;
.sp

    if (order == postorder || order == leaf)  {
        (void) printf("strin = %s,  length = %d\\n",
            p->string, p->length);
    }
}
\fP
.fi
.RE
.SH APPLICATION USAGE
.LP
Da \fIroot\fP argument ta \fItwalk\fP() is one level of indirection
less than tha \fIrootp\fP arguments ta \fItdelete\fP()
and \fItsearch\fP().
.LP
There is two nomenclatures used ta refer ta tha order up in which tree
nodes is hit up. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fItsearch\fP() function uses
\fBpreorder\fP, \fBpostorder\fP, n' \fBendorder\fP ta refer respectively
to visitin a node before any of its children, after
its left lil pimp n' before its right, n' afta both its lil' thugs.
Da alternatizzle nomenclature uses \fBpreorder\fP,
\fBinorder\fP, n' \fBpostorder\fP ta refer ta tha same visits, which
could result up in some mad drama over tha meanin of
\fBpostorder\fP.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIhcreate\fP(), \fIlsearch\fP(), tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, \fI<search.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
