.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "ICONV" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" iconv 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
iconv \- codeset conversion function
.SH SYNOPSIS
.LP
\fB#include <iconv.h>
.br
.sp
size_t iconv(iconv_t\fP \fIcd\fP\fB, char **restrict\fP \fIinbuf\fP\fB,
.br
\ \ \ \ \ \  size_t *restrict\fP \fIinbytesleft\fP\fB, char **restrict\fP
\fIoutbuf\fP\fB,
.br
\ \ \ \ \ \  size_t *restrict\fP \fIoutbytesleft\fP\fB); \fP
\fB
.br
\fP
.SH DESCRIPTION
.LP
Da \fIiconv\fP() function shall convert tha sequence of characters
from one codeset, up in tha array specified by \fIinbuf\fP,
into a sequence of correspondin charactas up in another codeset, in
the array specified by \fIoutbuf\fP. Da codesets is them
specified up in tha \fIiconv_open\fP() call dat returned tha conversion
descriptor,
\fIcd\fP. Da \fIinbuf\fP argument points ta a variable dat points
to tha straight-up original gangsta characta up in tha input buffer and
\fIinbytesleft\fP indicates tha number of bytes ta tha end of the
buffer ta be converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fIoutbuf\fP argument points ta a
variable dat points ta tha straight-up original gangsta available byte up in tha output buffer
and \fIoutbytesleft\fP indicates tha number of tha available
bytes ta tha end of tha buffer.
.LP
For state-dependent encodings, tha conversion descriptor \fIcd\fP
is placed tha fuck into its initial shift state by a cold-ass lil call fo' which
\fIinbuf\fP be a null pointer, or fo' which \fIinbuf\fP points to
a null pointer n' shit. When \fIiconv\fP() is called up in dis way, and
if \fIoutbuf\fP aint a null pointa or a pointa ta a null pointer,
and \fIoutbytesleft\fP points ta a positizzle value,
\fIiconv\fP() shall place, tha fuck into tha output buffer, tha byte sequence
to chizzle tha output buffer ta its initial shift state. If
the output buffer aint big-ass enough ta hold tha entire reset sequence,
\fIiconv\fP() shall fail n' set \fIerrno\fP ta [E2BIG].
Subsequent calls wit \fIinbuf\fP as other than a null pointa or
a pointa ta a null pointa cause tha conversion ta take place
from tha current state of tha conversion descriptor.
.LP
If a sequence of input bytes do not form a valid characta up in the
specified codeset, conversion shall stop afta tha previous
successfully converted character n' shit. If tha input buffer endz wit an
incomplete characta or shift sequence, conversion shall stop
afta tha previous successfully converted bytes. If tha output buffer
is not big-ass enough ta hold tha entire converted input,
conversion shall stop just prior ta tha input bytes dat would cause
the output buffer ta overflow. Da variable pointed ta by
\fIinbuf\fP shall be updated ta point ta tha byte followin tha last
byte successfully used up in tha conversion. I aint talkin' bout chicken n' gravy biatch. Da value pointed
to by \fIinbytesleft\fP shall be decremented ta reflect tha number
of bytes still not converted up in tha input buffer n' shit. Da variable
pointed ta by \fIoutbuf\fP shall be updated ta point ta tha byte following
the last byte of converted output data. Da value
pointed ta by \fIoutbytesleft\fP shall be decremented ta reflect the
number of bytes still available up in tha output buffer n' shit. For
state-dependent encodings, tha conversion descriptor shall be updated
to reflect tha shift state up in effect all up in tha end of tha last
successfully converted byte sequence.
.LP
If \fIiconv\fP() encountas a cold-ass lil characta up in tha input buffer dat is
valid yo, but fo' which a identical characta do not exist
in tha target codeset, \fIiconv\fP() shall big-ass up a implementation-defined
conversion on dis character.
.SH RETURN VALUE
.LP
Da \fIiconv\fP() function shall update tha variablez pointed ta by
the arguments ta reflect tha extent of tha conversion and
return tha number of non-identical conversions performed. Y'all KNOW dat shit, muthafucka! If tha entire
strin up in tha input buffer is converted, tha value pointed
to by \fIinbytesleft\fP shall be 0. If tha input conversion is stopped
due ta any conditions mentioned above, tha value pointed to
by \fIinbytesleft\fP shall be non-zero n' \fIerrno\fP shall be set
to indicate tha condition. I aint talkin' bout chicken n' gravy biatch. If a error occurs, \fIiconv\fP()
shall return (\fBsize_t\fP)-1 n' set \fIerrno\fP ta indicate the
error.
.SH ERRORS
.LP
Da \fIiconv\fP() function shall fail if:
.TP 7
.B EILSEQ
Input conversion stopped cuz of a input byte dat do not belong
to tha input codeset.
.TP 7
.B E2BIG
Input conversion stopped cuz of lack of space up in tha output buffer.
.TP 7
.B EINVAL
Input conversion stopped cuz of a incomplete characta or shift sequence
at tha end of tha input buffer.
.sp
.LP
Da \fIiconv\fP() function may fail if:
.TP 7
.B EBADF
Da \fIcd\fP argument aint a valid open conversion descriptor.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
Da \fIinbuf\fP argument indirectly points ta tha memory area which
gotz nuff tha conversion input data. Da \fIoutbuf\fP
argument indirectly points ta tha memory area which is ta contain
the result of tha conversion. I aint talkin' bout chicken n' gravy biatch. Da objects indirectly pointed to
by \fIinbuf\fP n' \fIoutbuf\fP is not restricted ta containin data
that is directly representable up in tha ISO\ C standard
language \fBchar\fP data type. Da type of \fIinbuf\fP n' \fIoutbuf\fP,
\fBchar **\fP, do not imply dat tha objects pointed
to is interpreted as null-terminated C strings or arrayz of characters.
Any interpretation of a funky-ass byte sequence dat represents a
characta up in a given characta set encodin scheme is done internally
within tha codeset converters. For example, tha area pointed
to indirectly by \fIinbuf\fP and/or \fIoutbuf\fP can contain all zero
octets dat is not interpreted as strang terminators but
as coded characta data accordin ta tha respectizzle codeset encoding
scheme. Da type of tha data ( \fBchar\fP, \fBshort\fP,
\fBlong\fP, n' so on) read or stored up in tha objects aint specified,
but may be inferred fo' both tha input n' output data by
the convertas determined by tha \fIfromcode\fP n' \fItocode\fP arguments
of \fIiconv_open\fP().
.LP
Regardless of tha data type inferred by tha converter, tha size of
the remainin space up in both input n' output objects (the
\fIintbytesleft\fP n' \fIoutbytesleft\fP arguments) be always measured
in bytes.
.LP
For implementations dat support tha conversion of state-dependent
encodings, tha conversion descriptor must be able to
accurately reflect tha shift-state up in effect all up in tha end of tha last
successful conversion. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it aint required dat tha conversion
descriptor itself be updated, which would require it ta be a pointer
type. Thus, implementations is free ta implement the
descriptor as a handle (other than a pointa type) by which tha conversion
information can be accessed n' updated.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIiconv_open\fP(), \fIiconv_close\fP(), tha Base Definitions
volume of IEEE\ Std\ 1003.1-2001, \fI<iconv.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
