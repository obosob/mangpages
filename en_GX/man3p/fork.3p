.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "FORK" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" fork 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
fork \- create a freshly smoked up process
.SH SYNOPSIS
.LP
\fB#include <unistd.h>
.br
.sp
pid_t fork(void);
.br
\fP
.SH DESCRIPTION
.LP
Da \fIfork\fP() function shall create a freshly smoked up process. Da freshly smoked up process
(child process) shall be a exact copy of tha calling
process (parent process) except as detailed below:
.IP " *" 3
Da lil pimp process shall gotz a unique process ID.
.LP
.IP " *" 3
Da lil pimp process ID also shall not match any actizzle process group
ID.
.LP
.IP " *" 3
Da lil pimp process shall gotz a gangbangin' finger-lickin' different parent process ID, which
shall be tha process ID of tha callin process.
.LP
.IP " *" 3
Da lil pimp process shall have its own copy of tha parentz file descriptors.
Each of tha childz file descriptors shall refer to
the same open file description wit tha correspondin file descriptor
of tha parent.
.LP
.IP " *" 3
Da lil pimp process shall have its own copy of tha parentz open directory
streams. Each open directory stream up in tha child
process may share directory stream positionin wit tha corresponding
directory stream of tha parent.
.LP
.IP " *" 3
Da lil pimp process shall have its own copy of tha parentz message
catalog descriptors. 
.LP
.IP " *" 3
Da lil pimp process' jointz of \fItms_utime\fP, \fItms_stime\fP, \fItms_cutime\fP,
and \fItms_cstime\fP shall be set ta 0.
.LP
.IP " *" 3
Da time left until a alarm clock signal shall be reset ta zero,
and tha alarm, if any, shall be canceled; peep \fIalarm\fP().
.LP
.IP " *" 3
All \fIsemadj\fP joints shall be cleared. Y'all KNOW dat shit, muthafucka! 
.LP
.IP " *" 3
File locks set by tha parent process shall not be inherited by the
child process.
.LP
.IP " *" 3
Da set of signals pendin fo' tha lil pimp process shall be initialized
to tha empty set.
.LP
.IP " *" 3
Interval timers shall be reset up in tha lil pimp process. 
.LP
.IP " *" 3
Any semaphores dat is open up in tha parent process shall also be open
in tha lil pimp process. 
.LP
.IP " *" 3
The
child process shall not inherit any address space memory locks established
by tha parent process via calls ta \fImlockall\fP() or \fImlock\fP().
.LP
.IP " *" 3
Memory mappings pimped up in tha parent shall be retained up in tha child
process. MAP_PRIVATE mappings inherited from tha parent shall
also be MAP_PRIVATE mappings up in tha child, n' any modifications to
the data up in these mappings made by tha parent prior ta calling
\fIfork\fP() shall be visible ta tha child. Y'all KNOW dat shit, muthafucka! Any modifications ta the
data up in MAP_PRIVATE mappings made by tha parent after
\fIfork\fP() returns shall be visible only ta tha parent. Modifications
to tha data up in MAP_PRIVATE mappings made by tha child
shall be visible only ta tha child. Y'all KNOW dat shit, muthafucka! 
.LP
.IP " *" 3
For
the SCHED_FIFO n' SCHED_RR schedulin policies, tha lil pimp process
shall inherit tha policy n' prioritizzle settingz of tha parent
process durin a \fIfork\fP() function. I aint talkin' bout chicken n' gravy biatch. For other schedulin policies,
the policy n' prioritizzle settings on \fIfork\fP() are
implementation-defined. Y'all KNOW dat shit, muthafucka! 
.LP
.IP " *" 3
Per-process timers pimped by tha parent shall not be inherited by
the lil pimp process. 
.LP
.IP " *" 3
Da lil pimp process shall have its own copy of tha message queue descriptors
of tha parent. Each of tha message descriptorz of the
child shall refer ta tha same open message queue description as the
correspondin message descriptor of tha parent. 
.LP
.IP " *" 3
No asynchronous input or asynchronous output operations shall be inherited
by tha lil pimp process. 
.LP
.IP " *" 3
A process shall be pimped wit a single thread. Y'all KNOW dat shit, muthafucka! If a multi-threaded
process calls \fIfork\fP(), tha freshly smoked up process shall contain
a replica of tha callin thread n' its entire address space, possibly
includin tha statez of mutexes n' other resources.
Consequently, ta avoid errors, tha lil pimp process may only execute
async-signal-safe operations until such time as one of tha \fIexec\fP
functions is called. Y'all KNOW dat shit, muthafucka!  Fork handlezs may be established by means
of tha \fIpthread_atfork\fP() function up in order ta maintain application
invariants across
\fIfork\fP() calls. 
.LP
When tha application calls \fIfork\fP() from a signal handlez and
any of tha fork handlezs registered by \fIpthread_atfork\fP() calls
a function dat aint asynch-signal-safe, tha behavior is
undefined.
.LP
.IP " *" 3
If tha Trace option n' tha Trace Inherit option is both supported:
.LP
If tha callin process was bein traced up in a trace stream dat had
its inheritizzle policy set ta POSIX_TRACE_INHERITED, the
child process shall be traced tha fuck into dat trace stream, n' tha child
process shall inherit tha parentz mappin of trace event names
to trace event type identifiers. If tha trace stream up in which the
callin process was bein traced had its inheritizzle policy set
to POSIX_TRACE_CLOSE_FOR_CHILD, tha lil pimp process shall not be traced
into dat trace stream. Da inheritizzle policy is set by a
call ta tha \fIposix_trace_attr_setinherited\fP() function. I aint talkin' bout chicken n' gravy biatch. 
.LP
.IP " *" 3
If tha Trace option is supported yo, but tha Trace Inherit option is
not supported:
.LP
Da lil pimp process shall not be traced tha fuck into any of tha trace streams
of its parent process. 
.LP
.IP " *" 3
If tha Trace option is supported, tha lil pimp process of a trace controller
process shall not control tha trace streams controlled by
its parent process. 
.LP
.IP " *" 3
Da initial value of tha CPU-time clock of tha lil pimp process shall
be set ta zero. 
.LP
.IP " *" 3
Da initial value of tha CPU-time clock of tha single thread of the
child process shall be set ta zero. 
.LP
.LP
All other process characteristics defined by IEEE\ Std\ 1003.1-2001
shall be tha same up in tha parent n' lil pimp processes.
Da inheritizzle of process characteristics not defined by IEEE\ Std\ 1003.1-2001
is unspecified by
IEEE\ Std\ 1003.1-2001.
.LP
Afta \fIfork\fP(), both tha parent n' tha lil pimp processes shall
be capable of executin independently before either one
terminates.
.SH RETURN VALUE
.LP
Upon successful completion, \fIfork\fP() shall return 0 ta tha child
process n' shall return tha process ID of tha child
process ta tha parent process. Both processes shall continue ta execute
from tha \fIfork\fP() function. I aint talkin' bout chicken n' gravy biatch. Otherwise, -1 shall be
returned ta tha parent process, no lil pimp process shall be pimped,
and \fIerrno\fP shall be set ta indicate tha error.
.SH ERRORS
.LP
Da \fIfork\fP() function shall fail if:
.TP 7
.B EAGAIN
Da system lacked tha necessary resources ta create another process,
or tha system-imposed limit on tha total number of
processes under execution system-wide or by a single user {CHILD_MAX}
would be exceeded.
.sp
.LP
Da \fIfork\fP() function may fail if:
.TP 7
.B ENOMEM
Insufficient storage space be available.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
None.
.SH RATIONALE
.LP
Many oldschool implementations have timin windows where a signal
sent ta a process crew (for example, a interactizzle SIGINT)
just prior ta or durin execution of \fIfork\fP() is served up to
the parent followin tha \fIfork\fP() but not ta tha child
because tha \fIfork\fP() code clears tha childz set of pendin signals.
This volume of IEEE\ Std\ 1003.1-2001 do not
require, or even permit, dis behavior. Shiiit, dis aint no joke. But fuck dat shiznit yo, tha word on tha street is dat it is pragmatic to
expect dat problemz of dis nature may continue ta exist in
implementations dat step tha fuck up ta conform ta dis volume of IEEE\ Std\ 1003.1-2001
and pass available verification suites.
This behavior is only a cold-ass lil consequence of tha implementation failing
to make tha interval between signal generation n' delivery
totally invisible. From tha applicationz perspective, a \fIfork\fP()
call should step tha fuck up atomic fo' realz. A signal dat is generated prior
to tha \fIfork\fP() should be served up prior ta tha \fIfork\fP().
A signal busted ta tha process crew afta tha \fIfork\fP()
should be served up ta both parent n' child. Y'all KNOW dat shit, muthafucka! Da implementation may
actually initialize internal data structures correspondin to
the childz set of pendin signals ta include signals busted ta the
process crew durin tha \fIfork\fP(). Right back up in yo muthafuckin ass. Since tha \fIfork\fP()
call can be considered as atomic from tha applicationz perspective,
the set would be initialized as empty n' such signals would
have arrived afta tha \fIfork\fP(); peep also \fI<signal.h>\fP.
.LP
One approach dat has been suggested ta address tha problem of signal
inheritizzle across \fIfork\fP() is ta add a [EINTR]
error, which would be returned when a signal is detected durin the
call. While dis is preferable ta losin signals, dat shiznit was not
considered a optimal solution. I aint talkin' bout chicken n' gravy biatch fo' realz. Although it aint recommended for
this purpose, such a error would be a allowable extension for
an implementation.
.LP
Da [ENOMEM] error value is reserved fo' dem implementations that
detect n' distinguish such a cold-ass lil condition. I aint talkin' bout chicken n' gravy biatch. This condition
occurs when a implementation detects dat there aint enough memory
to create tha process. This is intended ta be returned when
[EAGAIN] is inappropriate cuz there can never be enough memory
(either primary or secondary storage) ta big-ass up tha operation.
Since \fIfork\fP() duplicates a existin process, dis must be a
condizzle where there is sufficient memory fo' one such process,
but not fo' two. Many oldschool implementations straight-up return [ENOMEM]
due ta temporary lack of memory, a cold-ass lil case dat is not
generally distinct from [EAGAIN] from tha perspectizzle of a cold-ass lil conforming
application.
.LP
Part of tha reason fo' includin tha optionizzle error [ENOMEM] is cuz
the SVID specifies it n' it should be reserved fo' the
error condizzle specified there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Da condizzle aint applicable on
many implementations.
.LP
IEEE\ Std\ 1003.1-1988 neglected ta require concurrent execution of
the parent n' lil pimp of \fIfork\fP() fo' realz. A system that
single-threadz processes was clearly not intended n' is considered
an unacceptable "toy implementation" of dis volume of
IEEE\ Std\ 1003.1-2001. Da only objection anticipated ta tha phrase
"executin independently" is testabilitizzle yo, but this
assertion should be testable. Right back up in yo muthafuckin ass. Such tests require dat both tha parent
and lil pimp can block on a thugged-out detectable action of tha other, such
as a write ta a pipe or a signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. An interactizzle exchange of such
actions should be possible fo' tha system ta conform ta the
intent of dis volume of IEEE\ Std\ 1003.1-2001.
.LP
Da [EAGAIN] error exists ta warn applications dat such a cold-ass lil condition
might occur. Shiiit, dis aint no joke. Whether it occurs or not aint up in any
practical sense under tha control of tha application cuz tha condition
is probably a cold-ass lil consequence of tha userz use of the
system, not of tha applicationz code. Thus, no application can or
should rely upon its occurrence under any circumstances, nor
should tha exact semantics of what tha fuck concept of "user" is used be of
concern ta tha application thug n' shit. Validation writas should
be cognizant of dis limitation.
.LP
There is two reasons why POSIX programmers call \fIfork\fP(). One
reason is ta create a freshly smoked up thread of control within tha same
program (which was originally only possible up in POSIX by bustin a
new process); tha other is ta create a freshly smoked up process hustlin a
different program. In tha latta case, tha call ta \fIfork\fP() is
soon followed by a cold-ass lil call ta one of tha \fIexec\fP functions.
.LP
Da general problem wit makin \fIfork\fP() work up in a multi-threaded
world is what tha fuck ta do wit all of tha threads. There are
two alternatives. One is ta copy all of tha threadz tha fuck into tha freshly smoked up process.
This causes tha programmer or implementation ta deal with
threadz dat is suspended on system calls or dat might be about
to execute system calls dat should not be executed up in tha new
process. Da other alternatizzle is ta copy only tha thread dat calls
\fIfork\fP(). This creates tha hang-up dat tha state of
process-local resources is probably held up in process memory. If a thread
that aint callin \fIfork\fP() holdz a resource, that
resource is never busted out up in tha lil pimp process cuz tha thread
whose thang it is ta release tha resource do not exist up in the
child process.
.LP
When a programmer is freestylin a multi-threaded program, tha straight-up original gangsta busted lyrics about
use of \fIfork\fP(), bustin freshly smoked up threadz up in the
same program, is provided by tha \fIpthread_create\fP() function.
Da \fIfork\fP()
function is thus used only ta run freshly smoked up programs, n' tha effects of
callin functions dat require certain resources between the
call ta \fIfork\fP() n' tha call ta a \fIexec\fP function is undefined.
.LP
Da addizzle of tha \fIforkall\fP() function ta tha standard was considered
and rejected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fIforkall\fP() function lets
all tha threadz up in tha parent be duplicated up in tha child. Y'all KNOW dat shit, muthafucka! This essentially
duplicates tha state of tha parent up in tha child. Y'all KNOW dat shit, muthafucka! This
allows threadz up in tha lil pimp ta continue processin n' allows locks
and tha state ta be preserved without explicit \fIpthread_atfork\fP()
code. Da callin process has ta ensure dat tha threadz processing
state dat is shared between tha parent n' lil pimp (that is, file descriptors
or MAP_SHARED memory) behaves properly after
\fIforkall\fP(). For example, if a thread is readin a gangbangin' file descriptor
in tha parent when \fIforkall\fP() is called, then two
threadz (one up in tha parent n' one up in tha child) is readin tha file
descriptor afta tha \fIforkall\fP(). If dis aint desired
behavior, tha parent process has ta synchronize wit such threads
before callin \fIforkall\fP().
.LP
While tha \fIfork\fP() function be async-signal-safe, there is no
way fo' a implementation ta determine whether tha fork
handlezs established by \fIpthread_atfork\fP() is async-signal-safe.
Da fork
handlezs may attempt ta execute portionz of tha implementation that
are not async-signal-safe, like fuckin dem dat is protected by
mutexes, leadin ta a thugged-out deadlock condition. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is therefore undefined
for tha fork handlezs ta execute functions dat is not
async-signal-safe when \fIfork\fP() is called from a signal handlez.
.LP
When \fIforkall\fP() is called, threads, other than tha callin thread,
that is up in functions dat can return wit a [EINTR]
error may have dem functions return [EINTR] if tha implementation
cannot ensure dat tha function behaves erectly up in tha parent
and child. Y'all KNOW dat shit, muthafucka! In particular, \fIpthread_cond_wait\fP() n' \fIpthread_cond_timedwait\fP()
need ta return up in order ta ensure dat tha condition
has not chizzled. Y'all KNOW dat shit, muthafucka! These functions can be awakened by a spurious condition
wakeup rather than returnin [EINTR].
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIalarm\fP(), \fIexec\fP(), \fIfcntl\fP(), \fIposix_trace_attr_getinherited\fP(),
\fIposix_trace_trid_eventid_open\fP(), \fIpthread_atfork\fP(),
\fIsemop\fP(), \fIsignal\fP(), \fItimes\fP(), tha Base Definitions
volume of
IEEE\ Std\ 1003.1-2001, \fI<sys/types.h>\fP, \fI<unistd.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
