.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "SHM_OPEN" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" shm_open 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
shm_open \- open a gangbangin' finger-lickin' dirty-ass shared memory object (\fBREALTIME\fP)
.SH SYNOPSIS
.LP
\fB#include <sys/mman.h>
.br
.sp
int shm_open(const char *\fP\fIname\fP\fB, int\fP \fIoflag\fP\fB,
mode_t\fP \fImode\fP\fB); \fP
\fB
.br
\fP
.SH DESCRIPTION
.LP
Da \fIshm_open\fP() function shall establish a cold-ass lil connection between
a shared memory object n' a gangbangin' file descriptor. Shiiit, dis aint no joke. Well shiiiit, it shall
create a open file description dat refers ta tha shared memory object
and a gangbangin' file descriptor dat refers ta dat open file
description. I aint talkin' bout chicken n' gravy biatch. Da file descriptor is used by other functions ta refer
to dat shared memory object. Da \fIname\fP argument points
to a strang namin a gangbangin' finger-lickin' dirty-ass shared memory object. Well shiiiit, it is unspecified whether
the name appears up in tha file system n' is visible ta other
functions dat take pathnames as arguments, n' you can put dat on yo' toast. Da \fIname\fP argument
conforms ta tha construction rulez fo' a pathname. If
\fIname\fP begins wit tha slash character, then processes calling
\fIshm_open\fP() wit tha same value of \fIname\fP refer to
the same shared memory object, as long as dat name has not been removed.
If \fIname\fP do not begin wit tha slash character,
the effect is implementation-defined. Y'all KNOW dat shit, muthafucka! Da interpretation of slash
charactas other than tha leadin slash characta up in \fIname\fP
is implementation-defined.
.LP
If successful, \fIshm_open\fP() shall return a gangbangin' file descriptor for
the shared memory object dat is tha lowest numbered file
descriptor not currently open fo' dat process. Da open file description
is new, n' therefore tha file descriptor do not share
it wit any other processes. Well shiiiit, it is unspecified whether tha file offset
is set. Da FD_CLOEXEC file descriptor flag associated with
the freshly smoked up file descriptor is set.
.LP
Da file status flags n' file access modez of tha open file description
are accordin ta tha value of \fIoflag\fP. The
\fIoflag\fP argument is tha bitwise-inclusive OR of tha following
flags defined up in tha \fI<fcntl.h>\fP header n' shiznit fo' realz. Applications specify
exactly one of tha straight-up original gangsta two joints (access
modes) below up in tha value of \fIoflag\fP:
.TP 7
O_RDONLY
Open fo' read access only.
.TP 7
O_RDWR
Open fo' read or write access.
.sp
.LP
Any combination of tha remainin flags may be specified up in tha value
of \fIoflag\fP:
.TP 7
O_CREAT
If tha shared memory object exists, dis flag has no effect, except
as noted under O_EXCL below. Otherwise, tha shared memory
object is pimped; tha user ID of tha shared memory object shall be
set ta tha effectizzle user ID of tha process; tha crew ID of
the shared memory object is set ta a system default crew ID or to
the effectizzle crew ID of tha process. Da permission bits of
the shared memory object shall be set ta tha value of tha \fImode\fP
argument except dem set up in tha file mode creation mask of
the process. When bits up in \fImode\fP other than tha file permission
bits is set, tha effect is unspecified. Y'all KNOW dat shit, muthafucka! Da \fImode\fP
argument do not affect whether tha shared memory object is opened
for reading, fo' writing, or fo' both. Da shared memory object
has a size of zero.
.TP 7
O_EXCL
If O_EXCL n' O_CREAT is set, \fIshm_open\fP() fails if tha shared
memory object exists, n' you can put dat on yo' toast. Da check fo' tha existence of the
shared memory object n' tha creation of tha object if it do not
exist be atomic wit respect ta other processes executing
\fIshm_open\fP() namin tha same shared memory object wit O_EXCL
and O_CREAT set. If O_EXCL is set n' O_CREAT aint set, the
result is undefined.
.TP 7
O_TRUNC
If tha shared memory object exists, n' it is successfully opened
O_RDWR, tha object shall be truncated ta zero length n' the
mode n' balla shall be unchanged by dis function call. Da result
of rockin O_TRUNC wit O_RDONLY is undefined.
.sp
.LP
When a gangbangin' finger-lickin' dirty-ass shared memory object is pimped, tha state of tha shared memory
object, includin all data associated wit tha shared
memory object, persists until tha shared memory object is unlinked
and all other references is gone. Well shiiiit, it is unspecified whether the
name n' shared memory object state remain valid afta a system reboot.
.SH RETURN VALUE
.LP
Upon successful completion, tha \fIshm_open\fP() function shall return
a non-negatizzle integer representin tha lowest numbered
unused file descriptor. Shiiit, dis aint no joke. Otherwise, it shall return -1 n' set \fIerrno\fP
to indicate tha error.
.SH ERRORS
.LP
Da \fIshm_open\fP() function shall fail if:
.TP 7
.B EACCES
Da shared memory object exists n' tha permissions specified by \fIoflag\fP
are denied, or tha shared memory object do not
exist n' permission ta create tha shared memory object is denied,
or O_TRUNC is specified n' write permission is denied.
.TP 7
.B EEXIST
O_CREAT n' O_EXCL is set n' tha named shared memory object already
exists.
.TP 7
.B EINTR
Da \fIshm_open\fP() operation was interrupted by a signal.
.TP 7
.B EINVAL
Da \fIshm_open\fP() operation aint supported fo' tha given name.
.TP 7
.B EMFILE
Too nuff file descriptors is currently up in use by dis process.
.TP 7
.B ENAMETOOLONG
Da length of tha \fIname\fP argument exceedz {PATH_MAX} or a pathname
component is longer than {NAME_MAX}.
.TP 7
.B ENFILE
Too nuff shared memory objects is currently open up in tha system.
.TP 7
.B ENOENT
O_CREAT aint set n' tha named shared memory object do not exist.
.TP 7
.B ENOSPC
There is insufficient space fo' tha creation of tha freshly smoked up shared memory
object.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
None.
.SH RATIONALE
.LP
When tha Memory Mapped Filez option is supported, tha aiiight \fIopen\fP()
call is used to
obtain a thugged-out descriptor ta a gangbangin' file ta be mapped accordin ta existin practice
with \fImmap\fP().
When tha Shared Memory Objects option is supported, tha \fIshm_open\fP()
function shall obtain a thugged-out descriptor ta tha shared memory
object ta be mapped.
.LP
There be ample precedent fo' havin a gangbangin' file descriptor represent several
typez of objects, n' you can put dat on yo' toast. In tha POSIX.1-1990 standard, a gangbangin' file
descriptor can represent a gangbangin' file, a pipe, a FIFO, a tty, or a gangbangin' finger-lickin' directory.
Many implementations simply have a operations vector,
which is indexed by tha file descriptor type n' do straight-up different
operations. Note dat up in some cases tha file descriptor passed
to generic operations on file descriptors is returned by \fIopen\fP()
or \fIcreat\fP() n' up in some cases returned by alternate functions,
like fuckin \fIpipe\fP(). Da latta technique is used by \fIshm_open\fP().
.LP
Note dat such shared memory objects can straight-up be implemented as
mapped files. In both cases, tha size can be set afta the
open rockin \fIftruncate\fP(). Da \fIshm_open\fP() function itself
does not create a
shared object of a specified size cuz dis would duplicate an
extant function dat set tha size of a object referenced by a
file descriptor.
.LP
On implementations where memory objects is implemented rockin the
existin file system, tha \fIshm_open\fP() function may be
implemented rockin a macro dat invokes \fIopen\fP(), n' tha \fIshm_unlink\fP()
function may be implemented rockin a macro dat invokes \fIunlink\fP().
.LP
For implementations without a permanent file system, tha definition
of tha name of tha memory objects be allowed not ta survive
a system reboot. Note dat dis allows systems wit a permanent file
system ta implement memory objects as data structures internal
to tha implementation as well.
.LP
On implementations dat chizzle ta implement memory objects rockin memory
directly, a \fIshm_open\fP() followed by a \fIftruncate\fP() and
\fIclose\fP() can be used to
preallocate a gangbangin' finger-lickin' dirty-ass shared memory area n' ta set tha size of dat preallocation.
This may be necessary fo' systems without virtual
memory hardware support up in order ta ensure dat tha memory is contiguous.
.LP
Da set of valid open flags ta \fIshm_open\fP() was restricted to
O_RDONLY, O_RDWR, O_CREAT, n' O_TRUNC cuz these could be
easily implemented on most memory mappin systems. This volume of
IEEE\ Std\ 1003.1-2001 is silent on tha thangs up in dis biatch if the
implementation cannot supply tha axed file access cuz of
implementation-defined reasons, includin hardware ones.
.LP
Da error conditions [EACCES] n' [ENOTSUP] is provided ta inform
the application dat tha implementation cannot complete a
request.
.LP
[EACCES] indicates fo' implementation-defined reasons, probably hardware-related,
that tha implementation cannot comply wit a
axed mode cuz it conflicts wit another axed mode fo' realz. An
example might be dat a application desires ta open a memory
object two times, mappin different areas wit different access modes.
If tha implementation cannot map a single area tha fuck into a
process space up in two places, which would be required if different
access modes was required fo' tha two areas, then the
implementation may inform tha application all up in tha time of tha second
open.
.LP
[ENOTSUP] indicates fo' implementation-defined reasons, probably hardware-related,
that tha implementation cannot comply wit a
axed mode at all fo' realz. An example would be dat tha hardware of the
implementation cannot support write-only shared memory
areas.
.LP
On all implementations, it may be desirable ta restrict tha location
of tha memory objects ta specific file systems for
performizzle (like fuckin a RAM disk) or implementation-defined reasons
(shared memory supported directly only on certain file systems).
Da \fIshm_open\fP() function may be used ta enforce these restrictions.
There is a fuckin shitload of methodz available ta the
application ta determine a appropriate name of tha file or tha location
of a appropriate directory. One way is from the
environment via \fIgetenv\fP() fo' realz. Another would be from a cold-ass lil configuration
file.
.LP
This volume of IEEE\ Std\ 1003.1-2001 specifies dat memory objects
have initial contentz of zero when pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is
consistent wit current behavior fo' both filez n' newly allocated
memory. For dem implementations dat use physical memory, it
would be possible dat such implementations could simply use available
memory n' give it ta tha process uninitialized. Y'all KNOW dat shit, muthafucka! This,
however, aint consistent wit standard behavior fo' tha uninitialized
data area, tha stack, n' of course, files. Finally, it is
highly desirable ta set tha allocated memory ta zero fo' security
reasons. Thus, initializin memory objects ta zero is
required.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIclose\fP(), \fIdup\fP(), \fIexec\fP(), \fIfcntl\fP(), \fImmap\fP(),
\fIshmat\fP(), \fIshmctl\fP(), \fIshmdt\fP(), \fIshm_unlink\fP(),
\fIumask\fP(), tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, \fI<fcntl.h>\fP, \fI<sys/mman.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
