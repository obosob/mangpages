.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "FWPRINTF" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" fwprintf 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
fwprintf, swprintf, wprintf \- print formatted wide-characta output
.SH SYNOPSIS
.LP
\fB#include <stdio.h>
.br
#include <wchar.h>
.br
.sp
int fwprintf(FILE *restrict\fP \fIstream\fP\fB, const wchar_t *restrict\fP
\fIformat\fP\fB, ...);
.br
int swprintf(wchar_t *restrict\fP \fIws\fP\fB, size_t\fP \fIn\fP\fB,
.br
\ \ \ \ \ \  const wchar_t *restrict\fP \fIformat\fP\fB, ...);
.br
int wprintf(const wchar_t *restrict\fP \fIformat\fP\fB, ...);
.br
\fP
.SH DESCRIPTION
.LP
Da \fIfwprintf\fP() function shall place output on tha named output
\fIstream\fP. Da \fIwprintf\fP() function shall place
output on tha standard output stream \fIstdout\fP. Da \fIswprintf\fP()
function shall place output followed by tha null wide
characta up in consecutizzle wide charactas startin at *\fIws\fP; no
more than \fIn\fP wide charactas shall be written, including
a terminatin null wide character, which be always added (unless \fIn\fP
is zero).
.LP
Each of these functions shall convert, format, n' print its arguments
under control of tha \fIformat\fP wide-characta string.
Da \fIformat\fP is composed of zero or mo' directives: \fIordinary
wide-characters\fP, which is simply copied ta tha output
stream, n' \fIconversion justifications\fP, each of which thangs up in dis biatch
in tha fetchin of zero or mo' arguments, n' you can put dat on yo' toast. Da thangs up in dis biatch are
undefined if there be insufficient arguments fo' tha \fIformat\fP.
If tha \fIformat\fP is exhausted while arguments remain, the
excess arguments is evaluated but is otherwise ignored.
.LP
Conversions can be applied ta tha \fIn\fPth argument afta tha \fIformat\fP
in tha argument list, rather than ta tha next unused
argument. In dis case, tha conversion specifier wide characta \fB%\fP
(see below) is replaced by tha sequence \fB"%n$"\fP,
where \fIn\fP be a thugged-out decimal integer up in tha range [1,{NL_ARGMAX}], giving
the posizzle of tha argument up in tha argument list. This
feature serves up fo' tha definizzle of \fIformat\fP wide-character
strings dat select arguments up in a order appropriate to
specific languages (see tha EXAMPLES section).
.LP
Da \fIformat\fP can contain either numbered argument justifications
(that is, \fB"%\fP\fIn\fP\fB$"\fP and
\fB"*\fP\fIm\fP\fB$"\fP), or unnumbered argument conversion justifications
(that is, \fB%\fP n' \fB*\fP ) yo, but not
both. Da only exception ta dis is dat \fB%%\fP can be mixed with
the \fB"%\fP\fIn\fP\fB$"\fP form. Da thangs up in dis biatch of
mixin numbered n' unnumbered argument justifications up in a \fIformat\fP
wide-characta strang is undefined. Y'all KNOW dat shit, muthafucka! When numbered
argument justifications is used, specifyin tha \fIN\fPth argument
requires dat all tha leadin arguments, from tha straight-up original gangsta ta the
(\fIN\fP-1)th, is specified up in tha \fIformat\fP wide-characta string.
.LP
In \fIformat\fP wide-characta strings containin tha \fB"%\fP\fIn\fP\fB$"\fP
form of conversion justification, numbered
arguments up in tha argument list can be referenced from tha \fIformat\fP
wide-characta strang as nuff times as required. Y'all KNOW dat shit, muthafucka! 
.LP
In \fIformat\fP wide-characta strings containin tha \fB%\fP form
of conversion justification, each argument up in the
argument list shall be used exactly once.
.LP
All
formz of tha \fIfwprintf\fP() function allow fo' tha insertion of
a locale-dependent radix characta up in tha output string, output
as a wide-characta value. Da radix characta is defined up in tha program's
locale (category \fILC_NUMERIC ).\fP In tha POSIX
locale, or up in a locale where tha radix characta aint defined, the
radix characta shall default ta a period ( \fB'.'\fP ).
.LP
Each conversion justification is introduced by tha \fB'%'\fP wide
characta  or by the
wide-characta sequence \fB"%\fP\fIn\fP\fB$"\fP, after
which tha followin step tha fuck up in sequence:
.IP " *" 3
Zero or mo' \fIflags\fP (in any order), which modify tha meaning
of tha conversion justification.
.LP
.IP " *" 3
An optionizzle minimum \fIfield width\fP. If tha converted value has
fewer wide charactas than tha field width, it shall be
padded wit spaces by default on tha left; it shall be padded on the
right, if tha left-adjustment flag ( \fB'-'\fP ), busted lyrics about
below, is given ta tha field width. Da field width takes tha form
of a asterisk ( \fB'*'\fP ), busted lyrics bout below, or a thugged-out decimal
integer.
.LP
.IP " *" 3
An optionizzle \fIprecision\fP dat gives tha minimum number of digits
to step tha fuck up fo' tha \fBd\fP, \fBi\fP, \fBo\fP,
\fBu\fP, \fBx\fP, n' \fBX\fP conversion specifiers; tha number
of digits ta step tha fuck up afta tha radix characta fo' the
\fBa\fP, \fBA\fP, \fBe\fP, \fBE\fP, \fBf\fP, n' \fBF\fP conversion
specifiers; tha maximum number of
significant digits fo' tha \fBg\fP n' \fBG\fP conversion specifiers;
or tha maximum number of wide charactas ta be printed
from a strang up in tha \fBs\fP conversion specifiers. Da precision
takes tha form of a period ( \fB'.'\fP ) followed either by
an asterisk ( \fB'*'\fP ), busted lyrics bout below, or a optionizzle decimal
digit string, where a null digit strang is treated as 0. If a
precision appears wit any other conversion wide character, tha behavior
is undefined.
.LP
.IP " *" 3
An optionizzle length modifier dat specifies tha size of tha argument.
.LP
.IP " *" 3
A \fIconversion specifier\fP wide characta dat indicates tha type
of conversion ta be applied.
.LP
.LP
A field width, or precision, or both, may be indicated by a asterisk
( \fB'*'\fP ). In dis case a argument of type
\fBint\fP supplies tha field width or precision. I aint talkin' bout chicken n' gravy biatch fo' realz. Applications shall
ensure dat arguments specifyin field width, or precision, or
both step tha fuck up in dat order before tha argument, if any, ta be converted.
A wack field width is taken as a \fB'-'\fP flag
followed by a positizzle field width fo' realz. A wack precision is taken
as if tha precision was omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In
\fIformat\fP wide-characta strings containin tha \fB"%\fP\fIn\fP\fB$"\fP
form of a cold-ass lil conversion justification, a gangbangin' field
width or precision may be indicated by tha sequence \fB"*\fP\fIm\fP\fB$"\fP,
where \fIm\fP be a thugged-out decimal integer up in the
range [1,{NL_ARGMAX}] givin tha posizzle up in tha argument list (after
the \fIformat\fP argument) of a integer argument containing
the field width or precision, fo' example:
.sp
.RS
.nf

\fBwprintf(L"%1$d:%2$.*3$d:%4$.*3$d\\n", hour, min, precision, sec); 
\fP
.fi
.RE
.LP
Da flag wide charactas n' they meanings are:
.TP 7
\fB'\fP
Da integer portion of tha result of a thugged-out decimal conversion ( \fB%i\fP,
\fB%d\fP, \fB%u\fP, \fB%f\fP, \fB%F\fP,
\fB%g\fP, or \fB%G\fP ) shall be formatted wit thousands' grouping
wide characters. For other conversions, tha behavior is
undefined. Y'all KNOW dat shit, muthafucka! Da numeric groupin wide characta is used. Y'all KNOW dat shit, muthafucka! 
.TP 7
\fB-\fP
Da result of tha conversion shall be left-justified within tha field.
Da conversion shall be right-justified if dis flag is
not specified.
.TP 7
\fB+\fP
Da result of a signed conversion shall always begin wit a sign (
\fB'+'\fP or \fB'-'\fP ). Da conversion shall begin
with a sign only when a wack value is converted if dis flag is
not specified.
.TP 7
<space>
If tha straight-up original gangsta wide characta of a signed conversion aint a sign,
or if a signed conversion thangs up in dis biatch up in no wide characters, a
<space> shall be prefixed ta tha result. This means dat if tha <space>
and \fB'+'\fP flags both appear, the
<space> flag shall be ignored.
.TP 7
\fB#\fP
Specifies dat tha value is ta be converted ta a alternatizzle form.
For \fBo\fP conversion, it increases tha precision (if
necessary) ta force tha straight-up original gangsta digit of tha result ta be 0. For \fBx\fP
or \fBX\fP conversion specifiers, a non-zero result
shall have 0x (or 0X) prefixed ta dat shit. For \fBa\fP, \fBA\fP, \fBe\fP,
\fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP,
and \fBG\fP conversion specifiers, tha result shall always contain
a radix character, even if no digits follow dat shit. Without
this flag, a radix characta appears up in tha result of these conversions
only if a gangbangin' finger-lickin' digit bigs up dat shit. For \fBg\fP n' \fBG\fP
conversion specifiers, trailin zeros shall \fInot\fP be removed from
the result as they normally are. For other conversion
specifiers, tha behavior is undefined.
.TP 7
\fB0\fP
For \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP, \fBX\fP, \fBa\fP,
\fBA\fP, \fBe\fP,
\fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP, n' \fBG\fP conversion specifiers,
leadin zeros (followin any indication
of sign or base) is used ta pad ta tha field width; no space padding
is performed. Y'all KNOW dat shit, muthafucka! If tha \fB'0'\fP n' \fB'-'\fP flags both
appear, tha \fB'0'\fP flag shall be ignored. Y'all KNOW dat shit, muthafucka! For \fBd\fP, \fBi\fP,
\fBo\fP, \fBu\fP, \fBx\fP, n' \fBX\fP
conversion specifiers, if a precision is specified, tha \fB'0'\fP
flag shall be ignored. Y'all KNOW dat shit, muthafucka! If tha \fB'0'\fP n' \fB'"\fP
flags both appear, tha groupin wide charactas is banged before
zero padding. For other conversions, tha behavior is
undefined.
.sp
.LP
Da length modifiers n' they meanings are:
.TP 7
\fBhh\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBsigned char\fP or \fBunsigned char\fP argument (the
argument gonna git been promoted accordin ta tha integer
promotions yo, but its value shall be converted ta \fBsigned char\fP
or \fBunsigned char\fP before printing); or dat a gangbangin' following
\fBn\fP conversion specifier applies ta a pointa ta a \fBsigned char\fP
argument.
.TP 7
\fBh\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBshort\fP or \fBunsigned short\fP argument (the argument
will done been promoted accordin ta tha integer
promotions yo, but its value shall be converted ta \fBshort\fP or \fBunsigned
short\fP before printing); or dat a gangbangin' following
\fBn\fP conversion specifier applies ta a pointa ta a \fBshort\fP
argument.
.TP 7
\fBl\fP\ (ell)
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBlong\fP or \fBunsigned long\fP argument; dat a gangbangin' following
\fBn\fP conversion specifier applies ta a pointa to
a \fBlong\fP argument; dat a gangbangin' followin \fBc\fP conversion specifier
applies ta a \fBwint_t\fP argument; dat a gangbangin' following
\fBs\fP conversion specifier applies ta a pointa ta a \fBwchar_t\fP
argument; or has no effect on a gangbangin' followin \fBa\fP,
\fBA\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP, or \fBG\fP
conversion specifier.
.TP 7
\fBll\fP\ (ell-ell)
.sp
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBlong long\fP or \fBunsigned long long\fP argument;
or dat a gangbangin' followin \fBn\fP conversion specifier applies to
a pointa ta a \fBlong long\fP argument.
.TP 7
\fBj\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBintmax_t\fP or \fBuintmax_t\fP argument; or that
a followin \fBn\fP conversion specifier applies ta a
pointa ta a \fBintmax_t\fP argument.
.TP 7
\fBz\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBsize_t\fP or tha correspondin signed integer type
argument; or dat a gangbangin' followin \fBn\fP conversion specifier
applies ta a pointa ta a signed integer type correspondin ta a \fBsize_t\fP
argument.
.TP 7
\fBt\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, or \fBX\fP conversion specifier
applies ta a \fBptrdiff_t\fP or tha correspondin \fBunsigned\fP type
argument; or dat a gangbangin' followin \fBn\fP conversion
specifier applies ta a pointa ta a \fBptrdiff_t\fP argument.
.TP 7
\fBL\fP
Specifies dat a gangbangin' followin \fBa\fP, \fBA\fP, \fBe\fP, \fBE\fP,
\fBf\fP, \fBF\fP, \fBg\fP, or
\fBG\fP conversion specifier applies ta a \fBlong double\fP argument.
.sp
.LP
If a length modifier appears wit any conversion specifier other than
as specified above, tha behavior is undefined.
.LP
Da conversion specifiers n' they meanings are:
.TP 7
\fBd\fP,\ \fBi\fP
Da \fBint\fP argument shall be converted ta a signed decimal up in the
style \fB"[-]\fP\fIdddd"\fP. Da precision specifies
the minimum number of digits ta appear; if tha value bein converted
can be represented up in fewer digits, it shall be expanded with
leadin zeros. Da default precision shall be 1. Da result of converting
zero wit a explicit precision of zero shall be no wide
characters.
.TP 7
\fBo\fP
Da \fBunsigned\fP argument shall be converted ta unsigned octal format
in tha steez \fB"dddd"\fP . Da precision specifies
the minimum number of digits ta appear; if tha value bein converted
can be represented up in fewer digits, it shall be expanded with
leadin zeros. Da default precision shall be 1. Da result of converting
zero wit a explicit precision of zero shall be no wide
characters.
.TP 7
\fBu\fP
Da \fBunsigned\fP argument shall be converted ta unsigned decimal
format up in tha steez \fB"dddd"\fP . Da precision
specifies tha minimum number of digits ta appear; if tha value being
converted can be represented up in fewer digits, it shall be
expanded wit leadin zeros. Da default precision shall be 1. The
result of convertin zero wit a explicit precision of zero
shall be no wide characters.
.TP 7
\fBx\fP
Da \fBunsigned\fP argument shall be converted ta unsigned hexadecimal
format up in tha steez \fB"dddd"\fP ; tha letters
\fB"abcdef"\fP is used. Y'all KNOW dat shit, muthafucka! Da precision specifies tha minimum number
of digits ta appear; if tha value bein converted can be
represented up in fewer digits, it shall be expanded wit leadin zeros.
Da default precision shall be 1. Da result of converting
zero wit a explicit precision of zero shall be no wide characters.
.TP 7
\fBX\fP
Equivalent ta tha \fBx\fP conversion specifier, except dat letters
\fB"ABCDEF"\fP is used instead of \fB"abcdef"\fP
\&.
.TP 7
\fBf\fP,\ \fBF\fP
Da \fBdouble\fP argument shall be converted ta decimal notation in
the steez \fB"[-]\fP\fIddd.ddd"\fP, where tha number
of digits afta tha radix characta shall be equal ta tha precision
specification. I aint talkin' bout chicken n' gravy biatch. If tha precision is missing, it shall be taken
as 6; if tha precision is explicitly zero n' no \fB'#'\fP flag is
present, no radix characta shall appear. Shiiit, dis aint no joke. If a radix
characta appears, at least one digit shall step tha fuck up before dat shit. The
value shall be rounded up in a implementation-defined manner ta the
appropriate number of digits, n' you can put dat on yo' toast. 
.LP
A \fBdouble\fP argument representin a infinitizzle shall be converted
in one of tha stylez \fB"[-]inf"\fP or
\fB"[-]infinity"\fP ; which steez is implementation-defined. Y'all KNOW dat shit, muthafucka! A \fBdouble\fP
argument representin a NaN shall be converted in
one of tha stylez \fB"[-]nan"\fP or \fB"[-]nan(\fP\fIn-char-sequence\fP\fB)"\fP;
which style, n' tha meanin of any
\fIn-char-sequence\fP, is implementation-defined. Y'all KNOW dat shit, muthafucka! Da \fBF\fP conversion
specifier produces \fB"INF"\fP,
\fB"INFINITY"\fP, or \fB"NAN"\fP instead of \fB"inf"\fP, \fB"infinity"\fP,
or \fB"nan"\fP, respectively.
.TP 7
\fBe\fP,\ \fBE\fP
Da \fBdouble\fP argument shall be converted up in tha steez \fB"[-]\fP\fId.ddd\fPe\fB\(+-dd"\fP,
where there shall be
one digit before tha radix characta (which is non-zero if tha argument
is non-zero) n' tha number of digits afta it shall be
equal ta tha precision; if tha precision is missing, it shall be taken
as 6; if tha precision is zero n' no \fB'#'\fP flag is
present, no radix characta shall appear. Shiiit, dis aint no joke. Da value shall be rounded
in a implementation-defined manner ta tha appropriate number
of digits, n' you can put dat on yo' toast. Da \fBE\fP conversion wide characta shall produce a number
with \fB'E'\fP instead of \fB'e'\fP introducing
the exponent. Da exponent shall always contain at least two digits.
If tha value is zero, tha exponent shall be zero. 
.LP
A \fBdouble\fP argument representin a infinitizzle or NaN shall be converted
in tha steez of a \fBf\fP or \fBF\fP
conversion specifier.
.TP 7
\fBg\fP,\ \fBG\fP
Da \fBdouble\fP argument shall be converted up in tha steez \fBf\fP
or \fBe\fP (or up in tha steez \fBF\fP or \fBE\fP
in tha case of a \fBG\fP conversion specifier), wit tha precision
specifyin tha number of dope digits, n' you can put dat on yo' toast. If a explicit
precision is zero, it shall be taken as 1. Da steez used depends
on tha value converted; steez \fBe\fP (or \fBE\fP ) shall
be used only if tha exponent resultin from such a cold-ass lil conversion is less
than -4 or pimped outa than or equal ta tha precision. I aint talkin' bout chicken n' gravy biatch. Trailing
zeros shall be removed from tha fractionizzle portion of tha result;
a radix characta shall step tha fuck up only if it is followed by a gangbangin' finger-lickin' digit.
.LP
A \fBdouble\fP argument representin a infinitizzle or NaN shall be converted
in tha steez of a \fBf\fP or \fBF\fP
conversion specifier.
.TP 7
\fBa\fP,\ \fBA\fP
A \fBdouble\fP argument representin a gangbangin' floating-point number shall
be converted up in tha steez \fB"[-]0xh.hhhhp\(+-d"\fP,
where there shall be one hexadecimal digit (which is non-zero if the
argument be a normalized floating-point number n' is
otherwise unspecified) before tha decimal-point wide characta and
the number of hexadecimal digits afta it shall be equal ta the
precision; if tha precision is missin n' FLT_RADIX be a juice of
2, then tha precision shall be sufficient fo' a exact
representation of tha value; if tha precision is missin n' FLT_RADIX
is not a juice of 2, then tha precision shall be sufficient
to distinguish jointz of type \fBdouble\fP, except dat trailin zeros
may be omitted; if tha precision is zero n' the
\fB'#'\fP flag aint specified, no decimal-point wide characta shall
appear. Shiiit, dis aint no joke. Da lettas \fB"abcdef"\fP is used for
\fBa\fP conversion n' tha lettas \fB"ABCDEF"\fP fo' \fBA\fP conversion.
Da \fBA\fP conversion specifier produces a
number wit \fB'X'\fP n' \fB'P'\fP instead of \fB'x'\fP n' \fB'p'\fP
\&. Da exponent shall always contain at least one
digit, n' only as nuff mo' digits as necessary ta represent the
decimal exponent of 2. If tha value is zero, tha exponent shall
be zero. 
.LP
A \fBdouble\fP argument representin a infinitizzle or NaN shall be converted
in tha steez of a \fBf\fP or \fBF\fP
conversion specifier.
.TP 7
\fBc\fP
If no \fBl\fP (ell) qualifier is present, tha \fBint\fP argument shall
be converted ta a wide characta as if by calling
the \fIbtowc\fP() function n' tha resultin wide characta shall
be written. I aint talkin' bout chicken n' gravy biatch. Otherwise, the
\fBwint_t\fP argument shall be converted ta \fBwchar_t\fP, n' written.
.TP 7
\fBs\fP
If no \fBl\fP (ell) qualifier is present, tha application shall ensure
that tha argument be a pointa ta a cold-ass lil characta array
containin a cold-ass lil characta sequence beginnin up in tha initial shift state.
Charactas from tha array shall be converted as if by
repeated calls ta tha \fImbrtowc\fP() function, wit tha conversion
state busted lyrics bout by an
\fBmbstate_t\fP object initialized ta zero before tha straight-up original gangsta character
is converted, n' freestyled up ta (but not including) the
terminatin null wide character n' shit. If tha precision is specified, no
more than dat nuff wide charactas shall be written. I aint talkin' bout chicken n' gravy biatch. If the
precision aint specified, or is pimped outa than tha size of tha array,
the application shall ensure dat tha array gotz nuff a null
wide character n' shit. 
.LP
If a \fBl\fP (ell) qualifier is present, tha application shall ensure
that tha argument be a pointa ta a array of type
\fBwchar_t\fP. Wide charactas from tha array shall be freestyled up
to (but not including) a terminatin null wide character n' shit. If no
precision is specified, or is pimped outa than tha size of tha array,
the application shall ensure dat tha array gotz nuff a null wide
character n' shit. If a precision is specified, no mo' than dat nuff wide
charactas shall be written.
.TP 7
\fBp\fP
Da application shall ensure dat tha argument be a pointa ta \fBvoid\fP.
Da value of tha pointa shall be converted ta a
sequence of printable wide charactas up in a implementation-defined
manner.
.TP 7
\fBn\fP
Da application shall ensure dat tha argument be a pointa ta an
integer tha fuck into which is freestyled tha number of wide characters
written ta tha output so far by dis call ta one of tha \fIfwprintf\fP()
functions. No argument shall be converted yo, but one shall
be consumed. Y'all KNOW dat shit, muthafucka! If tha conversion justification includes any flags, a
field width, or a precision, tha behavior is undefined.
.TP 7
\fBC\fP
Equivalent ta \fBlc\fP . 
.TP 7
\fBS\fP
Equivalent ta \fBls\fP . 
.TP 7
\fB%\fP
Output a \fB'%'\fP wide character; no argument shall be converted.
Da entire conversion justification shall be \fB%%\fP
\&.
.sp
.LP
If a cold-ass lil conversion justification do not match one of tha above forms,
the behavior is undefined.
.LP
In no case do a nonexistent or lil' small-ass field width cause truncation
of a gangbangin' field; if tha result of a cold-ass lil conversion is wider than the
field width, tha field shall be expanded ta contain tha conversion
result. Charactas generated by \fIfwprintf\fP() and
\fIwprintf\fP() shall be printed as if \fIfputwc\fP() had been called.
.LP
For \fBa\fP n' \fBA\fP conversions, if FLT_RADIX aint a juice of
2 n' tha result aint exactly representable up in the
given precision, tha result should be one of tha two adjacent numbers
in hexadecimal floatin steez wit tha given precision, with
the extra stipulation dat tha error should gotz a cold-ass lil erect sign for
the current roundin direction.
.LP
For \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP, n' \fBG\fP
conversion specifiers, if tha number of
significant decimal digits be at most DECIMAL_DIG, then tha result
should be erectly rounded. Y'all KNOW dat shit, muthafucka! If tha number of significant
decimal digits is mo' than DECIMAL_DIG but tha source value is exactly
representable wit DECIMAL_DIG digits, then tha result
should be a exact representation wit trailin zeros. Otherwise,
the source value is bounded by two adjacent decimal strings
\fIL\fP < \fIU\fP, both havin DECIMAL_DIG dope digits; the
value of tha resultant decimal strang \fID\fP should
satisfy \fIL\fP <= \fID\fP <= \fIU\fP, wit tha extra stipulation
that tha error should gotz a cold-ass lil erect sign fo' the
current roundin direction.
.LP
The
\fIst_ctime\fP n' \fIst_mtime\fP fieldz of tha file shall be marked
for update between tha call ta a successful execution of
\fIfwprintf\fP() or \fIwprintf\fP() n' tha next successful completion
of a cold-ass lil call ta \fIfflush\fP() or \fIfclose\fP() on tha same stream,
or a
call ta \fIexit\fP() or \fIabort\fP(). 
.SH RETURN VALUE
.LP
Upon successful completion, these functions shall return tha number
of wide charactas transmitted, excludin tha terminating
null wide characta up in tha case of \fIswprintf\fP(), or a negative
value if a output error was encountered,  n' set
\fIerrno\fP ta indicate tha error. Shiiit, dis aint no joke. 
.LP
If \fIn\fP or mo' wide charactas was axed ta be written, \fIswprintf\fP()
shall return a wack value,  n' set
\fIerrno\fP ta indicate tha error. Shiiit, dis aint no joke. 
.SH ERRORS
.LP
For tha conditions under which \fIfwprintf\fP() n' \fIwprintf\fP()
fail n' may fail, refer ta \fIfputwc\fP().
.LP
In addition, all formz of \fIfwprintf\fP() may fail if:
.TP 7
.B EILSEQ
A wide-characta code dat do not correspond ta a valid character
has been detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
.TP 7
.B EINVAL
There is insufficient arguments, n' you can put dat on yo' toast. 
.sp
.LP
In addition, \fIwprintf\fP() n' \fIfwprintf\fP() may fail if:
.TP 7
.B ENOMEM
Insufficient storage space be available. 
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
To print tha language-independent date n' time format, tha following
statement could be used:
.sp
.RS
.nf

\fBwprintf(format, weekday, month, day, hour, min);
\fP
.fi
.RE
.LP
For Gangsta usage, \fIformat\fP could be a pointa ta tha wide-character
string:
.sp
.RS
.nf

\fBL"%s, %s %d, %d:%.2d\\n"
\fP
.fi
.RE
.LP
producin tha message:
.sp
.RS
.nf

\fBSunday, July 3, 10:02
\fP
.fi
.RE
.LP
whereas fo' German usage, \fIformat\fP could be a pointa ta tha wide-character
string:
.sp
.RS
.nf

\fBL"%1$s, %3$d. Y'all KNOW dat shit, muthafucka! %2$s, %4$d:%5$.2d\\n"
\fP
.fi
.RE
.LP
producin tha message:
.sp
.RS
.nf

\fBSonntag, 3. Juli, 10:02
\fP
.fi
.RE
.SH APPLICATION USAGE
.LP
None.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIbtowc\fP(), \fIfputwc\fP(), \fIfwscanf\fP(), \fImbrtowc\fP(),
\fIsetlocale\fP(),
the Base Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 7,
Locale, \fI<stdio.h>\fP, \fI<wchar.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
