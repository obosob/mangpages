.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "READDIR" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" readdir 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
readdir, readdir_r \- read a gangbangin' finger-lickin' directory
.SH SYNOPSIS
.LP
\fB#include <dirent.h>
.br
.sp
struct dirent *readdir(DIR *\fP\fIdirp\fP\fB);
.br
\fP
.LP
\fBint readdir_r(DIR *restrict\fP \fIdirp\fP\fB, struct dirent *restrict\fP
\fIentry\fP\fB,
.br
\ \ \ \ \ \  struct dirent **restrict\fP \fIresult\fP\fB); \fP
\fB
.br
\fP
.SH DESCRIPTION
.LP
Da type \fBDIR\fP, which is defined up in tha \fI<dirent.h>\fP header,
represents
a \fIdirectory stream\fP, which be a ordered sequence of all the
directory entries up in a particular directory. Directory entries
represent files; filez may be removed from a gangbangin' finger-lickin' directory or added to
a directory asynchronously ta tha operation of
\fIreaddir\fP().
.LP
Da \fIreaddir\fP() function shall return a pointa ta a structure
representin tha directory entry all up in tha current posizzle in
the directory stream specified by tha argument \fIdirp\fP, n' position
the directory stream all up in tha next entry. Well shiiiit, it shall return a
null pointa upon reachin tha end of tha directory stream. Da structure
\fBdirent\fP defined up in tha \fI<dirent.h>\fP header raps on some gangbangin' finger-lickin' directory
entry.
.LP
Da \fIreaddir\fP() function shall not return directory entries containing
empty names. If entries fo' dot or dot-dot exist,
one entry shall be returned fo' dot n' one entry shall be returned
for dot-dot; otherwise, they shall not be returned.
.LP
Da pointa returned by \fIreaddir\fP() points ta data which may be
overwritten by another call ta \fIreaddir\fP() on tha same
directory stream. This data aint overwritten by another call to
\fIreaddir\fP() on a gangbangin' finger-lickin' different directory stream.
.LP
If a gangbangin' file is removed from or added ta tha directory afta da most thugged-out
recent call ta \fIopendir\fP() or \fIrewinddir\fP(), whether a
subsequent call ta \fIreaddir\fP() returns a entry fo' dat file
is unspecified.
.LP
Da \fIreaddir\fP() function may buffer nuff muthafuckin directory entries
per actual read operation; \fIreaddir\fP() shall mark for
update tha \fIst_atime\fP field of tha directory each time tha directory
is straight-up read.
.LP
Afta a cold-ass lil call ta \fIfork\fP(), either tha parent or lil pimp (but not
both) may continue
processin tha directory stream rockin \fIreaddir\fP(), \fIrewinddir\fP(),
\ or \fIseekdir\fP().  If both the
parent n' lil pimp processes use these functions, tha result is undefined.
.LP
If tha entry names a symbolic link, tha value of tha \fId_ino\fP member
is unspecified.
.LP
Da \fIreaddir\fP() function need not be reentrant fo' realz. A function that
is not required ta be reentrant aint required ta be
thread-safe.
.LP
Da \fIreaddir_r\fP() function shall initialize tha \fBdirent\fP structure
referenced by \fIentry\fP ta represent tha directory
entry all up in tha current posizzle up in tha directory stream referred to
by \fIdirp\fP, store a pointa ta dis structure all up in tha location
referenced by \fIresult\fP, n' posizzle tha directory stream at the
next entry.
.LP
Da storage pointed ta by \fIentry\fP shall be big-ass enough fo' a
\fBdirent\fP wit a array of \fBchar\fP \fId_name\fP
thugz containin at least {NAME_MAX}+1 elements.
.LP
Upon successful return, tha pointa returned at *\fIresult\fP shall
have tha same value as tha argument \fIentry\fP. Upon
reachin tha end of tha directory stream, dis pointa shall have
the value NULL.
.LP
Da \fIreaddir_r\fP() function shall not return directory entries
containin empty names.
.LP
If a gangbangin' file is removed from or added ta tha directory afta da most thugged-out
recent call ta \fIopendir\fP() or \fIrewinddir\fP(), whether a
subsequent call ta \fIreaddir_r\fP() returns a entry fo' dat file
is unspecified.
.LP
Da \fIreaddir_r\fP() function may buffer nuff muthafuckin directory entries
per actual read operation; tha \fIreaddir_r\fP() function
shall mark fo' update tha \fIst_atime\fP field of tha directory each
time tha directory is straight-up read. Y'all KNOW dat shit, muthafucka! 
.LP
Applications wishin ta check fo' error thangs should set \fIerrno\fP
to 0 before callin \fIreaddir\fP(). If \fIerrno\fP
is set ta non-zero on return, a error occurred.
.SH RETURN VALUE
.LP
Upon successful completion, \fIreaddir\fP() shall return a pointer
to a object of type \fBstruct dirent\fP. When a error is
encountered, a null pointa shall be returned n' \fIerrno\fP shall
be set ta indicate tha error. Shiiit, dis aint no joke. When tha end of tha directory is
encountered, a null pointa shall be returned n' \fIerrno\fP is not
changed.
.LP
If successful, tha \fIreaddir_r\fP() function shall return zero; otherwise,
an error number shall be moonwalked back ta indicate the
error. Shiiit, dis aint no joke. 
.SH ERRORS
.LP
Da \fIreaddir\fP() function shall fail if:
.TP 7
.B EOVERFLOW
One of tha joints up in tha structure ta be returned cannot be represented
correctly.
.sp
.LP
Da \fIreaddir\fP() function may fail if:
.TP 7
.B EBADF
Da \fIdirp\fP argument do not refer ta a open directory stream.
.TP 7
.B ENOENT
Da current posizzle of tha directory stream is invalid.
.sp
.LP
Da \fIreaddir_r\fP() function may fail if:
.TP 7
.B EBADF
Da \fIdirp\fP argument do not refer ta a open directory stream.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
Da followin sample program searches tha current directory fo' each
of tha arguments supplied on tha command line.
.sp
.RS
.nf

\fB#include <dirent.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
.sp

static void lookup(const char *arg)
{
    DIR *dirp;
    struct dirent *dp;
.sp

    if ((dirp = opendir(".")) == NULL) {
        perror("couldn't open '.'");
        return;
    }
.sp

    do {
        errno = 0;
        if ((dp = readdir(dirp)) != NULL) {
            if (strcmp(dp->d_name, arg) != 0)
                continue;
.sp

            (void) printf("found %s\\n", arg);
            (void) closedir(dirp);
                return;
.sp

        }
    } while (dp != NULL);
.sp

    if (errno != 0)
        perror("error readin directory");
    else
        (void) printf("failed ta find %s\\n", arg);
    (void) closedir(dirp);
    return;
}
.sp

int main(int argc, char *argv[])
{
    int i;
    fo' (i = 1; i < argc; i++)
        lookup(arvg[i]);
    return (0);
}
\fP
.fi
.RE
.SH APPLICATION USAGE
.LP
Da \fIreaddir\fP() function should be used up in conjunction wit \fIopendir\fP(),
\fIclosedir\fP(), n' \fIrewinddir\fP() to
examine tha contentz of tha directory.
.LP
Da \fIreaddir_r\fP() function is thread-safe n' shall return joints
in a user-supplied buffer instead of possibly rockin a
static data area dat may be overwritten by each call.
.SH RATIONALE
.LP
Da returned value of \fIreaddir\fP() merely \fIrepresents\fP a gangbangin' finger-lickin' directory
entry. No equivalence should be inferred.
.LP
Oldschool implementationz of \fIreaddir\fP() obtain multiple directory
entries on a single read operation, which permits
subsequent \fIreaddir\fP() operations ta operate from tha buffered
information. I aint talkin' bout chicken n' gravy biatch fo' realz. Any wordin dat required each successful
\fIreaddir\fP() operation ta mark tha directory \fIst_atime\fP field
for update would disallow such historical
performance-oriented implementations.
.LP
Since \fIreaddir\fP() returns NULL when it detects a error n' when
the end of tha directory is encountered, a application
that need ta tell tha difference must set \fIerrno\fP ta zero before
the call n' check it if NULL is returned. Y'all KNOW dat shit, muthafucka! Since the
function must not chizzle \fIerrno\fP up in tha second case n' must set
it ta a non-zero value up in tha straight-up original gangsta case, a zero \fIerrno\fP
afta a cold-ass lil call returnin NULL indicates end-of-directory; otherwise,
an error.
.LP
Routines ta deal wit dis problem mo' directly was proposed:
.sp
.RS
.nf

\fBint derror (\fP\fIdirp\fP\fB)
DIR *\fP\fIdirp\fP\fB;
.sp

void clearderr (\fP\fIdirp\fP\fB)
DIR *\fP\fIdirp\fP\fB;
\fP
.fi
.RE
.LP
Da first would indicate whether a error had occurred, n' tha second
would clear tha error indication. I aint talkin' bout chicken n' gravy biatch. Da simpla method
involvin \fIerrno\fP was adopted instead by requirin dat \fIreaddir\fP()
not chizzle \fIerrno\fP when end-of-directory is
encountered.
.LP
An error or signal indicatin dat a gangbangin' finger-lickin' directory has chizzled while open
was considered but rejected.
.LP
Da thread-safe version of tha directory readin function returns
values up in a user-supplied buffer instead of possibly rockin a
static data area dat may be overwritten by each call. Either the
{NAME_MAX} compile-time constant or tha correspondin \fIpathconf\fP()
option can be used ta determine tha maximum sizez of returned pathnames.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIclosedir\fP(), \fIlstat\fP(), \fIopendir\fP(), \fIrewinddir\fP(),
\fIsymlink\fP(),
the Base Definitions volume of IEEE\ Std\ 1003.1-2001, \fI<dirent.h>\fP,
\fI<sys/types.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
