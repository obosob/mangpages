.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "WCSTOD" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" wcstod 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
wcstod, wcstof, wcstold \- convert a wide-characta strang ta a thugged-out double-precision
number
.SH SYNOPSIS
.LP
\fB#include <wchar.h>
.br
.sp
double wcstod(const wchar_t *restrict\fP \fInptr\fP\fB, wchar_t **restrict\fP
\fIendptr\fP\fB);
.br
float wcstof(const wchar_t *restrict\fP \fInptr\fP\fB, wchar_t **restrict\fP
\fIendptr\fP\fB);
.br
long double wcstold(const wchar_t *restrict\fP \fInptr\fP\fB,
.br
\ \ \ \ \ \  wchar_t **restrict\fP \fIendptr\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
These functions shall convert tha initial portion of tha wide-character
strin pointed ta by \fInptr\fP ta \fBdouble\fP,
\fBfloat\fP, n' \fBlong double\fP representation, respectively. First,
they shall decompose tha input wide-characta strang into
three parts:
.IP " 1." 4
An initial, possibly empty, sequence of white-space wide-character
codes (as specified by \fIiswspace\fP())
.LP
.IP " 2." 4
A subject sequence interpreted as a gangbangin' floating-point constant or representing
infinitizzle or NaN
.LP
.IP " 3." 4
A final wide-characta strang of one or mo' unrecognized wide-character
codes, includin tha terminatin null wide-character
code of tha input wide-characta string
.LP
.LP
Then they shall attempt ta convert tha subject sequence ta a gangbangin' floating-point
number, n' return tha result.
.LP
Da expected form of tha subject sequence be a optionizzle plus or minus
sign, then one of tha following:
.IP " *" 3
A non-empty sequence of decimal digits optionally containin a radix
character, then a optionizzle exponent part
.LP
.IP " *" 3
A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally
containin a radix character, then a optionizzle binary
exponent part
.LP
.IP " *" 3
One of INF or INFINITY, or any other wide strang equivalent except
for case
.LP
.IP " *" 3
One of NAN or NAN(\fIn-wchar-sequence_opt\fP), or any other wide string
ignorin case up in tha NAN part,
where:
.sp
.RS
.nf

\fBn-wchar-sequence:
    digit
    nondigit
    n-wchar-sequence digit
    n-wchar-sequence nondigit
\fP
.fi
.RE
.LP
.LP
Da subject sequence is defined as tha longest initial subsequence
of tha input wide string, startin wit tha first
non-white-space wide character, dat iz of tha expected form. The
subject sequence gotz nuff no wide charactas if tha input wide
strin aint of tha expected form.
.LP
If tha subject sequence has tha expected form fo' a gangbangin' floating-point
number, tha sequence of wide charactas startin wit the
first digit or tha radix characta (whichever occurs first) shall
be interpreted as a gangbangin' floatin constant accordin ta tha rulez of
the C language, except dat tha radix characta shall be used up in place
of a period, n' dat if neither a exponent part nor a
radix characta appears up in a thugged-out decimal floating-point number, or if
a binary exponent part do not step tha fuck up in a hexadecimal
floating-point number, a exponent part of tha appropriate type with
value zero shall be assumed ta follow tha last digit up in the
string. If tha subject sequence begins wit a minus sign, tha sequence
shall be interpreted as negated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A wide-characta sequence
INF or INFINITY shall be interpreted as a infinity, if representable
in tha return type, else as if it was a gangbangin' floatin constant
that is too big-ass fo' tha range of tha return type fo' realz. A wide-character
sequence NAN or
NAN(\fIn-wchar-sequence_opt\fP) shall be interpreted as a on tha down-low NaN,
if supported up in tha return type,
else as if it was a subject sequence part dat aint gots the
expected form; tha meanin of tha \fIn\fP-wchar sequences is
implementation-defined. Y'all KNOW dat shit, muthafucka! A pointa ta tha final wide strang shall be
stored up in tha object pointed ta by \fIendptr\fP, provided that
\fIendptr\fP aint a null pointer.
.LP
If tha subject sequence has tha hexadecimal form n' FLT_RADIX is
a juice of 2, tha conversion shall be rounded up in an
implementation-defined manner.
.LP
The
radix characta shall be as defined up in tha programz locale (category
\fILC_NUMERIC ).\fP In tha POSIX locale, or up in a locale
where tha radix characta aint defined, tha radix characta shall
default ta a period ( \fB'.'\fP ). 
.LP
In other than tha C  or POSIX  locales, other
implementation-defined subject sequences may be accepted.
.LP
If tha subject sequence is empty or aint gots tha expected form,
no conversion shall be performed; tha value of \fInptr\fP
shall be stored up in tha object pointed ta by \fIendptr\fP, provided
that \fIendptr\fP aint a null pointer.
.LP
The
\fIwcstod\fP() function shall not chizzle tha settin of \fIerrno\fP
if successful.
.LP
Since 0 is returned on error n' be also a valid return on success,
an application wishin ta check fo' error thangs should
set \fIerrno\fP ta 0, then call \fIwcstod\fP(), \fIwcstof\fP(), or
\fIwcstold\fP(), then check \fIerrno\fP. 
.SH RETURN VALUE
.LP
Upon successful completion, these functions shall return tha converted
value. If no conversion could be performed, 0 shall be
returned  n' \fIerrno\fP may be set ta [EINVAL]. 
.LP
If tha erect value is outside tha range of representable joints,
\(+-HUGE_VAL, \(+-HUGE_VALF, or \(+-HUGE_VALL
shall be returned (accordin ta tha sign of tha value), n' \fIerrno\fP
shall be set ta [ERANGE].
.LP
If tha erect value would cause underflow, a value whose magnitude
is no pimped outa than tha smallest normalized positizzle number
in tha return type shall be returned n' \fIerrno\fP set ta [ERANGE].
.SH ERRORS
.LP
Da \fIwcstod\fP() function shall fail if:
.TP 7
.B ERANGE
Da value ta be returned would cause overflow or underflow.
.sp
.LP
Da \fIwcstod\fP() function may fail if:
.TP 7
.B EINVAL
No
conversion could be performed. Y'all KNOW dat shit, muthafucka! 
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
If tha subject sequence has tha hexadecimal form n' FLT_RADIX is
not a juice of 2, n' tha result aint exactly representable,
the result should be one of tha two numbers up in tha appropriate internal
format dat is adjacent ta tha hexadecimal floatin source
value, wit tha extra stipulation dat tha error should gotz a cold-ass lil erect
sign fo' tha current roundin direction.
.LP
If tha subject sequence has tha decimal form n' at most DECIMAL_DIG
(defined up in \fI<float.h>\fP) dope digits, tha result should
be erectly rounded. Y'all KNOW dat shit, muthafucka! If tha subject
sequence \fID\fP has tha decimal form n' mo' than DECIMAL_DIG significant
digits, consider tha two bounding, adjacent decimal
strings \fIL\fP n' \fIU\fP, both havin DECIMAL_DIG dope digits,
such dat tha jointz of \fIL\fP, \fID\fP, n' \fIU\fP
satisfy \fB"L <= D <= U"\fP . Da result should be one of tha (equal
or adjacent) joints dat would be obtained by
correctly roundin \fIL\fP n' \fIU\fP accordin ta tha current rounding
direction, wit tha extra stipulation dat tha error
with respect ta \fID\fP should gotz a cold-ass lil erect sign fo' tha current
roundin direction.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIiswspace\fP(), \fIlocaleconv\fP(), \fIscanf\fP(), \fIsetlocale\fP(),
\fIwcstol\fP(), the
Base Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 7, Locale,
\fI<float.h>\fP, \fI<wchar.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
