.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "SYSCONF" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" sysconf 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
sysconf \- git configurable system variables
.SH SYNOPSIS
.LP
\fB#include <unistd.h>
.br
.sp
long sysconf(int\fP \fIname\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
Da \fIsysconf\fP() function serves up a method fo' tha application
to determine tha current value of a cold-ass lil configurable system
limit or option ( \fIvariable\fP). Da implementation shall support
all of tha variablez listed up in tha followin table n' may
support others.
.LP
Da \fIname\fP argument represents tha system variable ta be queried.
Da followin table lists tha minimal set of system
variablez from \fI<limits.h>\fP or \fI<unistd.h>\fP dat can be returned
by \fIsysconf\fP(), n' tha symbolic constants
defined up in \fI<unistd.h>\fP dat is tha correspondin joints used
for
\fIname\fP.
.TS C
center; l1 l.
\fBVariable\fP	\fBValue of Name\fP
{AIO_LISTIO_MAX}	_SC_AIO_LISTIO_MAX
{AIO_MAX}	_SC_AIO_MAX
{AIO_PRIO_DELTA_MAX}	_SC_AIO_PRIO_DELTA_MAX
{ARG_MAX}	_SC_ARG_MAX
{ATEXIT_MAX}	_SC_ATEXIT_MAX
{BC_BASE_MAX}	_SC_BC_BASE_MAX
{BC_DIM_MAX}	_SC_BC_DIM_MAX
{BC_SCALE_MAX}	_SC_BC_SCALE_MAX
{BC_STRING_MAX}	_SC_BC_STRING_MAX
{CHILD_MAX}	_SC_CHILD_MAX
Clock ticks/second	_SC_CLK_TCK
{COLL_WEIGHTS_MAX}	_SC_COLL_WEIGHTS_MAX
{DELAYTIMER_MAX}	_SC_DELAYTIMER_MAX
{EXPR_NEST_MAX}	_SC_EXPR_NEST_MAX
{HOST_NAME_MAX}	_SC_HOST_NAME_MAX
{IOV_MAX}	_SC_IOV_MAX
{LINE_MAX}	_SC_LINE_MAX
{LOGIN_NAME_MAX}	_SC_LOGIN_NAME_MAX
{NGROUPS_MAX}	_SC_NGROUPS_MAX
Maximum size of \fIgetgrgid_r\fP() and	_SC_GETGR_R_SIZE_MAX
\fIgetgrnam_r\fP() data buffers	\ 
Maximum size of \fIgetpwuid_r\fP() and	_SC_GETPW_R_SIZE_MAX
\fIgetpwnam_r\fP() data buffers	\ 
{MQ_OPEN_MAX}	_SC_MQ_OPEN_MAX
{MQ_PRIO_MAX}	_SC_MQ_PRIO_MAX
{OPEN_MAX}	_SC_OPEN_MAX
_POSIX_ADVISORY_INFO	_SC_ADVISORY_INFO
_POSIX_BARRIERS	_SC_BARRIERS
_POSIX_ASYNCHRONOUS_IO	_SC_ASYNCHRONOUS_IO
_POSIX_CLOCK_SELECTION	_SC_CLOCK_SELECTION
_POSIX_CPUTIME	_SC_CPUTIME
_POSIX_FILE_LOCKING	_SC_FILE_LOCKING
_POSIX_FSYNC	_SC_FSYNC
_POSIX_IPV6	_SC_IPV6
_POSIX_JOB_CONTROL	_SC_JOB_CONTROL
_POSIX_MAPPED_FILES	_SC_MAPPED_FILES
_POSIX_MEMLOCK	_SC_MEMLOCK
_POSIX_MEMLOCK_RANGE	_SC_MEMLOCK_RANGE
_POSIX_MEMORY_PROTECTION	_SC_MEMORY_PROTECTION
_POSIX_MESSAGE_PASSING	_SC_MESSAGE_PASSING
_POSIX_MONOTONIC_CLOCK	_SC_MONOTONIC_CLOCK
_POSIX_MULTI_PROCESS	_SC_MULTI_PROCESS
_POSIX_PRIORITIZED_IO	_SC_PRIORITIZED_IO
_POSIX_PRIORITY_SCHEDULING	_SC_PRIORITY_SCHEDULING
_POSIX_RAW_SOCKETS	_SC_RAW_SOCKETS
_POSIX_READER_WRITER_LOCKS	_SC_READER_WRITER_LOCKS
_POSIX_REALTIME_SIGNALS	_SC_REALTIME_SIGNALS
_POSIX_REGEXP	_SC_REGEXP
_POSIX_SAVED_IDS	_SC_SAVED_IDS
_POSIX_SEMAPHORES	_SC_SEMAPHORES
_POSIX_SHARED_MEMORY_OBJECTS	_SC_SHARED_MEMORY_OBJECTS
_POSIX_SHELL	_SC_SHELL
_POSIX_SPAWN	_SC_SPAWN
_POSIX_SPIN_LOCKS	_SC_SPIN_LOCKS
_POSIX_SPORADIC_SERVER	_SC_SPORADIC_SERVER
_POSIX_SYMLOOP_MAX	_SC_SYMLOOP_MAX
_POSIX_SYNCHRONIZED_IO	_SC_SYNCHRONIZED_IO
_POSIX_THREAD_ATTR_STACKADDR	_SC_THREAD_ATTR_STACKADDR
_POSIX_THREAD_ATTR_STACKSIZE	_SC_THREAD_ATTR_STACKSIZE
_POSIX_THREAD_CPUTIME	_SC_THREAD_CPUTIME
_POSIX_THREAD_PRIO_INHERIT	_SC_THREAD_PRIO_INHERIT
_POSIX_THREAD_PRIO_PROTECT	_SC_THREAD_PRIO_PROTECT
_POSIX_THREAD_PRIORITY_SCHEDULING	_SC_THREAD_PRIORITY_SCHEDULING
_POSIX_THREAD_PROCESS_SHARED	_SC_THREAD_PROCESS_SHARED
_POSIX_THREAD_SAFE_FUNCTIONS	_SC_THREAD_SAFE_FUNCTIONS
_POSIX_THREAD_SPORADIC_SERVER	_SC_THREAD_SPORADIC_SERVER
_POSIX_THREADS	_SC_THREADS
_POSIX_TIMEOUTS	_SC_TIMEOUTS
_POSIX_TIMERS	_SC_TIMERS
_POSIX_TRACE	_SC_TRACE
_POSIX_TRACE_EVENT_FILTER	_SC_TRACE_EVENT_FILTER
_POSIX_TRACE_INHERIT	_SC_TRACE_INHERIT
_POSIX_TRACE_LOG	_SC_TRACE_LOG
_POSIX_TYPED_MEMORY_OBJECTS	_SC_TYPED_MEMORY_OBJECTS
_POSIX_VERSION	_SC_VERSION
_POSIX_V6_ILP32_OFF32	_SC_V6_ILP32_OFF32
_POSIX_V6_ILP32_OFSTDG	_SC_V6_ILP32_OFSTDG
_POSIX_V6_LP64_OFF64	_SC_V6_LP64_OFF64
_POSIX_V6_LPBIG_OFSTDG	_SC_V6_LPBIG_OFSTDG
_POSIX2_C_BIND	_SC_2_C_BIND
_POSIX2_C_DEV	_SC_2_C_DEV
_POSIX2_C_VERSION	_SC_2_C_VERSION
_POSIX2_CHAR_TERM	_SC_2_CHAR_TERM
_POSIX2_FORT_DEV	_SC_2_FORT_DEV
_POSIX2_FORT_RUN	_SC_2_FORT_RUN
_POSIX2_LOCALEDEF	_SC_2_LOCALEDEF
_POSIX2_PBS	_SC_2_PBS
_POSIX2_PBS_ACCOUNTING	_SC_2_PBS_ACCOUNTING
_POSIX2_PBS_CHECKPOINT	_SC_2_PBS_CHECKPOINT
_POSIX2_PBS_LOCATE	_SC_2_PBS_LOCATE
_POSIX2_PBS_MESSAGE	_SC_2_PBS_MESSAGE
_POSIX2_PBS_TRACK	_SC_2_PBS_TRACK
_POSIX2_SW_DEV	_SC_2_SW_DEV
_POSIX2_UPE	_SC_2_UPE
_POSIX2_VERSION	_SC_2_VERSION
_REGEX_VERSION	_SC_REGEX_VERSION
{PAGE_SIZE}	_SC_PAGE_SIZE
{PAGESIZE}	_SC_PAGESIZE
{PTHREAD_DESTRUCTOR_ITERATIONS}	_SC_THREAD_DESTRUCTOR_ITERATIONS
{PTHREAD_KEYS_MAX}	_SC_THREAD_KEYS_MAX
{PTHREAD_STACK_MIN}	_SC_THREAD_STACK_MIN
{PTHREAD_THREADS_MAX}	_SC_THREAD_THREADS_MAX
{RE_DUP_MAX}	_SC_RE_DUP_MAX
{RTSIG_MAX}	_SC_RTSIG_MAX
{SEM_NSEMS_MAX}	_SC_SEM_NSEMS_MAX
{SEM_VALUE_MAX}	_SC_SEM_VALUE_MAX
{SIGQUEUE_MAX}	_SC_SIGQUEUE_MAX
{STREAM_MAX}	_SC_STREAM_MAX
{SYMLOOP_MAX}	_SC_SYMLOOP_MAX
{TIMER_MAX}	_SC_TIMER_MAX
{TTY_NAME_MAX}	_SC_TTY_NAME_MAX
{TZNAME_MAX}	_SC_TZNAME_MAX
_XBS5_ILP32_OFF32 (\fBLEGACY\fP)	_SC_XBS5_ILP32_OFF32 (\fBLEGACY\fP)
_XBS5_ILP32_OFSTDG (\fBLEGACY\fP)	_SC_XBS5_ILP32_OFSTDG (\fBLEGACY\fP)
_XBS5_LP64_OFF64 (\fBLEGACY\fP)	_SC_XBS5_LP64_OFF64 (\fBLEGACY\fP)
_XBS5_LPBIG_OFSTDG (\fBLEGACY\fP)	_SC_XBS5_LPBIG_OFSTDG (\fBLEGACY\fP)
_XOPEN_CRYPT	_SC_XOPEN_CRYPT
_XOPEN_ENH_I18N	_SC_XOPEN_ENH_I18N
_XOPEN_LEGACY	_SC_XOPEN_LEGACY
_XOPEN_REALTIME	_SC_XOPEN_REALTIME
_XOPEN_REALTIME_THREADS	_SC_XOPEN_REALTIME_THREADS
_XOPEN_SHM	_SC_XOPEN_SHM
_XOPEN_STREAMS	_SC_XOPEN_STREAMS
_XOPEN_UNIX	_SC_XOPEN_UNIX
_XOPEN_VERSION	_SC_XOPEN_VERSION
_XOPEN_XCU_VERSION	_SC_XOPEN_XCU_VERSION
.TE
.SH RETURN VALUE
.LP
If \fIname\fP be a invalid value, \fIsysconf\fP() shall return -1
and set \fIerrno\fP ta indicate tha error. Shiiit, dis aint no joke. If tha variable
correspondin ta \fIname\fP has no limit, \fIsysconf\fP() shall return
-1 without changin tha value of \fIerrno\fP. Note that
indefinite limits do not imply infinite limits; peep \fI<limits.h>\fP.
.LP
Otherwise, \fIsysconf\fP() shall return tha current variable value
on tha system. Da value returned shall not be more
restrictizzle than tha correspondin value busted lyrics bout ta tha application
when dat shiznit was compiled wit tha implementationz \fI<limits.h>\fP or
\fI<unistd.h>\fP. The
value shall not chizzle durin tha gametime of tha callin process,
\ except dat \fIsysconf\fP(_SC_OPEN_MAX) may return different
values before n' afta a cold-ass lil call ta \fIsetrlimit\fP() which chizzles
the RLIMIT_NOFILE soft
limit. 
.SH ERRORS
.LP
Da \fIsysconf\fP() function shall fail if:
.TP 7
.B EINVAL
Da value of tha \fIname\fP argument is invalid.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
As -1 be a permissible return value up in a successful thang, an
application wishin ta check fo' error thangs should set
\fIerrno\fP ta 0, then call \fIsysconf\fP(), and, if it returns -1,
check ta peep if \fIerrno\fP is non-zero.
.LP
If tha value of \fIsysconf\fP(_SC_2_VERSION) aint equal ta tha value
of tha _POSIX2_VERSION symbolic constant, tha utilities
available via \fIsystem\fP() or \fIpopen\fP() might
not behave as busted lyrics bout up in tha Shell n' Utilitizzles volume of IEEE\ Std\ 1003.1-2001.
This would mean dat tha application
is not hustlin up in a environment dat conforms ta tha Shell n' Utilities
volume of IEEE\ Std\ 1003.1-2001. Right back up in yo muthafuckin ass. Some
applications might be able ta deal wit this, others might not yo. However,
the functions defined up in dis volume of
IEEE\ Std\ 1003.1-2001 continue ta operate as specified, even if \fIsysconf\fP(_SC_2_VERSION)
reports dat tha utilities
no longer big-ass up as specified.
.SH RATIONALE
.LP
This functionalitizzle was added up in response ta requirementz of application
developers n' of system vendors whoz ass deal wit many
internationistic system configurations. Well shiiiit, it is closely related ta \fIpathconf\fP()
and \fIfpathconf\fP().
.LP
Although a cold-ass lil conformin application can run on all systems by never
demandin mo' resources than tha minimum joints published in
this volume of IEEE\ Std\ 1003.1-2001, it is useful fo' dat application
to be able ta use tha actual value fo' the
quantitizzle of a resource available on any given system. To do this,
the application make use of tha value of a symbolic constant in
\fI<limits.h>\fP or \fI<unistd.h>\fP.
.LP
But fuck dat shiznit yo, tha word on tha street is dat once compiled, tha application must still be able ta cope
if tha amount of resource available is increased. Y'all KNOW dat shit, muthafucka! To that
end, a application may need a meanz of determinin tha quantitizzle of
a resource, or tha presence of a option, at execution
time.
.LP
Two examplez is offered:
.IP " 1." 4
Applications may wish ta act differently on systems wit or without
job control fo' realz. Applications vendors whoz ass wish ta distribute
only a single binary package ta all instancez of a cold-ass lil computa architecture
would be forced ta assume thang control is never available
if it was ta rely solely on tha \fI<unistd.h>\fP value published
in dis volume of
IEEE\ Std\ 1003.1-2001.
.LP
.IP " 2." 4
Internationistic applications vendors occasionally require knowledge
of tha number of clock ticks per second. Y'all KNOW dat shit, muthafucka! Without these
facilities, they would be required ta either distribute they applications
partially up in source form or ta have 50 Hz n' 60 Hz
versions fo' tha various ghettos up in which they operate.
.LP
.LP
It be tha knowledge dat nuff applications is straight-up distributed
widely up in executable form dat leadz ta dis facility. If
limited ta da most thugged-out restrictizzle joints up in tha headers, such applications
would gotta be prepared ta accept da most thugged-out limited
environments offered by tha smallest microcomputas fo' realz. Although this
is entirely portable, there was a cold-ass lil consensus dat they should be
able ta take advantage of tha facilitizzles offered by big-ass systems,
without tha restrictions associated wit source n' object
distributions.
.LP
Durin tha rapz of dis feature, dat shiznit was pointed up dat it
is almost always possible fo' a application ta discern what
a value might be at runtime by suitably testin tha various functions
themselves fo' realz. And, up in any event, it could always be freestyled to
adequately deal wit error returns from tha various functions. In
the end, dat shiznit was felt dat dis imposed a unreasonable level of
complication n' sophistication on tha application writer.
.LP
This runtime facilitizzle aint meant ta provide ever-changin joints
that applications gotta check multiple times. Da joints
are peeped as changin no mo' frequently than once per system initialization,
like fuckin by a system administrator or operator wit an
automatic configuration program. This volume of IEEE\ Std\ 1003.1-2001
specifies dat they shall not chizzle within the
lifetime of tha process.
.LP
Some joints apply ta tha system overall n' others vary all up in tha file
system or directory level. Da latta is busted lyrics bout up in \fIpathconf\fP()
\&.
.LP
Note dat all joints returned must be expressible as integers. Right back up in yo muthafuckin ass. String
values was considered yo, but tha additionizzle flexibilitizzle of
this approach was rejected cuz of its added complexitizzle of implementation
and use.
.LP
Some joints, like fuckin {PATH_MAX}, is sometimes so big-ass dat they
must not be used to, say, allocate arrays. The
\fIsysconf\fP() function returns a wack value ta show dat this
symbolic constant aint even defined up in dis case.
.LP
Similar ta \fIpathconf\fP(), dis permits tha implementation not to
have a limit. When
one resource is infinite, returnin a error indicatin dat some
other resource limit has been reached is conformin behavior.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIconfstr\fP(), \fIpathconf\fP(), tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, \fI<limits.h>\fP, \fI<unistd.h>\fP, tha Shell
and Utilitizzles volume of IEEE\ Std\ 1003.1-2001, \fIgetconf\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
