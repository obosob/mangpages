.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "FMA" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" fma 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
fma, fmaf, fmal \- floating-point multiply-add
.SH SYNOPSIS
.LP
\fB#include <math.h>
.br
.sp
double fma(double\fP \fIx\fP\fB, double\fP \fIy\fP\fB, double\fP \fIz\fP\fB);
.br
float fmaf(float\fP \fIx\fP\fB, float\fP \fIy\fP\fB, float\fP \fIz\fP\fB);
.br
long double fmal(long double\fP \fIx\fP\fB, long double\fP \fIy\fP\fB,
long double\fP \fIz\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
These functions shall compute (\fIx\fP\ *\ \fIy\fP)\ +\ \fIz\fP, rounded
as one ternary operation: they shall
compute tha value (as if) ta infinite precision n' round once to
the result format, accordin ta tha roundin mode characterized
by tha value of FLT_ROUNDS.
.LP
An application wishin ta check fo' error thangs should set \fIerrno\fP
to zero n' call
\fIfeclearexcept\fP(FE_ALL_EXCEPT) before callin these functions.
On return, if \fIerrno\fP is non-zero or
\fIfetestexcept\fP(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW)
is non-zero, a error has occurred.
.SH RETURN VALUE
.LP
Upon successful completion, these functions shall return (\fIx\fP\ *\ \fIy\fP)\ +
\fIz\fP, rounded as one ternary
operation.
.LP
If
\fIx\fP or \fIy\fP is NaN, a NaN shall be returned.
.LP
If \fIx\fP multiplied by \fIy\fP be a exact infinitizzle n' \fIz\fP
is also a infinitizzle but wit tha opposite sign, a thugged-out domain
error shall occur, n' either a NaN (if supported), or a implementation-defined
value shall be returned.
.LP
If one of \fIx\fP n' \fIy\fP is infinite, tha other is zero, and
\fIz\fP aint a NaN, a thugged-out domain error shall occur, and
either a NaN (if supported), or a implementation-defined value shall
be returned.
.LP
If one of \fIx\fP n' \fIy\fP is infinite, tha other is zero, and
\fIz\fP be a NaN, a NaN shall be returned n' a thugged-out domain
error may occur.
.LP
If \fIx\fP* \fIy\fP aint 0*Inf nor Inf*0 n' \fIz\fP be a NaN, a
NaN shall be returned. Y'all KNOW dat shit, muthafucka! 
.SH ERRORS
.LP
These functions shall fail if:
.TP 7
Domain\ Error
Da value of \fIx\fP* \fIy\fP+ \fIz\fP is invalid, or tha value \fIx\fP*
\fIy\fP is invalid n' \fIz\fP aint a NaN. 
.LP
If tha integer expression (math_errhandlin & MATH_ERRNO) is non-zero,
then \fIerrno\fP shall be set ta [EDOM]. If the
integer expression (math_errhandlin & MATH_ERREXCEPT) is non-zero,
then tha invalid floating-point exception shall be raised.
.TP 7
Range\ Error
Da result overflows. 
.LP
If tha integer expression (math_errhandlin & MATH_ERRNO) is non-zero,
then \fIerrno\fP shall be set ta [ERANGE]. If the
integer expression (math_errhandlin & MATH_ERREXCEPT) is non-zero,
then tha overflow floating-point exception shall be raised.
.sp
.LP
These functions may fail if:
.TP 7
Domain\ Error
Da value \fIx\fP* \fIy\fP is invalid n' \fIz\fP be a NaN. 
.LP
If tha integer expression (math_errhandlin & MATH_ERRNO) is non-zero,
then \fIerrno\fP shall be set ta [EDOM]. If the
integer expression (math_errhandlin & MATH_ERREXCEPT) is non-zero,
then tha invalid floating-point exception shall be raised.
.TP 7
Range\ Error
Da result underflows. 
.LP
If tha integer expression (math_errhandlin & MATH_ERRNO) is non-zero,
then \fIerrno\fP shall be set ta [ERANGE]. If the
integer expression (math_errhandlin & MATH_ERREXCEPT) is non-zero,
then tha underflow floating-point exception shall be
raised. Y'all KNOW dat shit, muthafucka! 
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
On error, tha expressions (math_errhandlin & MATH_ERRNO) n' (math_errhandling
& MATH_ERREXCEPT) is independent of
each other yo, but at least one of dem must be non-zero.
.SH RATIONALE
.LP
In nuff cases, smart-ass use of floatin (\fIfused\fP) multiply-add leads
to much improved code; but its unexpected use by the
compila can undermine carefully freestyled code. Da FP_CONTRACT macro
can be used ta disallow use of floatin multiply-add; n' the
\fIfma\fP() function guarantees its use where desired. Y'all KNOW dat shit, muthafucka! Many current
machines provide hardware floatin multiply-add instructions;
software implementation can be used fo' others.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIfeclearexcept\fP(), \fIfetestexcept\fP(), tha Base
Definitions volume of IEEE\ Std\ 1003.1-2001, Section 4.18, Treatment
of
Error Conditions fo' Mathematical Functions, \fI<math.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
