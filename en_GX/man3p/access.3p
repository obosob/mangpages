.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "ACCESS" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" access 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
access \- determine accessibilitizzle of a gangbangin' file
.SH SYNOPSIS
.LP
\fB#include <unistd.h>
.br
.sp
int access(const char *\fP\fIpath\fP\fB, int\fP \fIamode\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
Da \fIaccess\fP() function shall check tha file named by tha pathname
pointed ta by tha \fIpath\fP argument fo' accessibility
accordin ta tha bit pattern contained up in \fIamode\fP, rockin tha real
user ID up in place of tha effectizzle user ID n' tha real group
ID up in place of tha effectizzle crew ID.
.LP
Da value of \fIamode\fP is either tha bitwise-inclusive OR of the
access permissions ta be checked (R_OK, W_OK, X_OK) or the
existence test (F_OK).
.LP
If any access permissions is checked, each shall be checked individually,
as busted lyrics bout up in tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Chapta 3, Definitions. If tha process has
appropriate
privileges, a implementation may indicate success fo' X_OK even if
none of tha execute file permission bits is set.
.SH RETURN VALUE
.LP
If tha axed access is permitted, \fIaccess\fP() succeedz and
shall return 0; otherwise, -1 shall be returned and
\fIerrno\fP shall be set ta indicate tha error.
.SH ERRORS
.LP
Da \fIaccess\fP() function shall fail if:
.TP 7
.B EACCES
Permission bitz of tha file mode do not permit tha axed access,
or search permission is denied on a cold-ass lil component of tha path
prefix.
.TP 7
.B ELOOP
A loop exists up in symbolic links encountered durin resolution of the
\fIpath\fP argument.
.TP 7
.B ENAMETOOLONG
Da length of tha \fIpath\fP argument exceedz {PATH_MAX} or a pathname
component is longer than {NAME_MAX}.
.TP 7
.B ENOENT
A component of \fIpath\fP do not name a existin file or \fIpath\fP
is a empty string.
.TP 7
.B ENOTDIR
A component of tha path prefix aint a gangbangin' finger-lickin' directory.
.TP 7
.B EROFS
Write access be axed fo' a gangbangin' file on a read-only file system.
.sp
.LP
Da \fIaccess\fP() function may fail if:
.TP 7
.B EINVAL
Da value of tha \fIamode\fP argument is invalid.
.TP 7
.B ELOOP
Mo' than {SYMLOOP_MAX} symbolic links was encountered durin resolution
of tha \fIpath\fP argument.
.TP 7
.B ENAMETOOLONG
As a result of encounterin a symbolic link up in resolution of tha \fIpath\fP
argument, tha length of tha substituted pathname
strin exceeded {PATH_MAX}.
.TP 7
.B ETXTBSY
Write access be axed fo' a pure procedure (shared text) file
that is bein executed.
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.SS Testin fo' tha Existence of a File
.LP
Da followin example tests whether a gangbangin' file named \fBmyfile\fP exists
in tha \fB/tmp\fP directory.
.sp
.RS
.nf

\fB#include <unistd.h>
\&...
int result;
const char *filename = "/tmp/myfile";
.sp

result = access (filename, F_OK);
\fP
.fi
.RE
.SH APPLICATION USAGE
.LP
Additionizzle jointz of \fIamode\fP other than tha set defined up in the
description may be valid; fo' example, if a system has
extended access controls.
.SH RATIONALE
.LP
In early proposals, some inadequacies up in tha \fIaccess\fP() function
led ta tha creation of a \fIeaccess\fP() function
because:
.IP " 1." 4
Oldschool implementationz of \fIaccess\fP() do not test file access
correctly when tha process' real user ID is superuser n' shit. In
particular, they always return zero when testin execute permissions
without regard ta whether tha file is executable.
.LP
.IP " 2." 4
Da superuser has complete access ta all filez on a system fo' realz. As a cold-ass lil consequence,
programs started by tha superuser n' switched to
the effectizzle user ID wit lesser privileges cannot use \fIaccess\fP()
to test they file access permissions.
.LP
.LP
But fuck dat shiznit yo, tha word on tha street is dat tha oldschool model of \fIeaccess\fP() do not resolve
problem (1), so dis volume of IEEE\ Std\ 1003.1-2001
now allows \fIaccess\fP() ta behave up in tha desired way cuz several
implementations have erected tha problem. Dat shiznit was also
argued dat problem (2) is mo' easily solved by rockin \fIopen\fP(),
\fIchdir\fP(), or one of tha \fIexec\fP functions as
appropriate n' respondin ta tha error, rather than bustin a new
function dat would not be as reliable. Therefore,
\fIeaccess\fP() aint included up in dis volume of IEEE\ Std\ 1003.1-2001.
.LP
Da sentence concernin appropriate privileges n' execute permission
bits reflects tha two possibilitizzles implemented by
historical implementations when checkin superuser access fo' X_OK.
.LP
New implementations is discouraged from returnin X_OK unless at
least one execution permission bit is set.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIchmod\fP(), \fIstat\fP(), tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, \fI<unistd.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
