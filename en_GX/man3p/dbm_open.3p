.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "DBM_CLEARERR" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" dbm_clearerr 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey,
dbm_nextkey, dbm_open, dbm_store \- database
functions
.SH SYNOPSIS
.LP
\fB#include <ndbm.h>
.br
.sp
int dbm_clearerr(DBM *\fP\fIdb\fP\fB);
.br
void dbm_close(DBM *\fP\fIdb\fP\fB);
.br
int dbm_delete(DBM *\fP\fIdb\fP\fB, datum\fP \fIkey\fP\fB);
.br
int dbm_error(DBM *\fP\fIdb\fP\fB);
.br
datum dbm_fetch(DBM *\fP\fIdb\fP\fB, datum\fP \fIkey\fP\fB);
.br
datum dbm_firstkey(DBM *\fP\fIdb\fP\fB);
.br
datum dbm_nextkey(DBM *\fP\fIdb\fP\fB);
.br
DBM *dbm_open(const char *\fP\fIfile\fP\fB, int\fP \fIopen_flags\fP\fB,
mode_t\fP \fIfile_mode\fP\fB);
.br
int dbm_store(DBM *\fP\fIdb\fP\fB, datum\fP \fIkey\fP\fB, datum\fP
\fIcontent\fP\fB, int\fP
\fIstore_mode\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
These functions create, access, n' modify a thugged-out database.
.LP
A \fBdatum\fP consistz of at least two members, \fIdptr\fP n' \fIdsize\fP.
Da \fIdptr\fP member points ta a object that
is \fIdsize\fP bytes up in length fo' realz. Arbitrary binary data, as well as
characta strings, may be stored up in tha object pointed ta by
\fIdptr\fP.
.LP
Da database is stored up in two files. One file be a gangbangin' finger-lickin' directory containing
a bitmap of keys n' has \fB.dir\fP as its suffix. The
second file gotz nuff all data n' has \fB.pag\fP as its suffix.
.LP
Da \fIdbm_open\fP() function shall open a thugged-out database. Da \fIfile\fP
argument ta tha function is tha pathname of tha database.
Da function opens two filez named \fIfile\fP\fB.dir\fP n' \fIfile\fP\fB.pag\fP.
Da \fIopen_flags\fP argument has tha same
meanin as tha \fIflags\fP argument of \fIopen\fP() except dat a
database opened for
write-only access opens tha filez fo' read n' write access n' the
behavior of tha O_APPEND flag is unspecified. Y'all KNOW dat shit, muthafucka! The
\fIfile_mode\fP argument has tha same ol' dirty meanin as tha third argument
of \fIopen\fP().
.LP
Da \fIdbm_close\fP() function shall close a thugged-out database. Da application
shall ensure dat argument \fIdb\fP be a pointa ta a
\fBdbm\fP structure dat has been returned from a cold-ass lil call ta \fIdbm_open\fP().
.LP
These database functions shall support a internal block size large
enough ta support key/content pairz of at least 1023
bytes.
.LP
Da \fIdbm_fetch\fP() function shall read a record from a thugged-out database.
Da argument \fIdb\fP be a pointa ta a thugged-out database structure
that has been returned from a cold-ass lil call ta \fIdbm_open\fP(). Da argument
\fIkey\fP be a \fBdatum\fP dat has been initialized by the
application ta tha value of tha key dat matches tha key of tha record
the program is fetching.
.LP
Da \fIdbm_store\fP() function shall write a record ta a thugged-out database.
Da argument \fIdb\fP be a pointa ta a thugged-out database structure
that has been returned from a cold-ass lil call ta \fIdbm_open\fP(). Da argument
\fIkey\fP be a \fBdatum\fP dat has been initialized by the
application ta tha value of tha key dat identifies (for subsequent
reading, writing, or deleting) tha record tha application is
writing. Da argument \fIcontent\fP be a \fBdatum\fP dat has been
initialized by tha application ta tha value of tha record the
program is writing. Da argument \fIstore_mode\fP controls whether
\fIdbm_store\fP() replaces any pre-existin record dat has
the same key dat is specified by tha \fIkey\fP argument. Da application
shall set \fIstore_mode\fP ta either DBM_INSERT or
DBM_REPLACE. If tha database gotz nuff a record dat matches tha \fIkey\fP
argument n' \fIstore_mode\fP is DBM_REPLACE, the
existin record shall be replaced wit tha freshly smoked up record. Y'all KNOW dat shit, muthafucka! If tha database
gotz nuff a record dat matches tha \fIkey\fP argument and
\fIstore_mode\fP is DBM_INSERT, tha existin record shall be left
unchanged n' tha freshly smoked up record ignored. Y'all KNOW dat shit, muthafucka! If tha database do not
contain a record dat matches tha \fIkey\fP argument n' \fIstore_mode\fP
is either DBM_INSERT or DBM_REPLACE, tha freshly smoked up record
shall be banged up in tha database.
.LP
If tha sum of a key/content pair exceedz tha internal block size,
the result is unspecified. Y'all KNOW dat shit, muthafucka! Mo'over, tha application shall
ensure dat all key/content pairs dat hash together fit on a single
block. Da \fIdbm_store\fP() function shall return a error
in tha event dat a gangbangin' finger-lickin' disk block fills wit inseparable data.
.LP
Da \fIdbm_delete\fP() function shall delete a record n' its key
from tha database. Da argument \fIdb\fP be a pointa ta a
database structure dat has been returned from a cold-ass lil call ta \fIdbm_open\fP().
Da argument \fIkey\fP be a \fBdatum\fP dat has been
initialized by tha application ta tha value of tha key dat identifies
the record tha program is deleting.
.LP
Da \fIdbm_firstkey\fP() function shall return tha straight-up original gangsta key up in the
database. Da argument \fIdb\fP be a pointa ta a thugged-out database
structure dat has been returned from a cold-ass lil call ta \fIdbm_open\fP().
.LP
Da \fIdbm_nextkey\fP() function shall return tha next key up in the
database. Da argument \fIdb\fP be a pointa ta a thugged-out database
structure dat has been returned from a cold-ass lil call ta \fIdbm_open\fP().
Da application shall ensure dat tha \fIdbm_firstkey\fP()
function is called before callin \fIdbm_nextkey\fP(). Right back up in yo muthafuckin ass. Subsequent
calls ta \fIdbm_nextkey\fP() return tha next key until all of
the keys up in tha database done been returned.
.LP
Da \fIdbm_error\fP() function shall return tha error condizzle of
the database. Da argument \fIdb\fP be a pointa ta a
database structure dat has been returned from a cold-ass lil call ta \fIdbm_open\fP().
.LP
Da \fIdbm_clearerr\fP() function shall clear tha error condition
of tha database. Da argument \fIdb\fP be a pointa ta a
database structure dat has been returned from a cold-ass lil call ta \fIdbm_open\fP().
.LP
Da \fIdptr\fP pointas returned by these functions may point into
static storage dat may be chizzled by subsequent calls.
.LP
These functions need not be reentrant fo' realz. A function dat aint required
to be reentrant aint required ta be thread-safe.
.SH RETURN VALUE
.LP
Da \fIdbm_store\fP() n' \fIdbm_delete\fP() functions shall return
0 when they succeed n' a wack value when they
fail.
.LP
Da \fIdbm_store\fP() function shall return 1 if it is called with
a \fIflags\fP value of DBM_INSERT n' tha function findz an
existin record wit tha same key.
.LP
Da \fIdbm_error\fP() function shall return 0 if tha error condition
is not set n' return a non-zero value if tha error
condizzle is set.
.LP
Da return value of \fIdbm_clearerr\fP() is unspecified.
.LP
Da \fIdbm_firstkey\fP() n' \fIdbm_nextkey\fP() functions shall return
a key \fBdatum\fP. When tha end of tha database is
reached, tha \fIdptr\fP gangmember of tha key be a null pointer n' shit. If an
error is detected, tha \fIdptr\fP gangmember of tha key shall be a
null pointa n' tha error condizzle of tha database shall be set.
.LP
Da \fIdbm_fetch\fP() function shall return a cold-ass lil content \fBdatum\fP.
If no record up in tha database matches tha key or if a error
condizzle has been detected up in tha database, tha \fIdptr\fP member
of tha content shall be a null pointer.
.LP
Da \fIdbm_open\fP() function shall return a pointa ta a thugged-out database
structure. If a error is detected durin tha operation,
\fIdbm_open\fP() shall return a ( \fBDBM *\fP)0.
.SH ERRORS
.LP
No errors is defined.
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
Da followin code can be used ta traverse tha database:
.sp
.RS
.nf

\fBfor(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
\fP
.fi
.RE
.LP
Da \fIdbm_\fP* functions provided up in dis library should not be confused
in any way wit dem of a general-purpose database
management system. These functions do not provide fo' multiple search
keys per entry, they do not protect against multi-user access
(in other lyrics they do not lock recordz or files), n' they do not
provide tha nuff other useful database functions dat is found
in mo' robust database pimpment systems. Creatin n' updating
databases by use of these functions is relatively slow cuz of
data copies dat occur upon hash collisions. These functions is useful
for applications requirin fast lookup of relatively static
information dat is ta be indexed by a single key.
.LP
Note dat a strictly conformin application is mad limited by
these functions: since there is no way ta determine dat the
keys up in use do not all hash ta tha same value (although dat would
be rare), a strictly conformin application cannot be guaranteed
that it can store mo' than one blockz worth of data up in tha database.
As long as a key collision do not occur, additionizzle data
may be stored yo, but cuz there is no way ta determine whether an
error is cuz of a key collision or some other error condizzle (
\fIdbm_error\fP() bein effectively a Boolean), once a error is detected,
the application is effectively limited ta guessin what
the error might be if it wishes ta continue rockin these functions.
.LP
Da \fIdbm_delete\fP() function need not physically reclaim file space,
although it do make it available fo' reuse by the
database.
.LP
Afta callin \fIdbm_store\fP() or \fIdbm_delete\fP() durin a pass
all up in tha keys by \fIdbm_firstkey\fP() and
\fIdbm_nextkey\fP(), tha application should reset tha database by
callin \fIdbm_firstkey\fP() before again n' again n' again calling
\fIdbm_nextkey\fP(). Da contentz of these filez is unspecified and
may not be portable.
.SH RATIONALE
.LP
None.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIopen\fP(), tha Base Definitions volume of IEEE\ Std\ 1003.1-2001,
\fI<ndbm.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
