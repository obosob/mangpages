.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "EXIT" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" exit 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
exit, _Exit, _exit \- terminizzle a process
.SH SYNOPSIS
.LP
\fB#include <stdlib.h>
.br
.sp
void exit(int\fP \fIstatus\fP\fB);
.br
void _Exit(int\fP \fIstatus\fP\fB);
.br
.sp
.sp
#include <unistd.h>
.br
void _exit(int\fP \fIstatus\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
For \fIexit\fP() n' \fI_Exit\fP():   Da functionalitizzle busted lyrics about
on dis reference page be aligned wit the
ISO\ C standard. Y'all KNOW dat shit, muthafucka! Any conflict between tha requirements busted lyrics bout here
and tha ISO\ C standard is unintentional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. This volume
of IEEE\ Std\ 1003.1-2001 defers ta tha ISO\ C standard. Y'all KNOW dat shit, muthafucka! 
.LP
Da value of \fIstatus\fP may be 0, EXIT_SUCCESS, EXIT_FAILURE,  
\ or any other value, though only tha least dope 8 bits
(that is, \fIstatus\fP & 0377) shall be available ta a waitin parent
process. 
.LP
Da \fIexit\fP() function shall first call all functions registered
by \fIatexit\fP(),
in tha reverse order of they registration, except dat a gangbangin' function
is called afta any previously registered functions dat had
already been called all up in tha time dat shiznit was registered. Y'all KNOW dat shit, muthafucka! Each function is
called as nuff times as dat shiznit was registered. Y'all KNOW dat shit, muthafucka! If, durin tha call
to any such function, a cold-ass lil call ta tha \fIlongjmp\fP() function is made
that would terminate
the call ta tha registered function, tha behavior is undefined.
.LP
If a gangbangin' function registered by a cold-ass lil call ta \fIatexit\fP() fails ta return,
the remaining
registered functions shall not be called n' tha rest of tha \fIexit\fP()
processin shall not be completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If \fIexit\fP() is
called mo' than once, tha behavior is undefined.
.LP
Da \fIexit\fP() function shall then flush all open streams wit unwritten
buffered data, close all open streams, n' remove
all filez pimped by \fItmpfile\fP(). Finally, control shall be terminated
with the
consequences busted lyrics bout below.
.LP
The
\fI_Exit\fP() n' \fI_exit\fP() functions shall be functionally equivalent.
.LP
Da \fI_Exit\fP()  n' \fI_exit\fP()  functions
shall not call functions registered wit \fIatexit\fP() nor any registered
signal handlezs.
Whether open streams is flushed or closed, or temporary filez are
removed is implementation-defined. Y'all KNOW dat shit, muthafucka! Finally, tha callin process
is terminated wit tha consequences busted lyrics bout below.
.LP
These functions shall terminizzle tha callin process  wit tha following
consequences:  
.TP 7
\fBNote:\fP
These consequences is all extensions ta tha ISO\ C standard n' are
not further CX shaded. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat XSI extensions are
shaded.
.sp
.IP " *" 3
All of tha file descriptors, directory streams,  conversion descriptors,
and message catalog descriptors open up in tha callin process shall
be closed.
.LP
.IP " *" 3
If tha parent process of tha callin process is executin a \fIwait\fP()
or \fIwaitpid\fP(),  n' has neither set its SA_NOCLDWAIT flag
nor set SIGCHLD to
SIG_IGN,  it shall be notified of tha callin process' termination
and tha low-order eight bits (that is, bits 0377) of \fIstatus\fP
shall be made available ta dat shit. If tha parent aint waiting, the
childz status shall be made available ta it when tha parent subsequently
executes \fIwait\fP() or \fIwaitpid\fP().
.LP
Da semantics of tha \fIwaitid\fP() function shall be equivalent to
\fIwait\fP(). 
.LP
.IP " *" 3
If tha parent process of tha callin process aint executin a \fIwait\fP()
or \fIwaitpid\fP(),  n' has neither set its SA_NOCLDWAIT flag
nor set SIGCHLD to
SIG_IGN,  tha callin process shall be transformed tha fuck into a \fIzombie
process\fP fo' realz. A \fIzombie process\fP be a inactizzle process n' it shall
be deleted at some lata time when its parent process
executes \fIwait\fP() or \fIwaitpid\fP().
.LP
Da semantics of tha \fIwaitid\fP() function shall be equivalent to
\fIwait\fP(). 
.LP
.IP " *" 3
Termination of a process do not directly terminizzle its lil' thugs.
Da bustin  of a SIGHUP signal as busted lyrics bout below indirectly
terminates lil pimps up in some circumstances.
.LP
.IP " *" 3
Either:
.LP
If tha implementation supports tha SIGCHLD signal, a SIGCHLD shall
be busted ta tha parent process.
.LP
Or:
.LP
If tha parent process has set its SA_NOCLDWAIT flag, or set SIGCHLD
to SIG_IGN, tha status shall be discarded, n' tha gametime of
the callin process shall end immediately. If SA_NOCLDWAIT is set,
it is implementation-defined whether a SIGCHLD signal is busted to
the parent process. 
.LP
.IP " *" 3
Da parent process ID of all of tha callin process' existin child
processes n' zombie processes shall be set ta tha process
ID of a implementation-defined system process. That is, these processes
shall be inherited by a special system process.
.LP
.IP " *" 3
Each attached shared-memory segment is detached n' tha value of \fIshm_nattch\fP
(see \fIshmget\fP()) up in tha data structure associated wit its shared
memory ID shall be decremented by
1. 
.LP
.IP " *" 3
For each semaphore fo' which tha callin process has set a \fIsemadj\fP
value (see \fIsemop\fP()), that
value shall be added ta tha \fIsemval\fP of tha specified semaphore.
.LP
.IP " *" 3
If tha process be a cold-ass lil controllin process, tha SIGHUP signal shall be
sent ta each process up in tha foreground process crew of the
controllin terminal belongin ta tha callin process.
.LP
.IP " *" 3
If tha process be a cold-ass lil controllin process, tha controllin terminal
associated wit tha session shall be disassociated from the
session, allowin it ta be acquired by a freshly smoked up controllin process.
.LP
.IP " *" 3
If tha exit of tha process causes a process crew ta become orphaned,
and if any gangmember of tha newly-orphaned process crew is
stopped, then a SIGHUP signal followed by a SIGCONT signal shall be
sent ta each process up in tha newly-orphaned process group.
.LP
.IP " *" 3
All open named semaphores up in tha callin process shall be closed as
if by appropriate calls ta \fIsem_close\fP(). 
.LP
.IP " *" 3
Any
memory locks established by tha process via calls ta \fImlockall\fP()
or \fImlock\fP() shall be removed. Y'all KNOW dat shit, muthafucka! If locked pages up in tha address
space of tha callin process is also
mapped tha fuck into tha address spacez of other processes n' is locked by
those processes, tha locks established by tha other processes
shall be unaffected by tha call by dis process ta \fI_Exit\fP() or
\fI_exit\fP(). 
.LP
.IP " *" 3
Memory mappings dat was pimped up in tha process shall be unmapped
before tha process is destroyed. Y'all KNOW dat shit, muthafucka! 
.LP
.IP " *" 3
Any blockz of typed memory dat was mapped up in tha callin process
shall be unmapped, as if \fImunmap\fP() was implicitly called ta unmap
them. 
.LP
.IP " *" 3
All open message queue descriptors up in tha callin process shall be
closed as if by appropriate calls ta \fImq_close\fP(). 
.LP
.IP " *" 3
Any outstandin cancelable asynchronous I/O operations may be canceled.
Those asynchronous I/O operations dat is not canceled
shall complete as if tha \fI_Exit\fP() or \fI_exit\fP() operation
had not yet occurred yo, but any associated signal notifications
shall be suppressed. Y'all KNOW dat shit, muthafucka! Da \fI_Exit\fP() or \fI_exit\fP() operation
may block awaitin such I/O completion. I aint talkin' bout chicken n' gravy biatch. Whether any I/O is
canceled, n' which I/O may be canceled upon \fI_Exit\fP() or \fI_exit\fP(),
is implementation-defined. Y'all KNOW dat shit, muthafucka! 
.LP
.IP " *" 3
Threadz terminated by a cold-ass lil call ta \fI_Exit\fP() or \fI_exit\fP() shall
not invoke they cancellation cleanup handlezs or
per-thread data destructors.
.LP
.IP " *" 3
If tha callin process be a trace controlla process, any trace streams
that was pimped by tha callin process shall be shut down
as busted lyrics bout by tha \fIposix_trace_shutdown\fP() function, n' any
process'
mappin of trace event names ta trace event type identifiers built
for these trace streams may be deallocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
.LP
.SH RETURN VALUE
.LP
These functions do not return.
.SH ERRORS
.LP
No errors is defined.
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
None.
.SH APPLICATION USAGE
.LP
Normally applications should use \fIexit\fP() rather than \fI_Exit\fP()
or \fI_exit\fP().
.SH RATIONALE
.SS Process Termination
.LP
Early proposals drew a gangbangin' finger-lickin' distinction between aiiight n' abnormal process
termination. I aint talkin' bout chicken n' gravy biatch fo' realz. Abnormal termination was caused only by
certain signals n' resulted up in implementation-defined "actions",
as discussed below. Right back up in yo muthafuckin ass. Subsequent proposals distinguished three
typez of termination: \fInormal termination\fP (as up in tha current
specification), \fIsimple abnormal termination\fP, and
\fIabnormal termination wit actions\fP fo' realz. Again tha distinction between
the two typez of abnormal termination was dat they were
caused by different signals n' dat implementation-defined actions
would result up in tha latta case. Given dat these actions were
completely implementation-defined, tha early proposals was only saying
when tha actions could occur n' how tha fuck they occurrence could
be detected yo, but not what tha fuck they were, so peek-a-boo, clear tha way, I be comin' thru fo'sho. This waz of lil or no use
to conformin applications, n' thus tha distinction aint made
in dis volume of IEEE\ Std\ 1003.1-2001.
.LP
Da implementation-defined actions probably include, up in most historical
implementations, tha creation of a gangbangin' file named \fBcore\fP
in tha current hustlin directory of tha process. This file gotz nuff
an image of tha memory of tha process, together with
descriptizzle shiznit bout tha process, like sufficient ta reconstruct
the state of tha process all up in tha receipt of the
signal.
.LP
There be a potential securitizzle problem up in bustin a \fBcore\fP file
if tha process was set-user-ID n' tha current user is not
the balla of tha program, if tha process was set-group-ID n' none
of tha userz crews match tha crew of tha program, or if the
user aint gots permission ta write up in tha current directory. In
this thang, a implementation either should not create a
\fBcore\fP file or should make it unreadable by tha user.
.LP
Despite tha silence of dis volume of IEEE\ Std\ 1003.1-2001 on this
feature, applications is advised not ta create
filez named \fBcore\fP cuz of potential conflicts up in nuff implementations.
Some implementations bust a name other than
\fBcore\fP fo' tha file; fo' example, by appendin tha process ID
to tha filename.
.SS Terminatin a Process
.LP
It be blingin dat tha consequencez of process termination as busted lyrics about
occur regardless of whether tha process called
\fI_exit\fP() (like indirectly all up in \fIexit\fP()) or instead
was terminated cuz of a signal or fo' some other reason. I aint talkin' bout chicken n' gravy biatch. Note
that up in tha specific case of \fIexit\fP() dis means dat tha \fIstatus\fP
argument ta \fIexit\fP() is treated up in tha same way
as tha \fIstatus\fP argument ta \fI_exit\fP().
.LP
A language other than C may have other termination primitives than
the C-language \fIexit\fP() function, n' programs written
in such a language should use its natizzle termination primitives yo, but
those should have as part of they function tha behavior of
\fI_exit\fP() as busted lyrics about. Y'all KNOW dat shit, muthafucka! Implementations up in languages other than
C is outside tha scope of dis version of dis volume of
IEEE\ Std\ 1003.1-2001, however.
.LP
As required by tha ISO\ C standard, rockin \fBreturn\fP from \fImain\fP()
has tha same ol' dirty behavior (other than wit respect to
language scope issues) as callin \fIexit\fP() wit tha returned value.
Reachin tha end of tha \fImain\fP() function has the
same behavior as callin \fIexit\fP(0).
.LP
A value of zero (or EXIT_SUCCESS, which is required ta be zero) for
the argument \fIstatus\fP conventionally indicates
successful termination. I aint talkin' bout chicken n' gravy biatch. This correspondz ta tha justification for
\fIexit\fP() up in tha ISO\ C standard. Y'all KNOW dat shit, muthafucka! Da convention is
followed by utilitizzles like fuckin \fImake\fP n' various shells, which
interpret a zero status
from a cold-ass lil lil pimp process as success. For dis reason, applications should
not call \fIexit\fP(0) or \fI_exit\fP(0) when they
terminizzle unsuccessfully; fo' example, up in signal-catchin functions.
.LP
Historically, tha implementation-defined process dat inherits children
whose muthafathas have terminated without waitin on dem is
called \fIinit\fP n' has a process ID of 1.
.LP
Da bustin  of a SIGHUP ta tha foreground process crew when a cold-ass lil controlling
process terminates correspondz ta somewhat different
historical implementations. In System V, tha kernel sendz a SIGHUP
on termination of (essentially) a cold-ass lil controllin process. In 4.2
BSD, tha kernel do not bust SIGHUP up in a cold-ass lil case like dis yo, but the
termination of a cold-ass lil controllin process is probably noticed by a
system daemon, which arranges ta bust a SIGHUP ta tha foreground process
group wit tha \fIvhangup\fP() function. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat up in 4.2
BSD, cuz of tha behavior of tha shells dat support thang control, the
controllin process is probably a gangbangin' finger-lickin' dirty-ass shell wit no other processes
in its process group. Thus, a cold-ass lil chizzle ta make \fI_exit\fP() behave
this way up in such systems should not cause problems wit existing
applications.
.LP
Da termination of a process may cause a process crew ta become orphaned
in either of two ways. Da connection of a process
group ta its parent(s) outside of tha crew dependz on both tha muthafathas
and they lil' thugs. Thus, a process crew may be orphaned
by tha termination of tha last connectin parent process outside of
the crew or by tha termination of tha last direct descendant
of tha parent process(es). In either case, if tha termination of a
process causes a process crew ta become orphaned, processes
within tha crew is disconnected from they thang control shell, which
no longer has any shiznit on tha existence of tha process
group. Right back up in yo muthafuckin ass. Stopped processes within tha crew would languish alllll muthafuckin day.
In order ta avoid dis problem, newly orphaned process groups
that contain stopped processes is busted a SIGHUP signal n' a SIGCONT
signal ta indicate dat they done been disconnected from
their session. I aint talkin' bout chicken n' gravy biatch. Da SIGHUP signal causes tha process crew members
to terminizzle unless they is catchin or ignorin SIGHUP. Under
most circumstances, all of tha thugz of tha process crew is stopped
if any of dem is stopped.
.LP
Da action of bustin  a SIGHUP n' a SIGCONT signal ta thugz of
a newly orphaned process crew is similar ta tha action of 4.2
BSD, which sendz SIGHUP n' SIGCONT ta each stopped lil pimp of a exiting
process. If such lil pimps exit up in response ta tha SIGHUP,
any additionizzle descendants receive similar treatment at dat time.
In dis volume of IEEE\ Std\ 1003.1-2001, tha signals
are busted ta tha entire process crew all up in tha same time fo' realz. Also, up in this
volume of IEEE\ Std\ 1003.1-2001 yo, but not up in 4.2 BSD,
stopped processes may be orphaned yo, but may be thugz of a process
group dat aint orphaned; therefore, tha action taken at
\fI_exit\fP() must consider processes other than lil pimp processes.
.LP
It be possible fo' a process crew ta be orphaned by a cold-ass lil call ta \fIsetpgid\fP()
or \fIsetsid\fP(), as well as by process termination. I aint talkin' bout chicken n' gravy biatch. This volume
of
IEEE\ Std\ 1003.1-2001 do not require bustin  SIGHUP n' SIGCONT
in dem cases, cuz, unlike process termination,
those cases is not caused accidentally by applications dat is unaware
of thang control fo' realz. An implementation can chizzle ta send
SIGHUP n' SIGCONT up in dem cases as a extension; such a extension
must be documented as required up in \fI<signal.h>\fP.
.LP
Da ISO/IEC\ 9899:1999 standard addz tha \fI_Exit\fP() function that
results up in immediate program termination without
triggerin signals or \fIatexit\fP()-registered functions. In
IEEE\ Std\ 1003.1-2001, dis is equivalent ta tha \fI_exit\fP() function.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIatexit\fP(), \fIclose\fP(), \fIfclose\fP(),
\fIlongjmp\fP(), \fIposix_trace_shutdown\fP(), \fIposix_trace_trid_eventid_open\fP(),
\fIsemop\fP(), \fIshmget\fP(), \fIsigaction\fP(), \fIwait\fP()
,
\fIwaitid\fP(), \fIwaitpid\fP(), tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, \fI<stdlib.h>\fP, \fI<unistd.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
