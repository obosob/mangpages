.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "FSCANF" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" fscanf 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
fscanf, scanf, sscanf \- convert formatted input
.SH SYNOPSIS
.LP
\fB#include <stdio.h>
.br
.sp
int fscanf(FILE *restrict\fP \fIstream\fP\fB, const char *restrict\fP
\fIformat\fP\fB, ... );
.br
int scanf(const char *restrict\fP \fIformat\fP\fB, ... );
.br
int sscanf(const char *restrict\fP \fIs\fP\fB, const char *restrict\fP
\fIformat\fP\fB, ... );
.br
\fP
.SH DESCRIPTION
.LP
Da \fIfscanf\fP() function shall read from tha named input \fIstream\fP.
Da \fIscanf\fP() function shall read from the
standard input stream \fIstdin\fP. Da \fIsscanf\fP() function shall
read from tha strang \fIs\fP. Each function readz bytes,
interprets dem accordin ta a gangbangin' format, n' stores tha thangs up in dis biatch up in its
arguments, n' you can put dat on yo' toast. Each expects, as arguments, a cold-ass lil control string
\fIformat\fP busted lyrics bout below, n' a set of \fIpointer\fP arguments
indicatin where tha converted input should be stored. Y'all KNOW dat shit, muthafucka! The
result is undefined if there be insufficient arguments fo' tha format.
If tha format is exhausted while arguments remain, the
excess arguments shall be evaluated but otherwise ignored.
.LP
Conversions can be applied ta tha \fIn\fPth argument afta tha \fIformat\fP
in tha argument list, rather than ta tha next unused
argument. In dis case, tha conversion specifier characta \fB%\fP
(see below) is replaced by tha sequence
\fB"%\fP\fIn\fP\fB$"\fP, where \fIn\fP be a thugged-out decimal integer up in the
range [1,{NL_ARGMAX}]. This feature serves up fo' the
definizzle of format strings dat select arguments up in a order appropriate
to specific languages. In format strings containin the
\fB"%\fP\fIn\fP\fB$"\fP form of conversion justifications, it is unspecified
whether numbered arguments up in tha argument list
can be referenced from tha format strang mo' than once.
.LP
Da \fIformat\fP can contain either form of a cold-ass lil conversion justification-that
is, \fB%\fP or
\fB"%\fP\fIn\fP\fB$"\fP-but tha two forms cannot be mixed within a
single \fIformat\fP string. Da only exception ta this
is dat \fB%%\fP or \fB%*\fP can be mixed wit tha \fB"%\fP\fIn\fP\fB$"\fP
form. When numbered argument justifications
are used, specifyin tha \fIN\fPth argument requires dat all the
leadin arguments, from tha straight-up original gangsta ta tha ( \fIN\fP-1)th, are
pointers. 
.LP
The
\fIfscanf\fP() function up in all its forms shall allow detection of
a language-dependent radix characta up in tha input string. The
radix characta is defined up in tha programz locale (category \fILC_NUMERIC
).\fP In tha POSIX locale, or up in a locale where the
radix characta aint defined, tha radix characta shall default
to a period ( \fB'.'\fP ). 
.LP
Da format be a cold-ass lil characta string, beginnin n' endin up in its initial
shift state, if any, composed of zero or mo' directives.
Each directizzle is composed of one of tha following: one or mo' white-space
charactas ( <space>s, <tab>s,
<newline>s, <vertical-tab>s, or <form-feed>s); a ordinary character
(neither \fB'%'\fP nor a white-space
character); or a cold-ass lil conversion justification. I aint talkin' bout chicken n' gravy biatch. Each conversion justification
is introduced by tha characta \fB'%'\fP  or the
characta sequence \fB"%\fP\fIn\fP\fB$"\fP, after
which tha followin step tha fuck up in sequence:
.IP " *" 3
An optionizzle assignment-suppressin characta \fB'*'\fP .
.LP
.IP " *" 3
An optionizzle non-zero decimal integer dat specifies tha maximum field
width.
.LP
.IP " *" 3
An option length modifier dat specifies tha size of tha receiving
object.
.LP
.IP " *" 3
A \fIconversion specifier\fP characta dat specifies tha type of
conversion ta be applied. Y'all KNOW dat shit, muthafucka! Da valid conversion specifiers are
busted lyrics bout below.
.LP
.LP
Da \fIfscanf\fP() functions shall execute each directizzle of tha format
in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If a gangbangin' finger-lickin' directizzle fails, as detailed below, the
function shall return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Failures is busted lyrics bout as input failures (due
to tha unavailabilitizzle of input bytes) or matchin failures
(due ta inappropriate input).
.LP
A directizzle composed of one or mo' white-space charactas shall be
executed by readin input until no mo' valid input can be
read, or up ta tha straight-up original gangsta byte which aint a white-space character,
which remains unread.
.LP
A directizzle dat be a ordinary characta shall be executed as bigs up:
the next byte shall be read from tha input n' compared
with tha byte dat comprises tha directive; if tha comparison shows
that they is not equivalent, tha directizzle shall fail, n' the
differin n' subsequent bytes shall remain unread. Y'all KNOW dat shit, muthafucka! Similarly, if
end-of-file, a encodin error, or a read error prevents a
characta from bein read, tha directizzle shall fail.
.LP
A directizzle dat be a cold-ass lil conversion justification defines a set of matching
input sequences, as busted lyrics bout below fo' each conversion
character n' shiznit fo' realz. A conversion justification shall be executed up in tha following
steps.
.LP
Input white-space charactas (as specified by \fIisspace\fP()) shall
be skipped, unless the
conversion justification includes a \fB[\fP, \fBc\fP, \fBC\fP,
or \fBn\fP conversion specifier.
.LP
An item shall be read from tha input, unless tha conversion justification
includes a \fBn\fP conversion specifier n' shiznit fo' realz. An input
item shall be defined as tha longest sequence of input bytes (up to
any specified maximum field width, which may be measured in
charactas or bytes dependent on tha conversion specifier) which is
an initial subsequence of a matchin sequence. Da first byte,
if any, afta tha input item shall remain unread. Y'all KNOW dat shit, muthafucka! If tha length of
the input item is 0, tha execution of tha conversion
specification shall fail; dis condizzle be a matchin failure, unless
end-of-file, a encodin error, or a read error prevented
input from tha stream, up in which case it be a input failure.
.LP
Except up in tha case of a \fB%\fP conversion specifier, tha input item
(or, up in tha case of a \fB%n\fP conversion
specification, tha count of input bytes) shall be converted ta a type
appropriate ta tha conversion character n' shit. If tha input item is
not a matchin sequence, tha execution of tha conversion justification
fails; dis condizzle be a matchin failure. Unless
assignment suppression was indicated by a \fB'*'\fP, tha result of
the conversion shall be placed up in tha object pointed ta by
the first argument followin tha \fIformat\fP argument dat has not
already received a cold-ass lil conversion result if tha conversion
specification is introduced by \fB%\fP,  or up in tha \fIn\fPth argument
if introduced by tha character
sequence \fB"%\fP\fIn\fP\fB$"\fP.  If dis object do not
have a appropriate type, or if tha result of tha conversion cannot
be represented up in tha space provided, tha behavior is
undefined.
.LP
Da length modifiers n' they meanings are:
.TP 7
\fBhh\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBsigned
char\fP or \fBunsigned char\fP.
.TP 7
\fBh\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBshort\fP
or \fBunsigned short\fP.
.TP 7
\fBl\fP\ (ell)
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBlong\fP
or \fBunsigned long\fP; dat a gangbangin' followin \fBa\fP,
\fBA\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP, \fBg\fP, or \fBG\fP
conversion specifier applies ta an
argument wit type pointa ta \fBdouble\fP; or dat a gangbangin' followin \fBc\fP,
\fBs\fP, or \fB[\fP conversion specifier
applies ta a argument wit type pointa ta \fBwchar_t\fP.
.TP 7
\fBll\fP\ (ell-ell)
.sp
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP conversion
specifier applies ta a argument wit type pointa ta \fBlong long\fP
or \fBunsigned long long\fP.
.TP 7
\fBj\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBintmax_t\fP
or \fBuintmax_t\fP.
.TP 7
\fBz\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBsize_t\fP
or tha correspondin signed integer type.
.TP 7
\fBt\fP
Specifies dat a gangbangin' followin \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP,
\fBx\fP, \fBX\fP, or \fBn\fP
conversion specifier applies ta a argument wit type pointa ta \fBptrdiff_t\fP
or tha correspondin \fBunsigned\fP type.
.TP 7
\fBL\fP
Specifies dat a gangbangin' followin \fBa\fP, \fBA\fP, \fBe\fP, \fBE\fP,
\fBf\fP, \fBF\fP, \fBg\fP, or
\fBG\fP conversion specifier applies ta a argument wit type pointer
to \fBlong double\fP.
.sp
.LP
If a length modifier appears wit any conversion specifier other than
as specified above, tha behavior is undefined.
.LP
Da followin conversion specifiers is valid:
.TP 7
\fBd\fP
Matches a optionally signed decimal integer, whose format is the
same as expected fo' tha subject sequence of \fIstrtol\fP() wit the
value 10 fo' tha \fIbase\fP argument. In tha absence of a size modifier,
the application shall ensure dat tha correspondin argument be a
pointa ta \fBint\fP.
.TP 7
\fBi\fP
Matches a optionally signed integer, whose format is tha same ol' dirty as
expected fo' tha subject sequence of \fIstrtol\fP() wit 0 fo' the
\fIbase\fP argument. In tha absence of a size modifier, the
application shall ensure dat tha correspondin argument be a pointer
to \fBint\fP.
.TP 7
\fBo\fP
Matches a optionally signed octal integer, whose format is tha same
as expected fo' tha subject sequence of \fIstrtoul\fP() wit tha value
8 fo' tha \fIbase\fP argument. In tha absence of a size modifier,
the application shall ensure dat tha correspondin argument be a
pointa ta \fBunsigned\fP.
.TP 7
\fBu\fP
Matches a optionally signed decimal integer, whose format is the
same as expected fo' tha subject sequence of \fIstrtoul\fP() with
the value 10 fo' tha \fIbase\fP argument. In tha absence of a size
modifier,
the application shall ensure dat tha correspondin argument be a
pointa ta \fBunsigned\fP.
.TP 7
\fBx\fP
Matches a optionally signed hexadecimal integer, whose format is
the same as expected fo' tha subject sequence of \fIstrtoul\fP() with
the value 16 fo' tha \fIbase\fP argument. In tha absence of a size
modifier,
the application shall ensure dat tha correspondin argument be a
pointa ta \fBunsigned\fP.
.TP 7
\fBa\fP,\ \fBe\fP,\ \fBf\fP,\ \fBg\fP
.sp
Matches a optionally signed floating-point number, infinity, or NaN,
whose format is tha same ol' dirty as expected fo' tha subject sequence
of \fIstrtod\fP(). In tha absence of a size modifier, tha application
shall ensure dat the
correspondin argument be a pointa ta \fBfloat\fP. 
.LP
If tha \fIfprintf\fP() crew of functions generates characta string
representations
for infinitizzle n' NaN (a symbolic entitizzle encoded up in floating-point
format) ta support IEEE\ Std\ 754-1985, the
\fIfscanf\fP() crew of functions shall recognize dem as input.
.TP 7
\fBs\fP
Matches a sequence of bytes dat is not white-space characters. The
application shall ensure dat tha correspondin argument
is a pointa ta tha initial byte of a array of \fBchar\fP, \fBsigned
char\fP, or \fBunsigned char\fP big-ass enough ta accept the
sequence n' a terminatin null characta code, which shall be added
automatically. 
.LP
If a \fBl\fP (ell) qualifier is present, tha input be a sequence
of charactas dat begins up in tha initial shift state. Each
characta shall be converted ta a wide characta as if by a cold-ass lil call to
the \fImbrtowc\fP()
function, wit tha conversion state busted lyrics bout by a \fBmbstate_t\fP
object initialized ta zero before tha straight-up original gangsta characta is
converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da application shall ensure dat tha correspondin argument
is a pointa ta a array of \fBwchar_t\fP big-ass enough to
accept tha sequence n' tha terminatin null wide character, which
shall be added automatically.
.TP 7
\fB[\fP
Matches a non-empty sequence of bytes from a set of expected bytes
(the \fIscanset\fP). Da aiiight skip over white-space
charactas shall be suppressed up in dis case. Da application shall
ensure dat tha correspondin argument be a pointa ta the
initial byte of a array of \fBchar\fP, \fBsigned char\fP, or \fBunsigned
char\fP big-ass enough ta accept tha sequence n' a
terminatin null byte, which shall be added automatically. 
.LP
If a \fBl\fP (ell) qualifier is present, tha input be a sequence
of charactas dat begins up in tha initial shift state. Each
characta up in tha sequence shall be converted ta a wide characta as
if by a cold-ass lil call ta tha \fImbrtowc\fP() function, wit tha conversion
state busted lyrics bout by a \fBmbstate_t\fP object
initialized ta zero before tha straight-up original gangsta characta is converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da application
shall ensure dat tha correspondin argument be a
pointa ta a array of \fBwchar_t\fP big-ass enough ta accept tha sequence
and tha terminatin null wide character, which shall be
added automatically.
.LP
Da conversion justification includes all subsequent bytes up in the
\fIformat\fP strang up ta n' includin tha matchin right
square bracket ( \fB']'\fP ). Da bytes between tha square brackets
(the \fIscanlist\fP) comprise tha scanset, unless tha byte
afta tha left square bracket be a cold-ass lil circumflex ( \fB'^'\fP ), up in which
case tha scanset gotz nuff all bytes dat do not step tha fuck up in
the scanlist between tha circumflex n' tha right square bracket.
If tha conversion justification begins wit \fB"[]"\fP or
\fB"[^]"\fP, tha right square bracket is included up in tha scanlist
and tha next right square bracket is tha matchin right
square bracket dat endz tha conversion justification; otherwise,
the first right square bracket is tha one dat endz the
conversion justification. I aint talkin' bout chicken n' gravy biatch. If a \fB'-'\fP is up in tha scanlist n' is
not tha straight-up original gangsta character, nor tha second where tha first
characta be a \fB'^'\fP, nor tha last character, tha behavior is
implementation-defined.
.TP 7
\fBc\fP
Matches a sequence of bytez of tha number specified by tha field width
(1 if no field width is present up in tha conversion
specification). Da application shall ensure dat tha corresponding
argument be a pointa ta tha initial byte of a array of
\fBchar\fP, \fBsigned char\fP, or \fBunsigned char\fP big-ass enough
to accept tha sequence. No null byte be added. Y'all KNOW dat shit, muthafucka! Da normal
skip over white-space charactas shall be suppressed up in dis case.
.LP
If a \fBl\fP (ell) qualifier is present, tha input shall be a sequence
of charactas dat begins up in tha initial shift state.
Each characta up in tha sequence is converted ta a wide characta as
if by a cold-ass lil call ta tha \fImbrtowc\fP() function, wit tha conversion
state busted lyrics bout by a \fBmbstate_t\fP object
initialized ta zero before tha straight-up original gangsta characta is converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da application
shall ensure dat tha correspondin argument be a
pointa ta a array of \fBwchar_t\fP big-ass enough ta accept tha resulting
sequence of wide characters. No null wide characta is
added.
.TP 7
\fBp\fP
Matches a implementation-defined set of sequences, which shall be
the same as tha set of sequences dat is produced by the
\fB%p\fP conversion justification of tha correspondin \fIfprintf\fP()
functions. The
application shall ensure dat tha correspondin argument be a pointer
to a pointa ta \fBvoid\fP. Da interpretation of tha input
item is implementation-defined. Y'all KNOW dat shit, muthafucka! If tha input item be a value converted
earlier durin tha same program execution, tha pointa that
results shall compare equal ta dat value; otherwise, tha behavior
of tha \fB%p\fP conversion justification is undefined.
.TP 7
\fBn\fP
No input is consumed. Y'all KNOW dat shit, muthafucka! Da application shall ensure dat tha corresponding
argument be a pointa ta tha integer tha fuck into which shall
be freestyled tha number of bytes read from tha input so far by this
call ta tha \fIfscanf\fP() functions. Execution of a \fB%n\fP
conversion justification shall not increment tha assignment count
returned all up in tha completion of execution of tha function. I aint talkin' bout chicken n' gravy biatch. No
argument shall be converted yo, but one shall be consumed. Y'all KNOW dat shit, muthafucka! If tha conversion
specification includes a assignment-suppressing
characta or a gangbangin' field width, tha behavior is undefined.
.TP 7
\fBC\fP
Equivalent ta \fBlc\fP . 
.TP 7
\fBS\fP
Equivalent ta \fBls\fP . 
.TP 7
\fB%\fP
Matches a single \fB'%'\fP character; no conversion or assignment
occurs. Da complete conversion justification shall be
\fB%%\fP .
.sp
.LP
If a cold-ass lil conversion justification is invalid, tha behavior is undefined.
.LP
Da conversion specifiers \fBA\fP, \fBE\fP, \fBF\fP, \fBG\fP,
and \fBX\fP is also valid n' shall be
equivalent ta \fBa\fP, \fBe\fP, \fBf\fP, \fBg\fP, n' \fBx\fP,
respectively.
.LP
If end-of-file is encountered durin input, conversion shall be terminated.
If end-of-file occurs before any bytes matchin the
current conversion justification (except fo' \fB%n\fP ) have been
read (other than leadin white-space characters, where
permitted), execution of tha current conversion justification shall
terminizzle wit a input failure. Otherwise, unless execution of
the current conversion justification is terminated wit a matching
failure, execution of tha followin conversion justification (if
any) shall be terminated wit a input failure.
.LP
Reachin tha end of tha strang up in \fIsscanf\fP() shall be equivalent
to encounterin end-of-file fo' \fIfscanf\fP().
.LP
If conversion terminates on a cold-ass lil conflictin input, tha offendin input
is left unread up in tha input fo' realz. Any trailin white space
(includin <newline>s) shall be left unread unless matched by a cold-ass lil conversion
specification. I aint talkin' bout chicken n' gravy biatch. Da success of literal matches and
suppressed assignments is only directly determinable via tha \fB%n\fP
conversion justification.
.LP
The
\fIfscanf\fP() n' \fIscanf\fP() functions may mark tha \fIst_atime\fP
field of tha file associated wit \fIstream\fP for
update. Da \fIst_atime\fP field shall be marked fo' update by the
first successful execution of \fIfgetc\fP(), \fIfgets\fP(), \fIfread\fP(),
\fIgetc\fP(), \fIgetchar\fP(), \fIgets\fP(), \fIfscanf\fP(), or
\fIfscanf\fP() rockin \fIstream\fP dat returns data not supplied by
a prior call ta \fIungetc\fP(). 
.SH RETURN VALUE
.LP
Upon successful completion, these functions shall return tha number
of successfully matched n' assigned input items; this
number can be zero up in tha event of a early matchin failure. If the
input endz before tha straight-up original gangsta matchin failure or conversion,
EOF shall be returned. Y'all KNOW dat shit, muthafucka! If a read error occurs, tha error indicator
for tha stream is set, EOF shall be returned,  and
\fIerrno\fP shall be set ta indicate tha error. Shiiit, dis aint no joke. 
.SH ERRORS
.LP
For tha conditions under which tha \fIfscanf\fP() functions fail and
may fail, refer ta \fIfgetc\fP()
or \fIfgetwc\fP().
.LP
In addition, \fIfscanf\fP() may fail if:
.TP 7
.B EILSEQ
Input byte sequence do not form a valid character n' shit. 
.TP 7
.B EINVAL
There is insufficient arguments, n' you can put dat on yo' toast. 
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.LP
Da call:
.sp
.RS
.nf

\fBint i, n; float x; char name[50];
n = scanf("%d%f%s", &i, &x, name);
\fP
.fi
.RE
.LP
with tha input line:
.sp
.RS
.nf

\fB25 54.32E-1 Hamster
\fP
.fi
.RE
.LP
assigns ta \fIn\fP tha value 3, ta \fIi\fP tha value 25, ta \fIx\fP
the value 5.432, n' \fIname\fP gotz nuff tha string
\fB"Hamster"\fP .
.LP
Da call:
.sp
.RS
.nf

\fBint i; float x; char name[50];
(void) scanf("%2d%f%*d %[0123456789]", &i, &x, name);
\fP
.fi
.RE
.LP
with input:
.sp
.RS
.nf

\fB56789 0123 56a72
\fP
.fi
.RE
.LP
assigns 56 ta \fIi\fP, 789.0 ta \fIx\fP, skips 0123, n' places the
strin \fB"56\\0"\fP up in \fIname\fP. Da next call ta \fIgetchar\fP()
shall return tha characta \fB'a'\fP .
.SS Readin Data tha fuck into a Array
.LP
Da followin call uses \fIfscanf\fP() ta read three floating-point
numbers from standard input tha fuck into tha \fIinput\fP
array.
.sp
.RS
.nf

\fBfloat input[3]; fscanf (stdin, "%f %f %f", input, input+1, input+2);
\fP
.fi
.RE
.SH APPLICATION USAGE
.LP
If tha application callin \fIfscanf\fP() has any objectz of type
\fBwint_t\fP or \fBwchar_t\fP, it must also include tha \fI<wchar.h>\fP
header ta have these objects defined.
.SH RATIONALE
.LP
This function be aligned wit tha ISO/IEC\ 9899:1999 standard, and
in bustin so all dem "obvious" thangs was not included.
Specifically, tha set of charactas allowed up in a scanset is limited
to single-byte characters. In other similar places, multi-byte
charactas done been permitted yo, but fo' alignment wit tha ISO/IEC\ 9899:1999
standard, it has not been done here, so peek-a-boo, clear tha way, I be comin' thru fo'sho fo' realz. Applications
needin dis could use tha correspondin wide-characta functions
to big up tha desired thangs up in dis biatch.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIgetc\fP(), \fIprintf\fP(), \fIsetlocale\fP(), \fIstrtod\fP(),
\fIstrtol\fP(),
\fIstrtoul\fP(), \fIwcrtomb\fP(), tha Base Definitions volume of
IEEE\ Std\ 1003.1-2001, Chapta 7, Locale, \fI<langinfo.h>\fP, \fI<stdio.h>\fP,
\fI<wchar.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
