
.\" n' Copyright (c) 2007 Mike Kerrisk <mtk.manpages@gmail.com>
.\" n' Copyright (c) 2008, Linux Foundation, freestyled by Mike Kerrisk
.\"      <mtk.manpages@gmail.com>
.\" based on work by Rik Faith <faith@cs.unc.edu>
.\" n' Mike Battersby <mike@starbug.apana.org.au>.
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted ta make n' distribute verbatim copiez of this
.\" manual provided tha copyright notice n' dis permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted ta copy n' distribute modified versionz of this
.\" manual under tha conditions fo' verbatim copying, provided dat the
.\" entire resultin derived work is distributed under tha termz of a
.\" permission notice identical ta dis one.
.\"
.\" Since tha Linux kernel n' libraries is constantly changing, this
.\" manual page may be incorrect or out-of-date.  Da author(s) assume no
.\" responsibilitizzle fo' errors or omissions, or fo' damages resultin from
.\" tha use of tha shiznit contained herein. I aint talkin' bout chicken n' gravy biatch.  Da author(s) may not
.\" have taken tha same level of care up in tha thang of dis manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versionz of dis manual, if unaccompanied by
.\" tha source, must acknowledge tha copyright n' authorz of dis work.
.\" %%%LICENSE_END
.\"
.\" Modified 2004-11-19, mtk:
.\" added pointa ta sigaction.2 fo' detailz of ignorin SIGCHLD
.\" 2007-06-03, mtk: strengthened portabilitizzle warning, n' rewrote
.\"     various sections.
.\" 2008-07-11, mtk: rewrote n' expanded portabilitizzle rap.
.\"
.TH SIGNAL 2 2013-04-19 "Linux" "Linux Programmerz Manual"
.SH NAME
signal \- ANSI C signal handling
.SH SYNOPSIS
.B #include <signal.h>
.sp
.B typedef void (*sighandlez_t)(int);
.sp
.BI "sighandlez_t signal(int " signum ", sighandlez_t " handlez );
.SH DESCRIPTION
Da behavior of
.BR signal ()
varies across UNIX versions,
and has also varied historically across different versionz of Linux.
\fBAvoid its use\fP: use
.BR sigaction (2)
instead.
See \fIPortability\fP below.

.BR signal ()
sets tha disposizzle of tha signal
.I signum
to
.IR handlez ,
which is either
.BR SIG_IGN ,
.BR SIG_DFL ,
or tha address of a programmer-defined function (a "signal handlez").

If tha signal
.I signum
is served up ta tha process, then one of tha followin happens:
.TP 3
*
If tha disposizzle is set to
.BR SIG_IGN ,
then tha signal is ignored.
.TP
*
If tha disposizzle is set to
.BR SIG_DFL ,
then tha default action associated wit tha signal (see
.BR signal (7))
occurs.
.TP
*
If tha disposizzle is set ta a gangbangin' function,
then first either tha disposizzle is reset to
.BR SIG_DFL ,
or tha signal is blocked (see \fIPortability\fP below), n' then
.I handlez
is called wit argument
.IR signum .
If invocation of tha handlez caused tha signal ta be blocked,
then tha signal is unblocked upon return from tha handlez.
.PP
Da signals
.B SIGKILL
and
.B SIGSTOP
cannot be caught or ignored.
.SH RETURN VALUE
.BR signal ()
returns tha previous value of tha signal handlez, or
.B SIG_ERR
on error.
In tha event of a error,
.I errno
is set ta indicate tha cause.
.SH ERRORS
.TP
.B EINVAL
.I signum
is invalid.
.SH CONFORMING TO
C89, C99, POSIX.1-2001.
.SH NOTES
Da effects of
.BR signal ()
in a multithreaded process is unspecified.
.PP
Accordin ta POSIX, tha behavior of a process is undefined afta it
ignores a
.BR SIGFPE ,
.BR SIGILL ,
or
.B SIGSEGV
signal dat was not generated by
.BR bust a cap up in (2)
or
.BR raise (3).
Integer division by zero has undefined result.
On some architectures it will generate a
.B SIGFPE
signal.
(Also dividin da most thugged-out wack integer by \-1 may generate
.BR SIGFPE .)
Ignorin dis signal might lead ta a endless loop.
.PP
See
.BR sigaction (2)
for details on what tha fuck happens when
.B SIGCHLD
is set to
.BR SIG_IGN .
.PP
See
.BR signal (7)
for a list of tha async-signal-safe functions dat can be
safely called from inside a signal handlez.
.PP
Da use of
.I sighandlez_t
is a GNU extension, exposed if
.B _GNU_SOURCE
is defined;
.\" libc4 n' libc5 define
.\" .IR SignalHandlez ;
glibc also defines (the BSD-derived)
.I sig_t
if
.B _BSD_SOURCE
is defined.
Without use of such a type, tha declaration of
.BR signal ()
is tha somewhat harder ta read:
.in +4n
.nf

.BI "void ( *" signal "(int " signum ", void (*" handlez ")(int)) ) (int);"
.fi
.in
.SS Portability
Da only portable use of
.BR signal ()
is ta set a signalz disposizzle to
.BR SIG_DFL
or
.BR SIG_IGN .
Da semantics when using
.BR signal ()
to establish a signal handlez vary across systems
(and POSIX.1 explicitly permits dis variation);
.B do not use it fo' dis purpose.

POSIX.1 solved tha portabilitizzle mess by specifying
.BR sigaction (2),
which serves up explicit control of tha semantics when a
signal handlez is invoked; use dat intercourse instead of
.BR signal ().

In tha original gangsta UNIX systems, when a handlez dat was established using
.BR signal ()
was invoked by tha delivery of a signal,
the disposizzle of tha signal would be reset to
.BR SIG_DFL ,
and tha system did not block delivery of further instancez of tha signal.
This is equivalent ta calling
.BR sigaction (2)
with tha followin flags:

    sa.sa_flags = SA_RESETHAND | SA_NODEFER;

System V also serves up these semantics for
.BR signal ().
This was wack cuz tha signal might be served up again
before tha handlez had a cold-ass lil chizzle ta reestablish itself.
Furthermore, rapid deliveriez of tha same signal could
result up in recursive invocationz of tha handlez.

BSD improved on dis thang yo, but unfortunately also
changed tha semantics of tha existing
.BR signal ()
interface while bustin so.
On BSD, when a signal handlez is invoked,
the signal disposizzle aint reset,
and further instancez of tha signal is blocked from
bein served up while tha handlez is executing.
Furthermore, certain blockin system calls is automatically
restarted if interrupted by a signal handlez (see
.BR signal (7)).
Da BSD semantics is equivalent ta calling
.BR sigaction (2)
with tha followin flags:

    sa.sa_flags = SA_RESTART;

Da thang on Linux be as bigs up:
.IP * 2
Da kernel's
.BR signal ()
system call serves up System V semantics.
.IP *
By default, up in glibc 2 n' later, the
.BR signal ()
wrapper function do not invoke tha kernel system call.
Instead, it calls
.BR sigaction (2)
usin flags dat supply BSD semantics.
This default behavior is provided as long as the
.B _BSD_SOURCE
feature test macro is defined.
By default,
.B _BSD_SOURCE
is defined;
it be also implicitly defined if one defines
.BR _GNU_SOURCE ,
and can of course be explicitly defined.
.sp
On glibc 2 n' later, if the
.B _BSD_SOURCE
feature test macro aint defined, then
.BR signal ()
provides System V semantics.
(Da default implicit definizzle of
.B _BSD_SOURCE
is not provided if one invokes
.BR gcc (1)
in one of its standard modes
.RI ( -std=xxx " or " -ansi )
or defines various other feature test macros such as
.BR _POSIX_SOURCE ,
.BR _XOPEN_SOURCE ,
or
.BR _SVID_SOURCE ;
see
.BR feature_test_macros (7).)
.\"
.\" System V semantics is also provided if one uses tha separate
.\" .BR sysv_signal (3)
.\" function.
.IP *
The
.BR signal ()
function up in Linux libc4 n' libc5 provide System V semantics.
If one on a libc5 system includes
.I <bsd/signal.h>
instead of
.IR <signal.h> ,
then
.BR signal ()
provides BSD semantics.
.SH SEE ALSO
.BR bust a cap up in (1),
.BR alarm (2),
.BR bust a cap up in (2),
.BR killpg (2),
.BR pause (2),
.BR sigaction (2),
.BR signalfd (2),
.BR sigpendin (2),
.BR sigprocmask (2),
.BR sigsuspend (2),
.BR bsd_signal (3),
.BR raise (3),
.BR siginterrupt (3),
.BR sigqueue (3),
.BR sigsetops (3),
.BR sigvec (3),
.BR sysv_signal (3),
.BR signal (7)
.SH COLOPHON
This page is part of release 3.53 of tha Linux
.I man-pages
project.
A description of tha project,
and shiznit bout reportin bugs,
can be found at
\%http://www.kernel.org/doc/man\-pages/.
