'\" 
'\" Copyright (c) 2005-2006 Donal K. Fellows
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type, biatch? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version, biatch? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH chan n 8.5 Tcl "Tcl Built-In Commands"
.BS
'\" Note:  do not modify tha .SH NAME line immediately below!
.SH NAME
chan \- Read, write n' manipulate channels
.SH SYNOPSIS
\fBchan \fIoption\fR ?\fIarg arg ...\fR?
.BE
.SH DESCRIPTION
.PP
This command serves up nuff muthafuckin operations fo' readin from, freestylin to
and otherwise manipulatin open channels (like fuckin done been pimped
with tha \fBopen\fR n' \fBsocket\fR commands, or tha default named
channels \fBstdin\fR, \fBstdout\fR or \fBstderr\fR which correspond to
the processs standard input, output n' error streams respectively).
\fIOption\fR indicates what tha fuck ta do wit tha channel; any unique
abbreviation fo' \fIoption\fR be acceptable. Valid options are:
.TP
\fBchan blocked \fIchannelId\fR
.
This tests whether tha last input operation on tha channel called
\fIchannelId\fR failed cuz it would have otherwise caused the
process ta block, n' returns 1 if dat was tha case. Well shiiiit, it returns 0
otherwise. Note dat dis only eva returns 1 when tha channel has
been configured ta be non-blocking; all Tcl channels have blocking
turned on by default.
.TP
\fBchan close \fIchannelId\fR
.
Close n' destroy tha channel called \fIchannelId\fR. Note dat this
deletes all existin file-events registered on tha channel.
.RS
.PP
As part of closin tha channel, all buffered output is flushed ta the
channelz output device, any buffered input is discarded, the
underlyin operatin system resource is closed n' \fIchannelId\fR
becomes unavailable fo' future use.
.PP
If tha channel is blocking, tha command do not return until all
output is flushed. Y'all KNOW dat shit, muthafucka!  If tha channel is nonblockin n' there is
unflushed output, tha channel remains open n' tha command returns
immediately; output is ghon be flushed up in tha background n' tha channel
will be closed when all tha flushin is complete.
.PP
If \fIchannelId\fR be a funky-ass blockin channel fo' a cold-ass lil command pipeline then
\fBchan close\fR waits fo' tha lil pimp processes ta complete.
.PP
If tha channel is shared between interpreters, then \fBchan close\fR
makes \fIchannelId\fR unavailable up in tha invokin interpreta but has
no other effect until all of tha pluggin interpretas have closed the
channel. When tha last interpreta up in which tha channel is registered
invokes \fBchan close\fR (or \fBclose\fR), tha cleanup actions
busted lyrics bout above occur. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. See tha \fBinterp\fR command fo' a thugged-out description
of channel sharing.
.PP
Channels is automatically closed when a interpreta is destroyed and
when tha process exits, n' you can put dat on yo' toast.  Channels is switched ta blockin mode, to
ensure dat all output is erectly flushed before tha process exits.
.PP
Da command returns a empty string, n' may generate a error if
an error occurs while flushin output.  If a cold-ass lil command up in a cold-ass lil command
pipeline pimped wit \fBopen\fR returns a error, \fBchan close\fR
generates a error (similar ta tha \fBexec\fR command.)
.RE
.TP
\fBchan configure \fIchannelId\fR ?\fIoptionName\fR, biatch? ?\fIvalue\fR, biatch? ?\fIoptionName value\fR?...
.
Query or set tha configuration optionz of tha channel named
\fIchannelId\fR.
.RS
.PP
If no \fIoptionName\fR or \fIvalue\fR arguments is supplied, the
command returns a list containin alternatin option names n' joints
for tha channel.  If \fIoptionName\fR is supplied but no \fIvalue\fR
then tha command returns tha current value of tha given option. I aint talkin' bout chicken n' gravy biatch.  If
one or mo' pairz of \fIoptionName\fR n' \fIvalue\fR is supplied,
the command sets each of tha named options ta tha corresponding
\fIvalue\fR; up in dis case tha return value be a empty string.
.PP
Da options busted lyrics bout below is supported fo' all channels. In
addition, each channel type may add options dat only it supports, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See
the manual entry fo' tha command dat creates each type of channels
for tha options dat that specific type of channel supports, n' you can put dat on yo' toast. For
example, peep tha manual entry fo' tha \fBsocket\fR command fo' its
additionizzle options.
.TP
\fB\-blocking\fR \fIboolean\fR
.
Da \fB\-blocking\fR option determines whether I/O operations on the
channel can cause tha process ta block indefinitely.  Da value of the
option must be a proper boolean value.  Channels is normally in
blockin mode; if a cold-ass lil channel is placed tha fuck into nonblockin mode it will
affect tha operation of tha \fBchan gets\fR, \fBchan read\fR, \fBchan
puts\fR, \fBchan flush\fR, n' \fBchan close\fR commands; peep the
documentation fo' dem commandz fo' details.  For nonblockin mode to
work erectly, tha application must be rockin tha Tcl event loop
(e.g. by callin \fBTcl_DoOneEvent\fR or invokin tha \fBvwait\fR
command).
.TP
\fB\-buffering\fR \fInewValue\fR
.
If \fInewValue\fR is \fBfull\fR then tha I/O system will buffer output
until its internal buffer is full or until tha \fBchan flush\fR
command is invoked. Y'all KNOW dat shit, muthafucka! If \fInewValue\fR is \fBline\fR, then tha I/O
system will automatically flush output fo' tha channel whenever a
newline characta is output. If \fInewValue\fR is \fBnone\fR, tha I/O
system will flush automatically afta every last muthafuckin output operation. I aint talkin' bout chicken n' gravy biatch.  The
default is fo' \fB\-buffering\fR ta be set ta \fBfull\fR except for
channels dat connect ta terminal-like devices; fo' these channels the
initial settin is \fBline\fR.  Additionally, \fBstdin\fR and
\fBstdout\fR is initially set ta \fBline\fR, n' \fBstderr\fR is set
to \fBnone\fR.
.TP
\fB\-buffersize\fR \fInewSize\fR
.
\fINewvalue\fR must be a integer; its value is used ta set tha size
of buffers, up in bytes, subsequently allocated fo' dis channel ta store
input or output. \fINewvalue\fR must be a fuckin shitload of no mo' than one
million, allowin bufferz of up ta one mazillion bytes up in size.
.TP
\fB\-encoding\fR \fIname\fR
.
This option is used ta specify tha encodin of tha channel as one of
the named encodings returned by \fBencodin names\fR or tha special
value \fBbinary\fR, so dat tha data can be converted ta n' from
Unicode fo' use up in Tcl.  For instance, up in order fo' Tcl ta read
charactas from a Japanese file up in \fBshiftjis\fR n' properly process
and display tha contents, tha encodin would be set ta \fBshiftjis\fR.
Thereafter, when readin from tha channel, tha bytes up in tha Japanese
file would be converted ta Unicode as they is read. Y'all KNOW dat shit, muthafucka!  Freestylin be also
supported \- as Tcl strings is freestyled ta tha channel they will
automatically be converted ta tha specified encodin on output.
.RS
.PP
If a gangbangin' file gotz nuff pure binary data (for instance, a JPEG image), the
encodin fo' tha channel should be configured ta be \fBbinary\fR.  Tcl
will then assign no interpretation ta tha data up in tha file n' simply
read or write raw bytes.  Da Tcl \fBbinary\fR command can be used to
manipulate dis byte-oriented data.  It be probably betta ta set the
\fB\-translation\fR option ta \fBbinary\fR when you wanna transfer
binary data, as dis turns off tha other automatic interpretations of
the bytes up in tha stream as well.
.PP
Da default encodin fo' newly opened channels is tha same ol' dirty platform-
and locale-dependent system encodin used fo' interfacin wit the
operatin system, as returned by \fBencodin system\fR.
.RE
.TP
\fB\-eofchar\fR \fIchar\fR
.TP
\fB\-eofchar\fR \fB{\fIinChar outChar\fB}\fR
.
This option supports DOS file systems dat use Control-z (\ex1a) as an
end of file marker n' shit.  If \fIchar\fR aint a empty string, then this
characta signals end-of-file when it is encountered durin input.
For output, tha end-of-file characta is output when tha channel is
closed. Y'all KNOW dat shit, muthafucka!  If \fIchar\fR is tha empty string, then there is no special
end of file characta marker n' shit.  For read-write channels, a two-element
list specifies tha end of file marker fo' input n' output,
respectively.  As a cold-ass lil convenience, when settin tha end-of-file
characta fo' a read-write channel you can specify a single value that
will apply ta both readin n' writing.  When queryin tha end-of-file
characta of a read-write channel, a two-element list will always be
returned. Y'all KNOW dat shit, muthafucka!  Da default value fo' \fB\-eofchar\fR is tha empty string
in all cases except fo' filez under Windows.  In dat case the
\fB\-eofchar\fR is Control-z (\ex1a) fo' readin n' tha empty string
for writing.
Da aaight range fo' \fB\-eofchar\fR joints is \ex01 - \ex7f;
attemptin ta set \fB\-eofchar\fR ta a value outside of dis range will
generate a error.
.TP
\fB\-translation\fR \fImode\fR
.TP
\fB\-translation\fR \fB{\fIinMode outMode\fB}\fR 
.
In Tcl scripts tha end of a line be always represented rockin a single
newline characta (\en).  But fuck dat shiznit yo, tha word on tha street is dat up in actual filez n' devices tha end
of a line may be represented differently on different platforms, or
even fo' different devices on tha same platform.  For example, under
UNIX newlines is used up in files, whereas carriage-return-linefeed
sequences is normally used up in network connections.  On input (i.e.,
with \fBchan gets\fR n' \fBchan read\fR) tha Tcl I/O system
automatically translates tha external end-of-line representation into
newline characters.  Upon output (i.e., wit \fBchan puts\fR), tha I/O
system translates newlines ta tha external end-of-line representation.
Da default translation mode, \fBauto\fR, handlez all tha common cases
automatically yo, but tha \fB\-translation\fR option serves up explicit
control over tha end of line translations.
.RS
.PP
Da value associated wit \fB\-translation\fR be a single item for
read-only n' write-only channels.  Da value be a two-element list for
read-write channels; tha read translation mode is tha straight-up original gangsta element of
the list, n' tha write translation mode is tha second element.  As a
convenience, when settin tha translation mode fo' a read-write channel
you can specify a single value dat will apply ta both readin and
writing.  When queryin tha translation mode of a read-write channel, a
two-element list will always be returned. Y'all KNOW dat shit, muthafucka!  Da followin joints are
currently supported:
.TP
\fBauto\fR
.
As tha input translation mode, \fBauto\fR treats any of newline
(\fBlf\fR), carriage return (\fBcr\fR), or carriage return followed by
a newline (\fBcrlf\fR) as tha end of line representation. I aint talkin' bout chicken n' gravy biatch.  Da end of
line representation can even chizzle from line-to-line, n' all cases
are translated ta a newline.  As tha output translation mode,
\fBauto\fR chizzlez a platform specific representation; fo' sockets on
all platforms Tcl chizzlez \fBcrlf\fR, fo' all Unix flavors, it chizzles
\fBlf\fR, n' fo' tha various flavorz of Windows it chizzles
\fBcrlf\fR.  Da default settin fo' \fB\-translation\fR is \fBauto\fR
for both input n' output.
.TP
\fBbinary\fR 
.
No end-of-line translations is performed. Y'all KNOW dat shit, muthafucka!  This is nearly identical
to \fBlf\fR mode, except dat up in addizzle \fBbinary\fR mode also sets
the end-of-file characta ta tha empty strang (which disablez it) and
sets tha encodin ta \fBbinary\fR (which disablez encodin filtering).
See tha description of \fB\-eofchar\fR n' \fB\-encoding\fR fo' more
information.
.TP
\fBcr\fR
.
Da end of a line up in tha underlyin file or thang is represented by a
single carriage return character n' shit.  As tha input translation mode,
\fBcr\fR mode converts carriage returns ta newline characters.  As the
output translation mode, \fBcr\fR mode translates newline characters
to carriage returns.
.TP
\fBcrlf\fR
.
Da end of a line up in tha underlyin file or thang is represented by a
carriage return characta followed by a linefeed character n' shit.  As the
input translation mode, \fBcrlf\fR mode converts
carriage-return-linefeed sequences ta newline characters.  As the
output translation mode, \fBcrlf\fR mode translates newline characters
to carriage-return-linefeed sequences.  This mode is typically used on
Windows platforms n' fo' network connections.
.TP
\fBlf\fR
.
Da end of a line up in tha underlyin file or thang is represented by a
single newline (linefeed) character n' shit.  In dis mode no translations
occur durin either input or output.  This mode is typically used on
UNIX platforms.
.RE
.RE
.TP
\fBchan copy \fIinputChan outputChan\fR ?\fB\-size \fIsize\fR, biatch? ?\fB\-command \fIcallback\fR?
.
Copy data from tha channel \fIinputChan\fR, which must have been
opened fo' reading, ta tha channel \fIoutputChan\fR, which must have
been opened fo' writing. Da \fBchan copy\fR command leverages the
bufferin up in tha Tcl I/O system ta avoid extra copies n' ta avoid
bufferin too much data up in main memory when copyin big-ass filez to
slow destinations like network sockets.
.RS
.PP
Da \fBchan copy\fR command transfers data from \fIinputChan\fR until
end of file or \fIsize\fR bytes done been transferred. Y'all KNOW dat shit, muthafucka! If no
\fB\-size\fR argument is given, then tha copy goes until end of file.
All tha data read from \fIinputChan\fR is copied ta \fIoutputChan\fR.
Without tha \fB\-command\fR option, \fBchan copy\fR blocks until the
copy is complete n' returns tha number of bytes freestyled to
\fIoutputChan\fR.
.PP
Da \fB\-command\fR argument make \fBchan copy\fR work up in the
background. Y'all KNOW dat shit, muthafucka!  In dis case it returns immediately n' the
\fIcallback\fR is invoked lata when tha copy completes.  The
\fIcallback\fR is called wit one or two additionizzle arguments that
indicates how tha fuck nuff bytes was freestyled ta \fIoutputChan\fR.  If an
error occurred durin tha background copy, tha second argument is the
error strang associated wit tha error. Shiiit, dis aint no joke.  With a funky-ass background copy, it is
not necessary ta put \fIinputChan\fR or \fIoutputChan\fR into
non-blockin mode; tha \fBchan copy\fR command takes care of that
automatically.  But fuck dat shiznit yo, tha word on tha street is dat it is necessary ta enta tha event loop by
usin tha \fBvwait\fR command or by rockin Tk.
.PP
Yo ass aint allowed ta do other I/O operations wit \fIinputChan\fR or
\fIoutputChan\fR durin a funky-ass background \fBchan copy\fR.  If either
\fIinputChan\fR or \fIoutputChan\fR git closed while tha copy is in
progress, tha current copy is stopped n' tha command callback is
\fInot\fR made.  If \fIinputChan\fR is closed, then all data already
queued fo' \fIoutputChan\fR is freestyled out.
.PP
Note dat \fIinputChan\fR can become readable durin a funky-ass background
copy.  Yo ass should turn off any \fBchan event\fR or \fBfileevent\fR
handlezs durin a funky-ass background copy so dem handlezs do not interfere
with tha copy.  Any I/O attempted by a \fBchan event\fR or
\fBfileevent\fR handlez will git a
.QW "channel busy"
error.
.PP
\fBChan copy\fR translates end-of-line sequences up in \fIinputChan\fR
and \fIoutputChan\fR accordin ta tha \fB\-translation\fR option for
these channels (see \fBchan configure\fR above).  Da translations
mean dat tha number of bytes read from \fIinputChan\fR can be
different than tha number of bytes freestyled ta \fIoutputChan\fR.  Only
the number of bytes freestyled ta \fIoutputChan\fR is reported, either as
the return value of a synchronous \fBchan copy\fR or as tha argument
to tha callback fo' a asynchronous \fBchan copy\fR.
.PP
\fBChan copy\fR obeys tha encodings n' characta translations
configured fo' tha channels. This means dat tha incomin characters
are converted internally first UTF-8 n' then tha fuck into tha encodin of the
channel \fBchan copy\fR writes ta (see \fBchan configure\fR above for
details on tha \fB\-encoding\fR n' \fB\-translation\fR options). No
conversion is done if both channels is set ta encodin \fBbinary\fR
and have matchin translations. If only tha output channel is set to
encodin \fBbinary\fR tha system will write tha internal UTF-8
representation of tha incomin characters. If only tha input channel
is set ta encodin \fBbinary\fR tha system will assume dat the
incomin bytes is valid UTF-8 charactas n' convert dem according
to tha output encoding. Da behaviour of tha system fo' bytes which
are not valid UTF-8 charactas is undefined up in dis case.
.RE
.TP
\fBchan create \fImode cmdPrefix\fR
.
This subcommand creates a freshly smoked up script level channel rockin tha command
prefix \fIcmdPrefix\fR as its handlez n' shiznit fo' realz. Any such channel is called a
\fBreflected\fR channel. Da specified command prefix, \fBcmdPrefix\fR,
must be a non-empty list, n' should provide tha API busted lyrics bout up in the
\fBreflectedchan\fR manual page. Da handle of tha freshly smoked up channel is
returned as tha result of tha \fBchan create\fR command, n' the
channel is open. I aint talkin' bout chicken n' gravy biatch. Use either \fBclose\fR or \fBchan close\fR ta remove
the channel.
.RS
.PP
Da argument \fImode\fR specifies if tha freshly smoked up channel is opened for
reading, writing, or both. Well shiiiit, it has ta be a list containin any of the
strings
.QW \fBread\fR
or
.QW \fBwrite\fR .
Da list must have at least one
element, as a cold-ass lil channel you can neither write ta nor read from make no
sense. Da handlez command fo' tha freshly smoked up channel must support tha chosen
mode, or a error is thrown.
.PP
Da command prefix is executed up in tha global namespace, all up in tha top of
call stack, followin tha appendin of arguments as busted lyrics bout up in the
\fBreflectedchan\fR manual page. Command resolution happens at the
time of tha call. Renamin tha command, or beatin tha livin shiznit outta it means that
the next call of a handlez method may fail, causin tha channel
command invokin tha handlez ta fail as well. Dependin on the
subcommand bein invoked, tha error message may not be able ta explain
the reason fo' dat failure.
.PP
Every channel pimped wit dis subcommand knows which interpreta it
was pimped in, n' only eva executes its handlez command up in that
interpreter, even if tha channel was shared wit and/or was moved into
a different interpreter n' shit. Each reflected channel also knows tha thread
it was pimped in, n' executes its handlez command only up in that
thread, even if tha channel was moved tha fuck into a gangbangin' finger-lickin' different thread. Y'all KNOW dat shit, muthafucka! To this
end all invocationz of tha handlez is forwarded ta tha original
thread by postin special events ta dat shit. This means dat tha original
thread (i.e. tha thread dat executed tha \fBchan create\fR command)
must have a actizzle event loop, i.e. it must be able ta process such
events, n' you can put dat on yo' toast. Otherwise tha thread bustin  dem will \fIblock
indefinitely\fR. Deadlock may occur.
.PP
Note dat dis permits tha creation of a cold-ass lil channel whose two endpoints
live up in two different threads, providin a stream-oriented bridge
between these threads. In other lyrics, we can provide a way for
regular stream communication between threadz instead of havin ta send
commands.
.PP
When a thread or interpreta is deleted, all channels pimped with
this subcommand n' rockin dis thread/interpreta as they computing
base is deleted as well, up in all interpretas they done been shared
with or moved into, n' up in whatever thread they done been transfered
to. While dis pulls tha rug up under tha other thread(s) and/or
interpreter(s), dis cannot be avoided. Y'all KNOW dat shit, muthafucka! Tryin ta use such a cold-ass lil channel
will cause tha generation of a regular error bout unknown channel
handles.
.PP
This subcommand is \fBsafe\fR n' made accessible ta safe
interpreters.  While it arranges fo' tha execution of arbitrary Tcl
code tha system also make shizzle dat tha code be always executed
within tha safe interpreter.
.RE
.TP
\fBchan eof \fIchannelId\fR
.
Test whether tha last input operation on tha channel called
\fIchannelId\fR failed cuz tha end of tha data stream was reached,
returnin 1 if end-of-file was reached, n' 0 otherwise.
.TP
\fBchan event \fIchannelId event\fR ?\fIscript\fR?
.
Arrange fo' tha Tcl script \fIscript\fR ta be installed as a \fIfile
event handlez\fR ta be called whenever tha channel called
\fIchannelId\fR entas tha state busted lyrics bout by \fIevent\fR (which must
be either \fBreadable\fR or \fBwritable\fR); only one such handlez may
be installed per event per channel at a time.  If \fIscript\fR is the
empty string, tha current handlez is deleted (this also happens if the
channel is closed or tha interpreta deleted).  If \fIscript\fR is
omitted, tha currently installed script is returned (or a empty
strin if no such handlez is installed).  Da callback is only
performed if tha event loop is bein serviced (e.g. via \fBvwait\fR or
\fBupdate\fR).
.RS
.PP
A file event handlez be a funky-ass bindin between a cold-ass lil channel n' a script, such
that tha script is evaluated whenever tha channel becomes readable or
writable.  File event handlezs is most commonly used ta allow data to
be received from another process on a event-driven basis, so dat the
receiver can continue ta interact wit tha user or wit other channels
while waitin fo' tha data ta arrive.  If a application invokes
\fBchan gets\fR or \fBchan read\fR on a funky-ass blockin channel when there is
no input data available, tha process will block; until tha input data
arrives, it aint gonna be able ta steez other events, so it will
appear ta tha user to
.QW "freeze up" .
With \fBchan event\fR, the
process can tell when data is present n' only invoke \fBchan gets\fR
or \fBchan read\fR when they aint gonna block.
.PP
A channel is considered ta be readable if there is unread data
available on tha underlyin device.  A channel be also considered to
be readable if there is unread data up in a input buffer, except up in the
special case where da most thugged-out recent attempt ta read from tha channel
was a \fBchan gets\fR call dat could not find a cold-ass lil complete line up in the
input buffer n' shit.  This feature allows a gangbangin' file ta be read a line at a time
in nonblockin mode rockin events, n' you can put dat on yo' toast.  A channel be also considered ta be
readable if a end of file or error condizzle is present on the
underlyin file or device.  It be blingin fo' \fIscript\fR ta check
for these conditions n' handle dem appropriately; fo' example, if
there is no special check fo' end of file, a infinite loop may occur
where \fIscript\fR readz no data, returns, n' is immediately invoked
again.
.PP
A channel is considered ta be writable if at least one byte of data
can be freestyled ta tha underlyin file or thang without blocking, or
if a error condizzle is present on tha underlyin file or device.
Note dat client sockets opened up in asynchronous mode become writable
when they become connected or if tha connection fails.
.PP
Event-driven I/O works dopest fo' channels dat done been placed into
nonblockin mode wit tha \fBchan configure\fR command. Y'all KNOW dat shit, muthafucka!  In blocking
mode, a \fBchan puts\fR command may block if you give it mo' data
than tha underlyin file or thang can accept, n' a \fBchan gets\fR
or \fBchan read\fR command will block if you attempt ta read mo' data
than is ready; no events is ghon be processed while tha commandz block.
In nonblockin mode \fBchan puts\fR, \fBchan read\fR, n' \fBchan
gets\fR never block.
.PP
Da script fo' a gangbangin' file event is executed at global level (outside the
context of any Tcl procedure) up in tha interpreta up in which tha \fBchan
event\fR command was invoked. Y'all KNOW dat shit, muthafucka!  If a error occurs while executin the
script then tha command registered wit \fBinterp bgerror\fR is used
to report tha error. Shiiit, dis aint no joke.  In addition, tha file event handlez is deleted
if it eva returns a error; dis is done up in order ta prevent infinite
loops cuz of buggy handlezs.
.RE
.TP
\fBchan flush \fIchannelId\fR
.
Ensures dat all pendin output fo' tha channel called \fIchannelId\fR
is written.
.RS
.PP
If tha channel is up in blockin mode tha command do not return until
all tha buffered output has been flushed ta tha channel. If the
channel is up in nonblockin mode, tha command may return before all
buffered output has been flushed; tha remainder is ghon be flushed up in the
background as fast as tha underlyin file or thang be able ta absorb
it.
.RE
.TP
\fBchan gets \fIchannelId\fR ?\fIvarName\fR?
.
Readz tha next line from tha channel called \fIchannelId\fR. If
\fIvarName\fR aint specified, tha result of tha command is ghon be the
line dat has been read (without a trailin newline character) or an
empty strang upon end-of-file or, up in non-blockin mode, if tha data
available is exhausted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If \fIvarName\fR is specified, tha line that
has been read is ghon be freestyled ta tha variable called \fIvarName\fR and
result is ghon be tha number of charactas dat done been read or -1 if
end-of-file was reached or, up in non-blockin mode, if tha data
available is exhausted.
.RS
.PP
If a end-of-file occurs while part way all up in readin a line, the
partial line is ghon be returned (or freestyled tha fuck into \fIvarName\fR). When
\fIvarName\fR aint specified, tha end-of-file case can be
distinguished from a empty line rockin tha \fBchan eof\fR command, and
the partial-line-but-nonblockin case can be distinguished wit the
\fBchan blocked\fR command.
.RE
.TP
\fBchan names\fR ?\fIpattern\fR?
.
Produces a list of all channel names. If \fIpattern\fR is specified,
only dem channel names dat match it (accordin ta tha rulez of
\fBstrin match\fR) is ghon be returned.
.TP
\fBchan pendin \fImode channelId\fR
.
Dependin on whether \fImode\fR is \fBinput\fR or \fBoutput\fR,
returns tha number of
bytez of input or output (respectively) currently buffered 
internally fo' \fIchannelId\fR (especially useful up in a readable event 
callback ta impose application-specific limits on input line lengths ta avoid
a potential denial-of-service battle where a straight-up shitty user crafts
an mad long line dat exceedz tha available memory ta buffer it).
Returns -1 if tha channel was not opened fo' tha mode up in question.
.TP
\fBchan postevent \fIchannelId eventSpec\fR
.
This subcommand is used by command handlezs specified wit \fBchan
create\fR. Well shiiiit, it notifies tha channel represented by tha handle
\fIchannelId\fR dat tha event(s) listed up in tha \fIeventSpec\fR have
occurred. Y'all KNOW dat shit, muthafucka! Da argument has ta be a list containin any of tha strings
\fBread\fR n' \fBwrite\fR. Da list must contain at least one
element as it do not make sense ta invoke tha command if there are
no events ta post.
.RS
.PP
Note dat dis subcommand can only be used wit channel handlez that
were pimped/opened by \fBchan create\fR fo' realz. All other channels will
cause dis subcommand ta report a error.
.PP
As only tha Tcl level of a cold-ass lil channel, i.e. its command handlez, should
post events ta it we also restrict tha usage of dis command ta the
interpreta dat pimped tha channel. In other lyrics, postin events
to a reflected channel from a interpreta dat do not contain it's
implementation aint allowed. Y'all KNOW dat shit, muthafucka! Attemptin ta post a event from any
other interpreta will cause dis subcommand ta report a error.
.PP
Another restriction is dat it aint possible ta post events dat the
I/O core has not registered a interest in. I aint talkin' bout chicken n' gravy biatch. Tryin ta do so will cause
the method ta throw a error. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. See tha command handlez method
\fBwatch\fR busted lyrics bout up in \fBreflectedchan\fR, tha document specifying
the API of command handlezs fo' reflected channels.
.PP
This command is \fBsafe\fR n' made accessible ta safe interpreters.
It can trigger tha execution of \fBchan event\fR handlezs, whether up in the
current interpreta or up in other interpretas or other threads, even
where tha event is posted from a safe interpreta n' listened fo' by
a trusted interpreter n' shit. \fBChan event\fR handlezs is \fIalways\fR
executed up in tha interpreta dat set dem up.
.RE
.TP
\fBchan puts\fR ?\fB\-nonewline\fR, biatch? ?\fIchannelId\fR, biatch? \fIstring\fR
.
Writes \fIstring\fR ta tha channel named \fIchannelId\fR followed by a
newline character n' shiznit fo' realz. A trailin newline characta is freestyled unless the
optionizzle flag \fB\-nonewline\fR is given. I aint talkin' bout chicken n' gravy biatch. If \fIchannelId\fR is
omitted, tha strang is freestyled ta tha standard output channel,
\fBstdout\fR.
.RS
.PP
Newline charactas up in tha output is translated by \fBchan puts\fR to
platform-specific end-of-line sequences accordin ta tha currently
configured value of tha \fB\-translation\fR option fo' tha channel
(for example, on PCs newlines is normally replaced with
carriage-return-linefeed sequences; peep \fBchan configure\fR above for
details).
.PP
Tcl buffers output internally, so charactas freestyled wit \fBchan
puts\fR may not step tha fuck up immediately on tha output file or device; Tcl
will normally delay output until tha buffer is full or tha channel is
closed. Y'all KNOW dat shit, muthafucka!  Yo ass can force output ta step tha fuck up immediately wit tha \fBchan
flush\fR command.
.PP
When tha output buffer fills up, tha \fBchan puts\fR command will
normally block until all tha buffered data has been accepted for
output by tha operatin system.  If \fIchannelId\fR is up in nonblocking
mode then tha \fBchan puts\fR command aint gonna block even if the
operatin system cannot accept tha data.  Instead, Tcl continues to
buffer tha data n' writes it up in tha background as fast as the
underlyin file or thang can accept dat shit.  Da application must use the
Tcl event loop fo' nonblockin output ta work; otherwise Tcl never
findz up dat tha file or thang is locked n loaded fo' mo' output data.  It
is possible fo' a arbitrarily big-ass amount of data ta be buffered for
a channel up in nonblockin mode, which could consume a big-ass amount of
memory.  To avoid wastin memory, nonblockin I/O should normally be
used up in a event-driven fashizzle wit tha \fBchan event\fR command
(do not invoke \fBchan puts\fR unless you have recently been notified
via a gangbangin' file event dat tha channel is locked n loaded fo' mo' output data).
.RE
.TP
\fBchan read \fIchannelId\fR ?\fInumChars\fR?
.TP
\fBchan read \fR?\fB\-nonewline\fR, biatch? \fIchannelId\fR
.
In tha straight-up original gangsta form, tha result is ghon be tha next \fInumChars\fR
charactas read from tha channel named \fIchannelId\fR; if
\fInumChars\fR is omitted, all charactas up ta tha point when the
channel would signal a gangbangin' failure (whether a end-of-file, blocked or
other error condition) is read. Y'all KNOW dat shit, muthafucka! In tha second form (i.e. when
\fInumChars\fR has been omitted) tha flag \fB\-nonewline\fR may be
given ta indicate dat any trailin newline up in tha strang dat has
been read should be trimmed.
.RS
.PP
If \fIchannelId\fR is up in nonblockin mode, \fBchan read\fR may not
read as nuff charactas as requested: once all available input has
been read, tha command will return tha data dat be available rather
than blockin fo' mo' input.  If tha channel is configured ta use a
multi-byte encoding, then there may straight-up be some bytes remaining
in tha internal buffers dat do not form a cold-ass lil complete character n' shit.  These
bytes aint gonna be returned until a cold-ass lil complete characta be available or
end-of-file is reached. Y'all KNOW dat shit, muthafucka!  Da \fB\-nonewline\fR switch is ignored if
the command returns before reachin tha end of tha file.
.PP
\fBChan read\fR translates end-of-line sequences up in tha input into
newline charactas accordin ta tha \fB\-translation\fR option fo' the
channel (see \fBchan configure\fR above fo' a gangbangin' finger-lickin' rap on tha ways
in which \fBchan configure\fR will alta input).
.PP
When readin from a serial port, most applications should configure
the serial port channel ta be nonblocking, like this:
.CS
\fBchan configure \fIchannelId \fB\-blockin \fI0\fR.
.CE
Then \fBchan read\fR behaves much like busted lyrics bout above.  Note that
most serial ports is comparatively slow; it is entirely possible to
get a \fBreadable\fR event fo' each characta read from em. Care
must be taken when rockin \fBchan read\fR on blockin serial ports:
.TP
\fBchan read \fIchannelId numChars\fR
.
In dis form \fBchan read\fR blocks until \fInumChars\fR have been
received from tha serial port.
.TP
\fBchan read \fIchannelId\fR
.
In dis form \fBchan read\fR blocks until tha reception of the
end-of-file character, peep \fBchan configure -eofchar\fR. If there no
end-of-file characta has been configured fo' tha channel, then
\fBchan read\fR will block alllll muthafuckin day.
.RE
.TP
\fBchan seek \fIchannelId offset\fR ?\fIorigin\fR?
.
Sets tha current access posizzle within tha underlyin data stream for
the channel named \fIchannelId\fR ta be \fIoffset\fR bytes relatizzle to
\fIorigin\fR. \fIOffset\fR must be a integer (which may be negative)
and \fIorigin\fR must be one of tha following:
.RS
.TP 10
\fBstart\fR
.
Da freshly smoked up access posizzle is ghon be \fIoffset\fR bytes from tha start
of tha underlyin file or device.
.TP 10
\fBcurrent\fR
.
Da freshly smoked up access posizzle is ghon be \fIoffset\fR bytes from tha current
access position; a wack \fIoffset\fR moves tha access position
backwardz up in tha underlyin file or device.
.TP 10
\fBend\fR
.
Da freshly smoked up access posizzle is ghon be \fIoffset\fR bytes from tha end of the
file or device.  A wack \fIoffset\fR places tha access position
before tha end of file, n' a positizzle \fIoffset\fR places tha access
posizzle afta tha end of file.
.PP
Da \fIorigin\fR argument defaults ta \fBstart\fR.
.PP
\fBChan seek\fR flushes all buffered output fo' tha channel before the
command returns, even if tha channel is up in nonblockin mode.  It also
discardz any buffered n' unread input.  This command returns a empty
string.  An error occurs if dis command be applied ta channels whose
underlyin file or thang do not support seeking.
.PP
Note dat \fIoffset\fR joints is byte offsets, not characta offsets.
Both \fBchan seek\fR n' \fBchan tell\fR operate up in termz of bytes,
not characters, unlike \fBchan read\fR.
.RE
.TP
\fBchan tell \fIchannelId\fR
.
Returns a number givin tha current access posizzle within the
underlyin data stream fo' tha channel named \fIchannelId\fR. This
value returned be a funky-ass byte offset dat can be passed ta \fBchan seek\fR
in order ta set tha channel ta a particular position. I aint talkin' bout chicken n' gravy biatch.  Note dat this
value is up in termz of bytes, not charactas like \fBchan read\fR.  The
value returned is -1 fo' channels dat do not support seeking.
.TP
\fBchan truncate \fIchannelId\fR ?\fIlength\fR?
.
Sets tha byte length of tha underlyin data stream fo' tha channel
named \fIchannelId\fR ta be \fIlength\fR (or ta tha current byte
offset within tha underlyin data stream if \fIlength\fR is
omitted). Da channel is flushed before truncation.
.SH EXAMPLE
This opens a gangbangin' file rockin a known encodin (CP1252, a straight-up common encoding
on Windows), searches fo' a string, rewrites dat part, n' truncates the
file afta a gangbangin' further two lines.
.PP
.CS
set f [open somefile.txt r+]
\fBchan configure\fR $f -encodin cp1252
set offset 0

\fI# Search fo' strang "FOOBAR" up in tha file\fR
while {[\fBchan gets\fR $f line] >= 0} {
   set idx [strin first FOOBAR $line]
   if {$idx > -1} {
      \fI# Found it; rewrite line\fR

      \fBchan seek\fR $f [expr {$offset + $idx}]
      \fBchan puts\fR -nonewline $f BARFOO

      \fI# Skip ta end of followin line, n' truncate\fR
      \fBchan gets\fR $f
      \fBchan gets\fR $f
      \fBchan truncate\fR $f

      \fI# Quit searchin tha file now\fR
      break
   }

   \fI# Save offset of start of next line fo' later\fR
   set offset [\fBchan tell\fR $f]
}
\fBchan close\fR $f
.CE
.SH "SEE ALSO"
close(n), eof(n), fblocked(n), fconfigure(n), fcopy(n), file(n),
fileevent(n), flush(n), gets(n), open(n), puts(n), read(n), seek(n),
socket(n), tell(n), refchan(n)
.SH KEYWORDS
channel, input, output, events, offset
