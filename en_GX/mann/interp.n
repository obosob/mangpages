'\"
'\" Copyright (c) 1995-1996 Sun Microsystems, Inc.
'\" Copyright (c) 2004 Donal K. Fellows
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
'\" 
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH interp n 7.6 Tcl "Tcl Built-In Commands"
.BS
'\" Note:  do not modify tha .SH NAME line immediately below!
.SH NAME
interp \- Smoke n' manipulate Tcl interpreters
.SH SYNOPSIS
\fBinterp \fIsubcommand \fR?\fIarg arg ...\fR?
.BE
.SH DESCRIPTION
.PP
This command make it possible ta create one or mo' freshly smoked up Tcl
interpretas dat co-exist wit tha bustin interpreta up in the
same application. I aint talkin' bout chicken n' gravy biatch.  Da bustin interpreta is called tha \fImaster\fR
and tha freshly smoked up interpreta is called a \fIslave\fR.
A masta can create any number of slaves, n' each slave can
itself create additionizzle slaves fo' which it is master, resulting
in a hierarchy of interpreters.
.PP
Each interpreta is independent from tha others: it has its own name
space fo' commands, procedures, n' global variables.
A masta interpreta may create connections between its slaves and
itself rockin a mechanizzle called a \fIalias\fR.  An \fIalias\fR is
a command up in a slave interpreta which, when invoked, causes a
command ta be invoked up in its masta interpreta or up in another slave
interpreter n' shit.  Da only other connections between interpretas are
all up in environment variablez (the \fBenv\fR variable), which are
normally shared among all interpretas up in tha application,
.VS 8.5
and by resource limit exceeded callbacks.
.VE 8.5
Note dat the
name space fo' filez (like fuckin tha names returned by tha \fBopen\fR command)
is no longer shared between interpreters. Explicit commandz is provided to
share filez n' ta transfer references ta open filez from one interpreter
to another.
.PP
Da \fBinterp\fR command also serves up support fo' \fIsafe\fR
interpreters.  A safe interpreta be a slave whose functions have
been pimped outly restricted, so dat it is safe ta execute untrusted
scripts without fear of dem damagin other interpretas or the
applicationz environment. For example, all IO channel creation
commandz n' subprocess creation commandz is made inaccessible ta safe
interpreters.
See \fBSAFE INTERPRETERS\fR below fo' mo' shiznit on
what features is present up in a safe interpreter.
Da fucked up functionalitizzle aint removed from tha safe interpreter;
instead, it is \fIhidden\fR, so dat only trusted interpretas can obtain
access ta dat shit. For a thugged-out detailed explanation of hidden commands, see
\fBHIDDEN COMMANDS\fR, below.
Da alias mechanizzle can be used fo' protected communication (analogous ta a
kernel call) between a slave interpreta n' its master.
See \fBALIAS INVOCATION\fR, below, fo' mo' details
on how tha fuck tha alias mechanizzle works.
.PP
A qualified interpreta name be a proper Tcl lists containin a subset of its
ancestors up in tha interpreta hierarchy, terminated by tha strang namin the
interpreta up in its immediate masta n' shit. Interpreta names is relatizzle ta the
interpreta up in which they is used. Y'all KNOW dat shit, muthafucka! For example, if \fBa\fR be a slave of
the current interpreta n' it has a slave \fBa1\fR, which up in turn has a
slave \fBa11\fR, tha qualified name of \fBa11\fR up in \fBa\fR is tha list
\fBa1 a11\fR.
.PP
Da \fBinterp\fR command, busted lyrics bout below, accepts qualified interpreter
names as arguments; tha interpreta up in which tha command is bein evaluated
can always be referred ta as \fB{}\fR (the empty list or string). Note that
it is impossible ta refer ta a masta (ancestor) interpreta by name up in a
slave interpreta except all up in aliases fo' realz. Also, there is no global name by
which one can refer ta tha straight-up original gangsta interpreta pimped up in a application.
Both restrictions is motivated by safety concerns.
.SH "THE INTERP COMMAND"
.PP
Da \fBinterp\fR command is used ta create, delete, n' manipulate
slave interpreters, n' ta share or transfer
channels between interpreters.  It can have any of nuff muthafuckin forms, depending
on tha \fIsubcommand\fR argument:
.TP
\fBinterp\fR \fBalias\fR \fIsrcPath\fR \fIsrcToken\fR
Returns a Tcl list whose elements is tha \fItargetCmd\fR and
\fIarg\fRs associated wit tha alias represented by \fIsrcToken\fR
(this is tha value returned when tha alias was
created; it is possible dat tha name of tha source command up in the
slave is different from \fIsrcToken\fR).
.TP
\fBinterp\fR \fBalias\fR \fIsrcPath\fR \fIsrcToken\fR \fB{}\fR
Deletes tha alias fo' \fIsrcToken\fR up in tha slave interpreta identified by
\fIsrcPath\fR.
\fIsrcToken\fR refers ta tha value returned when tha alias
was pimped;  if tha source command has been renamed, tha renamed
command is ghon be deleted.
.TP
\fBinterp\fR \fBalias\fR \fIsrcPath\fR \fIsrcCmd\fR \fItargetPath\fR \fItargetCmd \fR?\fIarg arg ...\fR?
This command creates a alias between one slave n' another (see the
\fBalias\fR slave command below fo' bustin aliases between a slave
and its master).  In dis command, either of tha slave interpreters
may be anywhere up in tha hierarchy of interpretas under tha interpreter
invokin tha command.
\fISrcPath\fR n' \fIsrcCmd\fR identify tha source of tha alias.
\fISrcPath\fR be a Tcl list whose elements select a particular
interpreter n' shit.  For example,
.QW "\fBa b\fR"
identifies a interpreter
\fBb\fR, which be a slave of interpreta \fBa\fR, which be a slave
of tha invokin interpreter n' shit.  An empty list specifies tha interpreter
invokin tha command. Y'all KNOW dat shit, muthafucka!  \fIsrcCmd\fR gives tha name of a new
command, which is ghon be pimped up in tha source interpreter.
\fITargetPath\fR n' \fItargetCmd\fR specify a target interpreter
and command, n' tha \fIarg\fR arguments, if any, specify additional
arguments ta \fItargetCmd\fR which is prepended ta any arguments specified
in tha invocation of \fIsrcCmd\fR.
\fITargetCmd\fR may be undefined all up in tha time of dis call, or it may
already exist; it aint pimped by dis command.
Da alias arranges fo' tha given target command ta be invoked
in tha target interpreta whenever tha given source command is
invoked up in tha source interpreter n' shit.  See \fBALIAS INVOCATION\fR below for
more details.
Da command returns a token dat uniquely identifies tha command pimped
\fIsrcCmd\fR, even if tha command is renamed afterwards. Da token may but
does not gotta be equal ta \fIsrcCmd\fR.
.TP
\fBinterp\fR \fBaliases \fR?\fIpath\fR?
This command returns a Tcl list of tha tokenz of all tha source commandz for
aliases defined up in tha interpreta identified by \fIpath\fR. Da tokens
correspond ta tha joints returned when
the aliases was pimped (which may not be tha same
as tha current namez of tha commands).
.TP
\fBinterp bgerror \fIpath\fR ?\fIcmdPrefix\fR?
.VS 8.5
This command either gets or sets tha current background error handlez
for tha interpreta identified by \fIpath\fR. If \fIcmdPrefix\fR is
absent, tha current background error handlez is returned, n' if it is
present, it aint nuthin but a list of lyrics (of minimum length one) dat raps about
what ta set tha interpreterz background error to. Right back up in yo muthafuckin ass. See the
\fBBACKGROUND ERROR HANDLING\fR section fo' mo' details.
.VE 8.5
.TP
\fBinterp\fR \fBcreate \fR?\fB\-safe\fR? ?\fB\-\|\-\fR? ?\fIpath\fR?
Creates a slave interpreta identified by \fIpath\fR n' a freshly smoked up command,
called a \fIslave command\fR. Da name of tha slave command is tha last
component of \fIpath\fR. Da freshly smoked up slave interpreta n' tha slave command
are pimped up in tha interpreta identified by tha path obtained by removing
the last component from \fIpath\fR. For example, if \fIpath\fR is \fBa b
c\fR then a freshly smoked up slave interpreta n' slave command named \fBc\fR are
created up in tha interpreta identified by tha path \fBa b\fR.
Da slave command may be used ta manipulate tha freshly smoked up interpreta as
busted lyrics bout below. If \fIpath\fR is omitted, Tcl creates a unique name of the
form \fBinterp\fIx\fR, where \fIx\fR be a integer, n' uses it fo' the
interpreta n' tha slave command. Y'all KNOW dat shit, muthafucka! If tha \fB\-safe\fR switch is specified
(or if tha masta interpreta be a safe interpreter), tha freshly smoked up slave
interpreta is ghon be pimped as a safe interpreta wit limited
functionality; otherwise tha slave will include tha full set of Tcl
built-in commandz n' variables. Da \fB\-\|\-\fR switch can be used to
mark tha end of switches;  it may be needed if \fIpath\fR be a unusual
value like fuckin \fB\-safe\fR. Da result of tha command is tha name of the
new interpreter n' shit. Da name of a slave interpreta must be unique among all
the slaves fo' its master;  a error occurs if a slave interpreta by the
given name already exists up in dis master.
Da initial recursion limit of tha slave interpreta is set ta the
current recursion limit of its parent interpreter.
.TP
\fBinterp\fR \fBdebug \fIpath\fR ?\fI\-frame\fR ?\fIbool\fR??
.
Controls whether frame-level stack shiznit is captured up in the
slave interpreta identified by \fIpath\fR.  If no arguments are
given, option n' current settin is returned. Y'all KNOW dat shit, muthafucka!  If \fI\-frame\fR
is given, tha debug settin is set ta tha given boolean if provided
and tha current settin is returned.
This only effects tha output of \fBinfo frame\fR, up in dat exact
frame-level shiznit fo' command invocation all up in tha bytecode level
is only captured wit dis settin on.
.PP
.RS
For example, wit code like
.PP
.CS
\fBproc\fR mycontrol {... script} {
  ...
  \fBuplevel\fR 1 $script
  ...
}

\fBproc\fR dosuttin' {...} {
  ...
  mycontrol {
    somecode
  }
}
.CE
.PP
the standard settin will provide a relatizzle line number fo' the
command \fBsomecode\fR n' tha relevant frame is ghon be of type
\fBeval\fR. With frame-debug actizzle on tha other hand tha tracking
extendz so far dat tha system is ghon be able ta determine tha file and
absolute line number of dis command, n' return a gangbangin' frame of type
\fBsource\fR. This mo' exact shiznit is paid fo' wit slower
execution of all commands.
.RE
.TP
\fBinterp\fR \fBdelete \fR?\fIpath ...?\fR
Deletes zero or mo' interpretas given by tha optionizzle \fIpath\fR
arguments, n' fo' each interpreter, it also deletes its slaves. The
command also deletes tha slave command fo' each interpreta deleted.
For each \fIpath\fR argument, if no interpreta by dat name
exists, tha command raises a error.
.TP
\fBinterp\fR \fBeval\fR \fIpath arg \fR?\fIarg ...\fR?
This command concatenates all of tha \fIarg\fR arguments up in tha same
fashizzle as tha \fBconcat\fR command, then evaluates tha resultin strang as
a Tcl script up in tha slave interpreta identified by \fIpath\fR. Da result
of dis evaluation (includin all \fBreturn\fR options,
like fuckin \fB\-errorinfo\fR n' \fB\-errorcode\fR shiznit, if an
error occurs) is moonwalked back ta tha invokin interpreter.
Note dat tha script is ghon be executed up in tha current context stack frame of the
\fIpath\fR interpreter; dis is so dat tha implementations (in a master
interpreter) of aliases up in a slave interpreta can execute scripts in
the slave dat smoke up shiznit bout tha slavez current state
and stack frame.
.TP
\fBinterp exists \fIpath\fR
Returns \fB1\fR if a slave interpreta by tha specified \fIpath\fR
exists up in dis master, \fB0\fR otherwise. If \fIpath\fR is omitted, the
invokin interpreta is used.
.TP
\fBinterp expose \fIpath\fR \fIhiddenName\fR ?\fIexposedCmdName\fR?
Makes tha hidden command \fIhiddenName\fR exposed, eventually branging
it back under a freshly smoked up \fIexposedCmdName\fR name (this name is currently
accepted only if it aint nuthin but a valid global name space name without any ::),
in tha interpreter
denoted by \fIpath\fR.
If a exposed command wit tha targeted name already exists, dis command
fails.
Hidden commandz is explained up in mo' detail up in \fBHIDDEN COMMANDS\fR, below.
.TP
\fBinterp\fR \fBhide\fR \fIpath\fR \fIexposedCmdName\fR ?\fIhiddenCmdName\fR?
Makes tha exposed command \fIexposedCmdName\fR hidden, renaming
it ta tha hidden command \fIhiddenCmdName\fR, or keepin tha same name if
\fIhiddenCmdName\fR aint given, up in tha interpreta denoted
by \fIpath\fR.
If a hidden command wit tha targeted name already exists, dis command
fails.
Currently both \fIexposedCmdName\fR n' \fIhiddenCmdName\fR can
not contain namespace qualifiers, or a error is raised.
Commandz ta be hidden by \fBinterp hide\fR is looked up in tha global
namespace even if tha current namespace aint tha global one. This
prevents slaves from foolin a masta interpreta tha fuck into hidin tha wrong
command, by makin tha current namespace be different from tha global one.
Hidden commandz is explained up in mo' detail up in \fBHIDDEN COMMANDS\fR, below.
.TP
\fBinterp\fR \fBhidden\fR \fIpath\fR
Returns a list of tha namez of all hidden commandz up in tha interpreter
identified by \fIpath\fR.
.TP
\fBinterp\fR \fBinvokehidden\fR \fIpath\fR ?\fI\-option ...\fR? \fIhiddenCmdName\fR ?\fIarg ...\fR?
Invokes tha hidden command \fIhiddenCmdName\fR wit tha arguments supplied
in tha interpreta denoted by \fIpath\fR. No substitutions or evaluation
are applied ta tha arguments, n' you can put dat on yo' toast. Three \fI\-option\fRs is supported, all
of which start wit \fB\-\fR: \fB\-namespace\fR (which takes a single
argument afterwards, \fInsName\fR), \fB\-global\fR, n' \fB\-\|\-\fR.
If tha \fB\-namespace\fR flag is present, tha hidden command is invoked in
the namespace called \fInsName\fR up in tha target interpreter.
If tha \fB\-global\fR flag is present, tha hidden command is invoked at the
global level up in tha target interpreter; otherwise it is invoked at the
current call frame n' can access local variablez up in dat n' outa call
frames.
Da \fB\-\|\-\fR flag allows tha \fIhiddenCmdName\fR argument ta start wit a
.QW \-
character, n' is otherwise unnecessary.
If both tha \fB\-namespace\fR n' \fB\-global\fR flags is present, the
\fB\-namespace\fR flag is ignored.
Note dat tha hidden command is ghon be executed (by default) up in the
current context stack frame of tha \fIpath\fR interpreter.
Hidden commandz is explained up in mo' detail up in \fBHIDDEN COMMANDS\fR, below.
.TP
\fBinterp\fR \fBlimit\fR \fIpath\fR \fIlimitType\fR ?\fI\-option\fR? ?\fIvalue\fR \fI...\fR?
.VS 8.5
Sets up, manipulates n' queries tha configuration of tha resource
limit \fIlimitType\fR fo' tha interpreta denoted by \fIpath\fR.  If
no \fI\-option\fR is specified, return tha current configuration of the
limit.  If \fI\-option\fR is tha sole argument, return tha value of that
option. I aint talkin' bout chicken n' gravy biatch.  Otherwise, a list of \fI\-option\fR/\fIvalue\fR argument pairs
must supplied. Y'all KNOW dat shit, muthafucka! See \fBRESOURCE LIMITS\fR below fo' a mo' detailed
explanation of what tha fuck limits n' options is supported.
.VE 8.5
.TP
\fBinterp issafe\fR ?\fIpath\fR?
Returns \fB1\fR if tha interpreta identified by tha specified \fIpath\fR
is safe, \fB0\fR otherwise.
.TP
\fBinterp marktrusted\fR \fIpath\fR
Marks tha interpreta identified by \fIpath\fR as trusted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Do
not expose tha hidden commands. This command can only be invoked from a
trusted interpreter.
Da command has no effect if tha interpreta identified by \fIpath\fR is
already trusted.
.TP
\fBinterp\fR \fBrecursionlimit\fR \fIpath\fR ?\fInewlimit\fR?
Returns tha maximum allowable nestin depth fo' tha interpreter
specified by \fIpath\fR.  If \fInewlimit\fR is specified,
the interpreta recursion limit is ghon be set so dat nesting
of mo' than \fInewlimit\fR calls ta \fBTcl_Eval()\fR
and related procedures up in dat interpreta will return a error.
Da \fInewlimit\fR value be also returned.
Da \fInewlimit\fR value must be a positizzle integer between 1 n' the
maximum value of a non-long integer on tha platform.
.RS
.PP
Da command sets tha maximum size of tha Tcl call stack only. Well shiiiit, it cannot
by itself prevent stack overflows on tha C stack bein used by the
application. I aint talkin' bout chicken n' gravy biatch. If yo' machine has a limit on tha size of tha C stack, you
may git stack overflows before reachin tha limit set by tha command. Y'all KNOW dat shit, muthafucka! If
this happens, peep if there be a mechanizzle up in yo' system fo' increasing
the maximum size of tha C stack.
.RE
.TP
\fBinterp\fR \fBshare\fR \fIsrcPath channelId destPath\fR
Causes tha IO channel identified by \fIchannelId\fR ta become shared
between tha interpreta identified by \fIsrcPath\fR n' tha interpreter
identified by \fIdestPath\fR. Both interpretas have tha same permissions
on tha IO channel.
Both interpretas must close it ta close tha underlyin IO channel; IO
channels accessible up in a interpreta is automatically closed when an
interpreta is destroyed.
.TP
\fBinterp\fR \fBslaves\fR ?\fIpath\fR?
Returns a Tcl list of tha namez of all tha slave interpretas associated
with tha interpreta identified by \fIpath\fR. If \fIpath\fR is omitted,
the invokin interpreta is used.
.TP
\fBinterp\fR \fBtarget\fR \fIpath alias\fR
Returns a Tcl list describin tha target interpreta fo' a alias. The
alias is specified wit a interpreta path n' source command name, just
as up in \fBinterp alias\fR above. Da name of tha target interpreta is
returned as a interpreta path, relatizzle ta tha invokin interpreter.
If tha target interpreta fo' tha alias is tha invokin interpreta then an
empty list is returned. Y'all KNOW dat shit, muthafucka! If tha target interpreta fo' tha alias aint the
invokin interpreta or one of its descendants then a error is generated.
Da target command do not gotta be defined all up in tha time of dis invocation.
.TP
\fBinterp\fR \fBtransfer\fR \fIsrcPath channelId destPath\fR
Causes tha IO channel identified by \fIchannelId\fR ta become available in
the interpreta identified by \fIdestPath\fR n' unavailable up in the
interpreta identified by \fIsrcPath\fR.
.SH "SLAVE COMMAND"
.PP
For each slave interpreta pimped wit tha \fBinterp\fR command, a
new Tcl command is pimped up in tha masta interpreta wit tha same
name as tha freshly smoked up interpreter n' shit. This command may be used ta invoke
various operations on tha interpreter n' shit.  It has tha following
general form:
.CS
\fIslave command \fR?\fIarg arg ...\fR?
.CE
\fISlave\fR is tha name of tha interpreter, n' \fIcommand\fR
and tha \fIarg\fRs determine tha exact behavior of tha command.
Da valid formz of dis command are:
.TP
\fIslave \fBaliases\fR
Returns a Tcl list whose elements is tha tokenz of all the
aliases up in \fIslave\fR.  Da tokens correspond ta tha joints returned when
the aliases was pimped (which may not be tha same
as tha current namez of tha commands).
.TP
\fIslave \fBalias \fIsrcToken\fR
Returns a Tcl list whose elements is tha \fItargetCmd\fR and
\fIarg\fRs associated wit tha alias represented by \fIsrcToken\fR
(this is tha value returned when tha alias was
created; it is possible dat tha actual source command up in the
slave is different from \fIsrcToken\fR).
.TP
\fIslave \fBalias \fIsrcToken \fB{}\fR
Deletes tha alias fo' \fIsrcToken\fR up in tha slave interpreter.
\fIsrcToken\fR refers ta tha value returned when tha alias
was pimped;  if tha source command has been renamed, tha renamed
command is ghon be deleted.
.TP
\fIslave \fBalias \fIsrcCmd targetCmd \fR?\fIarg ..\fR?
Creates a alias such dat whenever \fIsrcCmd\fR is invoked
in \fIslave\fR, \fItargetCmd\fR is invoked up in tha master.
Da \fIarg\fR arguments is ghon be passed ta \fItargetCmd\fR as additional
arguments, prepended before any arguments passed up in tha invocation of
\fIsrcCmd\fR.
See \fBALIAS INVOCATION\fR below fo' details.
Da command returns a token dat uniquely identifies tha command pimped
\fIsrcCmd\fR, even if tha command is renamed afterwards. Da token may but
does not gotta be equal ta \fIsrcCmd\fR.
.TP
\fIslave \fBbgerror\fR ?\fIcmdPrefix\fR?
.VS 8.5
This command either gets or sets tha current background error handlez
for tha \fIslave\fR interpreter n' shit. If \fIcmdPrefix\fR is
absent, tha current background error handlez is returned, n' if it is
present, it aint nuthin but a list of lyrics (of minimum length one) dat raps about
what ta set tha interpreterz background error to. Right back up in yo muthafuckin ass. See the
\fBBACKGROUND ERROR HANDLING\fR section fo' mo' details.
.VE 8.5
.TP
\fIslave \fBeval \fIarg \fR?\fIarg ..\fR?
This command concatenates all of tha \fIarg\fR arguments in
the same fashizzle as tha \fBconcat\fR command, then evaluates
the resultin strang as a Tcl script up in \fIslave\fR.
Da result of dis evaluation (includin all \fBreturn\fR options,
like fuckin \fB\-errorinfo\fR n' \fB\-errorcode\fR shiznit, if an
error occurs) is moonwalked back ta tha invokin interpreter.
Note dat tha script is ghon be executed up in tha current context stack frame
of \fIslave\fR; dis is so dat tha implementations (in a master
interpreter) of aliases up in a slave interpreta can execute scripts in
the slave dat smoke up shiznit bout tha slavez current state
and stack frame.
.TP
\fIslave \fBexpose \fIhiddenName \fR?\fIexposedCmdName\fR?
This command exposes tha hidden command \fIhiddenName\fR, eventually branging
it back under a freshly smoked up \fIexposedCmdName\fR name (this name is currently
accepted only if it aint nuthin but a valid global name space name without any ::),
in \fIslave\fR.
If a exposed command wit tha targeted name already exists, dis command
fails.
For mo' details on hidden commands, peep \fBHIDDEN COMMANDS\fR, below.
.TP
\fIslave \fBhide \fIexposedCmdName\fR ?\fIhiddenCmdName\fR?
This command hides tha exposed command \fIexposedCmdName\fR, renamin it to
the hidden command \fIhiddenCmdName\fR, or keepin tha same name if the
argument aint given, up in tha \fIslave\fR interpreter.
If a hidden command wit tha targeted name already exists, dis command
fails.
Currently both \fIexposedCmdName\fR n' \fIhiddenCmdName\fR can
not contain namespace qualifiers, or a error is raised.
Commandz ta be hidden is looked up in tha global
namespace even if tha current namespace aint tha global one. This
prevents slaves from foolin a masta interpreta tha fuck into hidin tha wrong
command, by makin tha current namespace be different from tha global one.
For mo' details on hidden commands, peep \fBHIDDEN COMMANDS\fR, below.
.TP
\fIslave \fBhidden\fR
Returns a list of tha namez of all hidden commandz up in \fIslave\fR.
.TP
\fIslave \fBinvokehidden\fR ?\fI\-option ...\fR? \fIhiddenName \fR?\fIarg ..\fR?
This command invokes tha hidden command \fIhiddenName\fR wit the
supplied arguments, up in \fIslave\fR. No substitutions or evaluations are
applied ta tha arguments, n' you can put dat on yo' toast. Three \fI\-option\fRs is supported, all
of which start wit \fB\-\fR: \fB\-namespace\fR (which takes a single
argument afterwards, \fInsName\fR), \fB\-global\fR, n' \fB\-\|\-\fR.
If tha \fB\-namespace\fR flag is given, tha hidden command is invoked in
the specified namespace up in tha slave.
If tha \fB\-global\fR flag is given, tha command is invoked all up in tha global
level up in tha slave; otherwise it is invoked all up in tha current call frame and
can access local variablez up in dat or outa call frames.
Da \fB\-\|\-\fR flag allows tha \fIhiddenCmdName\fR argument ta start wit a
.QW \-
character, n' is otherwise unnecessary.
If both tha \fB\-namespace\fR n' \fB\-global\fR flags is given, the
\fB\-namespace\fR flag is ignored.
Note dat tha hidden command is ghon be executed (by default) up in the
current context stack frame of \fIslave\fR.
For mo' details on hidden commands,
see \fBHIDDEN COMMANDS\fR, below.
.TP
\fIslave \fBissafe\fR
Returns  \fB1\fR if tha slave interpreta is safe, \fB0\fR otherwise.
.TP
\fIslave \fBlimit\fR \fIlimitType\fR ?\fI\-option\fR? ?\fIvalue\fR \fI...\fR?
.VS 8.5
Sets up, manipulates n' queries tha configuration of tha resource
limit \fIlimitType\fR fo' tha slave interpreter n' shit.  If no \fI\-option\fR
is specified, return tha current configuration of tha limit.  If
\fI\-option\fR is tha sole argument, return tha value of dat option.
Otherwise, a list of \fI\-option\fR/\fIvalue\fR argument pairs must
supplied. Y'all KNOW dat shit, muthafucka! See \fBRESOURCE LIMITS\fR below fo' a mo' detailed explanation of
what limits n' options is supported.
.VE 8.5
.TP
\fIslave \fBmarktrusted\fR
Marks tha slave interpreta as trusted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Can only be invoked by a
trusted interpreter n' shit. This command do not expose any hidden
commandz up in tha slave interpreter n' shit. Da command has no effect if tha slave
is already trusted.
.TP
\fIslave\fR \fBrecursionlimit\fR ?\fInewlimit\fR?
Returns tha maximum allowable nestin depth fo' tha \fIslave\fR interpreter.
If \fInewlimit\fR is specified, tha recursion limit up in \fIslave\fR will be
set so dat nestin of mo' than \fInewlimit\fR calls ta \fBTcl_Eval()\fR
and related procedures up in \fIslave\fR will return a error.
Da \fInewlimit\fR value be also returned.
Da \fInewlimit\fR value must be a positizzle integer between 1 n' the
maximum value of a non-long integer on tha platform.
.RS
.PP
Da command sets tha maximum size of tha Tcl call stack only. Well shiiiit, it cannot
by itself prevent stack overflows on tha C stack bein used by the
application. I aint talkin' bout chicken n' gravy biatch. If yo' machine has a limit on tha size of tha C stack, you
may git stack overflows before reachin tha limit set by tha command. Y'all KNOW dat shit, muthafucka! If
this happens, peep if there be a mechanizzle up in yo' system fo' increasing
the maximum size of tha C stack.
.RE
.SH "SAFE INTERPRETERS"
.PP
A safe interpreta is one wit restricted functionality, so that
is safe ta execute a arbitrary script from yo' most shitty enemy without
fear of dat script damagin tha enclosin application or tha rest
of yo' computin environment.  In order ta cook up a interpreter
safe, certain commandz n' variablez is removed from tha interpreter.
For example, commandz ta create filez on disk is removed, n' the
\fBexec\fR command is removed, since it could be used ta cause damage
all up in subprocesses.
Limited access ta these facilitizzles can be provided, by bustin
aliases ta tha masta interpreta which check they arguments carefully
and provide restricted access ta a safe subset of facilities.
For example, file creation might be allowed up in a particular subdirectory
and subprocess invocation might be allowed fo' a cold-ass lil carefully selected and
fixed set of programs.
.PP
A safe interpreta is pimped by specifyin tha \fB\-safe\fR switch
to tha \fBinterp create\fR command. Y'all KNOW dat shit, muthafucka!  Furthermore, any slave pimped
by a safe interpreta will also be safe.
.PP
A safe interpreta is pimped wit exactly tha followin set of
built-in commands:
.DS
.ta 1.2i 2.4i 3.6i
\fBafter\fR	\fBappend\fR	\fBapply\fR	\fBarray\fR
\fBbinary\fR	\fBbreak\fR	\fBcatch\fR	\fBchan\fR
\fBclock\fR	\fBclose\fR	\fBconcat\fR	\fBcontinue\fR
\fBdict\fR	\fBeof\fR	\fBerror\fR	\fBeval\fR
\fBexpr\fR	\fBfblocked\fR	\fBfcopy\fR	\fBfileevent\fR
\fBflush\fR	\fBfor\fR	\fBforeach\fR	\fBformat\fR
\fBgets\fR	\fBglobal\fR	\fBif\fR	\fBincr\fR
\fBinfo\fR	\fBinterp\fR	\fBjoin\fR	\fBlappend\fR
\fBlassign\fR	\fBlindex\fR	\fBlinsert\fR	\fBlist\fR
\fBllength\fR	\fBlrange\fR	\fBlrepeat\fR	\fBlreplace\fR
\fBlsearch\fR	\fBlset\fR	\fBlsort\fR	\fBnamespace\fR
\fBpackage\fR	\fBpid\fR	\fBproc\fR	\fBputs\fR
\fBread\fR	\fBregexp\fR	\fBregsub\fR	\fBrename\fR
\fBreturn\fR	\fBscan\fR	\fBseek\fR	\fBset\fR
\fBsplit\fR	\fBstring\fR	\fBsubst\fR	\fBswitch\fR
\fBtell\fR	\fBtime\fR	\fBtrace\fR	\fBunset\fR
\fBupdate\fR	\fBuplevel\fR	\fBupvar\fR	\fBvariable\fR
\fBvwait\fR	\fBwhile\fR
.DE
Da followin commandz is hidden by \fBinterp create\fR when it
creates a safe interpreter:
.DS
.ta 1.2i 2.4i 3.6i
\fBcd\fR	\fBencoding\fR	\fBexec\fR	\fBexit\fR
\fBfconfigure\fR	\fBfile\fR	\fBglob\fR	\fBload\fR
\fBopen\fR	\fBpwd\fR	\fBsocket\fR	\fBsource\fR
\fBunload\fR
.DE
These commandz can be recreated lata as Tcl procedures or aliases, or
re-exposed by \fBinterp expose\fR.
.PP
Da followin commandz from Tclz library of support procedures are
not present up in a safe interpreter:
.DS
.ta 1.6i 3.2i
\fBauto_exec_ok\fR	\fBauto_import\fR	\fBauto_load\fR
\fBauto_load_index\fR	\fBauto_qualify\fR	\fBunknown\fR
.DE
Note up in particular dat safe interpretas have no default \fBunknown\fR
command, so Tclz default autoloadin facilitizzles is not available.
Autoload access ta Tclz commandz dat is normally autoloaded:
.DS
.ta 2.1i
\fBauto_mkindex\fR	\fBauto_mkindex_old\fR
\fBauto_reset\fR	\fBhistory\fR
\fBparray\fR	\fBpkg_mkIndex\fR
\fB::pkg::create\fR	\fB::safe::interpAddToAccessPath\fR
\fB::safe::interpCreate\fR	\fB::safe::interpConfigure\fR
\fB::safe::interpDelete\fR	\fB::safe::interpFindInAccessPath\fR
\fB::safe::interpInit\fR	\fB::safe::setLogCmd\fR
\fBtcl_endOfWord\fR	\fBtcl_findLibrary\fR
\fBtcl_startOfNextWord\fR	\fBtcl_startOfPreviousWord\fR
\fBtcl_wordBreakAfter\fR	\fBtcl_wordBreakBefore\fR
.DE
can only be provided by explicit definizzle of a \fBunknown\fR command
in tha safe interpreter n' shit.  This will involve exposin tha \fBsource\fR
command. Y'all KNOW dat shit, muthafucka!  This is most easily accomplished by bustin tha safe interpreter
with Tclz \fBSafe\-Tcl\fR mechanism.  \fBSafe\-Tcl\fR serves up safe
versionz of \fBsource\fR, \fBload\fR, n' other Tcl commandz needed
to support autoloadin of commandz n' tha loadin of packages.
.PP
In addition, tha \fBenv\fR variable aint present up in a safe interpreter,
so it cannot share environment variablez wit other interpreters. The
\fBenv\fR variable poses a securitizzle risk, cuz playas can store
sensitizzle shiznit up in a environment variable. For example, tha PGP
manual recommendz storin tha PGP private key protection password in
the environment variable \fIPGPPASS\fR. Makin dis variable available
to untrusted code executin up in a safe interpreta would incur a
securitizzle risk.
.PP
If extensions is loaded tha fuck into a safe interpreter, they may also restrict
their own functionalitizzle ta eliminizzle unsafe commands. For a gangbangin' finger-lickin' rap of
management of extensions fo' safety peep tha manual entries for
\fBSafe\-Tcl\fR n' tha \fBload\fR Tcl command.
.PP
A safe interpreta may not alta tha recursion limit of any interpreter,
includin itself.
.SH "ALIAS INVOCATION"
.PP
Da alias mechanizzle has been carefully designed so dat it can
be used safely when a untrusted script is executing
in a safe slave n' tha target of tha alias be a trusted
masta n' shit.  Da most blingin thang up in guaranteein safety is to
ensure dat shiznit passed from tha slave ta tha masta is
never evaluated or substituted up in tha master;  if dis was to
occur, it would enable a evil script up in tha slave ta invoke
arbitrary functions up in tha master, which would compromise security.
.PP
When tha source fo' a alias is invoked up in tha slave interpreter, the
usual Tcl substitutions is performed when parsin dat command.
These substitutions is carried up in tha source interpreta just
as they would be fo' any other command invoked up in dat interpreter.
Da command procedure fo' tha source command takes its arguments
and merges dem wit tha \fItargetCmd\fR n' \fIarg\fRs fo' the
alias ta create a freshly smoked up array of arguments, n' you can put dat on yo' toast.  If tha lyrics
of \fIsrcCmd\fR were
.QW "\fIsrcCmd arg1 arg2 ... argN\fR" ,
the freshly smoked up set of lyrics will be
.QW "\fItargetCmd arg arg ... arg arg1 arg2 ... argN\fR" ,
where \fItargetCmd\fR n' \fIarg\fRs is tha joints supplied when the
alias was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \fITargetCmd\fR is then used ta locate a cold-ass lil command
procedure up in tha target interpreter, n' dat command procedure
is invoked wit tha freshly smoked up set of arguments, n' you can put dat on yo' toast.  An error occurs if
there is no command named \fItargetCmd\fR up in tha target interpreter.
No additionizzle substitutions is performed on tha lyrics:  the
target command procedure is invoked directly, without
goin all up in tha aiiight Tcl evaluation mechanism.
Substitutions is thus performed on each word exactly once:
\fItargetCmd\fR n' \fIargs\fR was substituted when parsin tha command
that pimped tha alias, n' \fIarg1 - argN\fR is substituted when
the aliass source command is parsed up in tha source interpreter.
.PP
When freestylin tha \fItargetCmd\fRs fo' aliases up in safe interpreters,
it is straight-up blingin dat tha arguments ta dat command never be
evaluated or substituted, since dis would provide a escape
mechanizzle whereby tha slave interpreta could execute arbitrary
code up in tha masta n' shit.  This up in turn would compromise tha security
of tha system.
.SH "HIDDEN COMMANDS"
.PP
Safe interpretas pimped outly restrict tha functionalitizzle available ta Tcl
programs executin within em.
Allowin tha untrusted Tcl program ta have direct access ta this
functionalitizzle is unsafe, cuz it can be used fo' a variety of
attacks on tha environment.
But fuck dat shiznit yo, tha word on tha street is dat there be times when there be a legitimate need ta use the
dangerous functionalitizzle up in tha context of tha safe interpreter n' shit. For
example, sometimes a program must be \fBsource\fRd tha fuck into tha interpreter.
Another example is Tk, where windows is bound ta tha hierarchy of windows
for a specific interpreter; some potentially fucked up functions, e.g.
window pimpment, must be performed on these windows within the
interpreta context.
.PP
Da \fBinterp\fR command serves up a solution ta dis problem up in tha form of
\fIhidden commands\fR. Instead of removin tha fucked up commandz entirely
from a safe interpreter, these commandz is hidden so they become
unavailable ta Tcl scripts executin up in tha interpreter n' shit. But fuck dat shiznit yo, tha word on tha street is dat such
hidden commandz can be invoked by any trusted ancestor of tha safe
interpreter, up in tha context of tha safe interpreter, rockin \fBinterp
invoke\fR yo. Hidden commandz n' exposed commandz reside up in separate name
spaces. Well shiiiit, it is possible ta define a hidden command n' a exposed command by
the same name within one interpreter.
.PP
Hidden commandz up in a slave interpreta can be invoked up in tha body of
procedures called up in tha masta durin alias invocation. I aint talkin' bout chicken n' gravy biatch. For example, an
alias fo' \fBsource\fR could be pimped up in a slave interpreter n' shit. When it is
invoked up in tha slave interpreter, a procedure is called up in tha master
interpreta ta check dat tha operation be allowable (e.g. it asks to
source a gangbangin' file dat tha slave interpreta be allowed ta access). The
procedure then it invokes tha hidden \fBsource\fR command up in tha slave
interpreta ta straight-up source up in tha contentz of tha file. Note dat two
commandz named \fBsource\fR exist up in tha slave interpreter: tha alias, and
the hidden command.
.PP
Because a masta interpreta may invoke a hidden command as part of
handlin a alias invocation, pimped out care must be taken ta avoid evaluating
any arguments passed up in all up in tha alias invocation.
Otherwise, malicious slave interpretas could cause a trusted master
interpreta ta execute fucked up commandz on they behalf. Right back up in yo muthafuckin ass. See tha section
on \fBALIAS INVOCATION\fR fo' a mo' complete rap of dis topic.
To help avoid dis problem, no substitutions or evaluations are
applied ta argumentz of \fBinterp invokehidden\fR.
.PP
Safe interpretas is not allowed ta invoke hidden commandz up in theyselves
or up in they descendants, n' you can put dat on yo' toast. This prevents safe slaves from bustin access to
hidden functionalitizzle up in theyselves or they descendants.
.PP
Da set of hidden commandz up in a interpreta can be manipulated by a trusted
interpreta rockin \fBinterp expose\fR n' \fBinterp hide\fR. Da \fBinterp
expose\fR command moves a hidden command ta the
set of exposed commandz up in tha interpreta identified by \fIpath\fR,
potentially renamin tha command up in tha process. If a exposed command by
the targeted name already exists, tha operation fails. Right back up in yo muthafuckin ass. Similarly,
\fBinterp hide\fR moves a exposed command ta tha set of hidden commandz in
that interpreter n' shit. Right back up in yo muthafuckin ass. Safe interpretas is not allowed ta move commands
between tha set of hidden n' exposed commands, up in either theyselves or
their descendants.
.PP
Currently, tha namez of hidden commandz cannot contain namespace
qualifiers, n' you must first rename a cold-ass lil command up in a namespace ta the
global namespace before you can hide dat shit.
Commandz ta be hidden by \fBinterp hide\fR is looked up in tha global
namespace even if tha current namespace aint tha global one. This
prevents slaves from foolin a masta interpreta tha fuck into hidin tha wrong
command, by makin tha current namespace be different from tha global one.
.SH "RESOURCE LIMITS"
.VS 8.5
.PP
Every interpreta has two kindz of resource limits dat may be imposed by any
masta interpreta upon its slaves. Command limits (of type \fBcommand\fR)
restrict tha total number of Tcl commandz dat may be executed by an
interpreta (as can be inspected via tha \fBinfo cmdcount\fR command), and
time limits (of type \fBtime\fR) place a limit by which execution within the
interpreta must complete. Note dat time limits is expressed as
\fIabsolute\fR times (as up in \fBclock seconds\fR) n' not relatizzle times (as in
\fBafter\fR) cuz they may be modified afta creation.
.PP
When a limit is exceeded fo' a interpreter, first any handlez callbacks
defined by masta interpretas is called. Y'all KNOW dat shit, muthafucka! If dem callbacks increase or
remove tha limit, execution within tha (previously) limited interpreter
continues. If tha limit is still up in force, a error is generated at dat point
and aiiight processin of errors within tha interpreta (by tha \fBcatch\fR
command) is disabled, so tha error propagates outwardz (buildin a stack-trace
as it goes) ta tha point where tha limited interpreta was invoked (e.g. by
\fBinterp eval\fR) where it becomes tha responsibilitizzle of tha callin code to
catch n' handle.
.SS "LIMIT OPTIONS"
.PP
Every limit has a fuckin shitload of options associated wit it, a shitload of which are
common across all kindz of limits, n' otherz of which is particular ta the
kind of limit.
.VE 8.5
.TP
\fB\-command\fR
.VS 8.5
This option (common fo' all limit types) specifies (if non-empty) a Tcl script
to be executed up in tha global namespace of tha interpreta readin n' writing
the option when tha particular limit up in tha limited interpreta is exceeded.
Da callback may modify tha limit on tha interpreta if it wishes tha limited
interpreta ta continue executing. If tha callback generates a error, it is
reported all up in tha background error mechanizzle (see \fBBACKGROUND ERROR
HANDLING\fR). Note dat tha callbacks defined by one interpreta are
completely isolated from tha callbacks defined by another, n' dat tha order
in which dem callbacks is called is undefined.
.VE 8.5
.TP
\fB\-granularity\fR
.VS 8.5
This option (common fo' all limit types) specifies how tha fuck frequently (out of the
points when tha Tcl interpreta is up in a cold-ass lil consistent state where limit checking
is possible) dat tha limit is straight-up checked. Y'all KNOW dat shit, muthafucka! This allows tha tunin of how
frequently a limit is checked, n' hence how tha fuck often tha limit-checkin overhead
(which may be substantial up in tha case of time limits) is incurred.
.VE 8.5
.TP
\fB\-milliseconds\fR
.VS 8.5
This option specifies tha number of millisecondz afta tha moment defined in
the \fB\-seconds\fR option dat tha time limit will fire. Well shiiiit, it should only ever
be specified up in conjunction wit tha \fB\-seconds\fR option (whether it was
set previously or is bein set dis invocation.)
.VE 8.5
.TP
\fB\-seconds\fR
.VS 8.5
This option specifies tha number of secondz afta tha epoch (see \fBclock
seconds\fR) dat tha time limit fo' tha interpreta is ghon be triggered. Y'all KNOW dat shit, muthafucka! The
limit is ghon be triggered all up in tha start of tha second unless specified at a
sub-second level rockin tha \fB\-milliseconds\fR option. I aint talkin' bout chicken n' gravy biatch. This option may be the
empty string, which indicates dat a time limit aint set fo' the
interpreter.
.VE 8.5
.TP
\fB\-value\fR
.VS 8.5
This option specifies tha number of commandz dat tha interpreta may execute
before triggerin tha command limit. This option may be tha empty string,
which indicates dat a cold-ass lil command limit aint set fo' tha interpreter.
.PP
Where a interpreta wit a resource limit set on it creates a slave
interpreter, dat slave interpreta gonna git resource limits imposed on it
that is at least as restrictizzle as tha limits on tha bustin master
interpreter n' shit. If tha masta interpreta of tha limited masta wishes ta chillax
these conditions, it should hide tha \fBinterp\fR command up in tha lil pimp and
then use aliases n' tha \fBinterp invokehidden\fR subcommand ta provide such
access as it chizzlez ta tha \fBinterp\fR command ta tha limited masta as
necessary.
.SH "BACKGROUND ERROR HANDLING"
.PP
When a error happens up in a thang where it cannot be reported directly up
the stack (e.g. when processin events up in a \fBupdate\fR or \fBvwait\fR call)
the error is instead reported all up in tha background error handlin mechanism.
Every interpreta has a funky-ass background error handlez registered; tha default error
handlez arranges fo' tha \fBbgerror\fR command up in tha interpreterz global
namespace ta be called yo, but other error handlezs may be installed n' process
background errors up in substantially different ways.
.PP
A background error handlez consistz of a non-empty list of lyrics ta which will
be appended two further lyrics at invocation time. Da first word is ghon be the
error message string, n' tha second will a gangbangin' finger-lickin' doggtionary of return options (this
is also tha sort of shiznit dat can be obtained by trappin a normal
error rockin \fBcatch\fR of course.) Da resultin list will then be executed
in tha interpreterz global namespace without further substitutions being
performed.
.VE 8.5
.SH CREDITS
Da safe interpreta mechanizzle is based on tha Safe-Tcl prototype implemented
by Nathaniel Borenstein n' Marshall Rose.
.SH EXAMPLES
Creatin n' rockin a alias fo' a cold-ass lil command up in tha current interpreter:
.CS
\fBinterp alias\fR {} getIndex {} lsearch {alpha beta gamma delta}
set idx [getIndex delta]
.CE
.PP
Executin a arbitrary command up in a safe interpreta where every
invocation of \fBlappend\fR is logged:
.CS
set i [\fBinterp create\fR -safe]
\fBinterp hide\fR $i lappend
\fBinterp alias\fR $i lappend {} loggedLappend $i
proc loggedLappend {i args} {
   puts "logged invocation of lappend $args"
   \fBinterp invokehidden\fR $i lappend {*}$args
}
\fBinterp eval\fR $i $someUntrustedScript
.CE
.PP
.VS 8.5
Settin a resource limit on a interpreta so dat a infinite loop
terminates.
.CS
set i [\fBinterp create\fR]
\fBinterp limit\fR $i command -value 1000
\fBinterp eval\fR $i {
   set x 0
   while {1} {
      puts "Countin up... [incr x]"
   }
}
.CE
.VE 8.5
.SH "SEE ALSO"
bgerror(n), load(n), safe(n), Tcl_CreateSlave(3)
.SH KEYWORDS
alias, masta interpreter, safe interpreter, slave interpreter
