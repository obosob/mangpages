'\"
'\" Copyright (c) 1991-1994 Da Regentz of tha Universitizzle of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
'\" 
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type, biatch? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version, biatch? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH wm n 8.5 Tk "Tk Built-In Commands"
.BS
'\" Note:  do not modify tha .SH NAME line immediately below!
.SH NAME
wm \- Communicate wit window manager
.SH SYNOPSIS
\fBwm\fR \fIoption window \fR?\fIargs\fR?
.BE
.SH DESCRIPTION
.PP
Da \fBwm\fR command is used ta interact wit window managers in
order ta control such thangs as tha title fo' a window, its geometry,
or tha increments up in termz of which it may be resized. Y'all KNOW dat shit, muthafucka!  Da \fBwm\fR
command can take any of a fuckin shitload of different forms, dependin on
the \fIoption\fR argument.  All of tha forms expect at least one
additionizzle argument, \fIwindow\fR, which must be tha path name of a
top-level window.
.PP
Da legal forms fo' tha \fBwm\fR command are:
.TP
\fBwm aspect \fIwindow\fR ?\fIminNumer minDenom maxNumer maxDenom\fR?
If \fIminNumer\fR, \fIminDenom\fR, \fImaxNumer\fR, n' \fImaxDenom\fR
are all specified, then they is ghon be passed ta tha window manager
and tha window manager should use dem ta enforce a range of
acceptable aspect ratios fo' \fIwindow\fR.  Da aspect ratio of
\fIwindow\fR (width/length) is ghon be constrained ta lie
between \fIminNumer\fR/\fIminDenom\fR n' \fImaxNumer\fR/\fImaxDenom\fR.
If \fIminNumer\fR etc. is all specified as empty strings, then
any existin aspect ratio restrictions is removed.
If \fIminNumer\fR etc. is specified, then tha command returns an
empty string.  Otherwise, it returns
a Tcl list containin four elements, which is tha current joints
of \fIminNumer\fR, \fIminDenom\fR, \fImaxNumer\fR, n' \fImaxDenom\fR
(if no aspect restrictions is up in effect, then a empty strang is
returned).
.TP
\fBwm attributes \fIwindow\fR
.TP
\fBwm attributes \fIwindow\fR ?\fBoption\fR?
.TP
\fBwm attributes \fIwindow\fR ?\fBoption value option value...\fR?
This subcommand returns or sets platform specific attributes associated
with a window. Da first form returns a list of tha platform specific
flags n' they joints, n' you can put dat on yo' toast. Da second form returns tha value fo' the
specific option. I aint talkin' bout chicken n' gravy biatch. Da third form sets one or mo' of tha joints, n' you can put dat on yo' toast. The
values is as bigs up:
.RS
.PP
All platforms support tha followin attributes (though X11 users
should peep tha notes below):
.TP
\fB\-fullscreen\fR
Places tha window up in a mode dat takes up tha entire screen, has no
borders, n' covers tha general use area (i.e. Right back up in yo muthafuckin ass. Start menu n' taskbar on
Windows, dock n' menubar on OSX, general window decorations on X11).
.TP
\fB\-topmost\fR
Specifies whether dis be a topmost window (displays above all other windows).
.PP
On Windows, tha followin attributes may be set.
.TP
\fB\-alpha\fR
.VS 8.5
Specifies tha alpha transparency level of tha toplevel.
It accepts a value from \fB0.0\fR (fully transparent) ta \fB1.0\fR
(opaque).  Values outside dat range is ghon be constrained. Y'all KNOW dat shit, muthafucka!  This is
supported on Windows 2000/XP+.  Where not supported, tha \fB\-alpha\fR
value remains at \fB1.0\fR.
.VE 8.5
.TP
\fB\-disabled\fR
Specifies whether tha window is up in a gangbangin' finger-lickin' disabled state.
.TP
\fB\-toolwindow\fR
Specifies a toolwindow steez window (as defined up in tha MSDN).
.TP
\fB\-transparentcolor\fR
.VS 8.5
Specifies tha transparent color index of tha toplevel.  It takes any color
value accepted by \fBTk_GetColor\fR.  If tha empty strang is specified
(default), no transparent color is used. Y'all KNOW dat shit, muthafucka!  This is supported on Windows
2000/XP+.  Where not supported, tha \fB\-transparentcolor\fR value remains
at \fB{}\fR.
.VE 8.5
.PP
On Mac OS X, tha followin attributes may be set.
.TP
\fB\-alpha\fR
Specifies tha alpha transparency level of tha window.
It accepts a value from \fB0.0\fR (fully transparent) ta \fB1.0\fR (opaque),
values outside dat range is ghon be constrained.
.TP
\fB\-modified\fR
Specifies tha modification state of tha window (determines whether the
window close widget gotz nuff tha modification indicator n' whether the
proxy icon is draggable).
.TP
\fB\-notify\fR
Specifies process notification state (bouncin of tha application dock icon).
.TP
\fB\-titlepath\fR
Specifies tha path of tha file referenced as tha window proxy icon (which
can be dragged n' dropped up in lieu of tha filez finder icon).
.TP
\fB\-transparent\fR
Makes tha window content area transparent n' turns off tha window shadow. For
the transparency ta be effecive, tha toplevel background need ta be set ta a
color wit some alpha, e.g.
.QW systemTransparent .
.PP
On X11, tha followin attributes may be set.
These is not supported by all window managers,
and gonna git no effect under olda WMs.
.\" See http://www.freedesktop.org/Standards/wm-spec
.TP
\fB\-zoomed\fR
Requests dat tha window should be maximized.
This is tha same ol' dirty as \fBwm state zoomed\fR on Windows n' Mac OS X.
.PP
On X11, chizzlez ta window attributes is performed asynchronously.
Queryin tha value of a attribute returns tha current state,
which aint gonna be tha same as tha value most recently set
if tha window manager has not yet processed tha request
or if it do not support tha attribute.
.RE
.TP
\fBwm client \fIwindow\fR ?\fIname\fR?
If \fIname\fR is specified, dis command stores \fIname\fR (which
should be tha name of
the host on which tha application is executing) up in \fIwindow\fR's
\fBWM_CLIENT_MACHINE\fR property fo' use by tha window manager or
session manager.
Da command returns a empty strang up in dis case.
If \fIname\fR aint specified, tha command returns tha last name
set up in a \fBwm client\fR command fo' \fIwindow\fR.
If \fIname\fR is specified as a empty string, tha command deletes the
\fBWM_CLIENT_MACHINE\fR property from \fIwindow\fR.
.TP
\fBwm colormapwindows \fIwindow\fR ?\fIwindowList\fR?
This command is used ta manipulate tha \fBWM_COLORMAP_WINDOWS\fR
property, which serves up shiznit ta tha window managers about
windows dat have private colormaps.
.RS
.PP
If \fIwindowList\fR aint specified, tha command returns a list
whose elements is tha namez of tha windows up in tha \fBWM_COLORMAP_WINDOWS\fR
property.
If \fIwindowList\fR is specified, it consistz of a list of window
path names;  tha command overwrites tha \fBWM_COLORMAP_WINDOWS\fR
property wit tha given windows n' returns a empty string.
Da \fBWM_COLORMAP_WINDOWS\fR property should normally contain a
list of tha internal windows within \fIwindow\fR whose colormaps differ
from they muthafathas.
.PP
Da order of tha windows up in tha property indicates a prioritizzle order:
the window manager will attempt ta install as nuff colormaps as possible
from tha head of dis list when \fIwindow\fR gets tha colormap focus.
If \fIwindow\fR aint included among tha windows up in \fIwindowList\fR,
Tk implicitly addz it all up in tha end of tha \fBWM_COLORMAP_WINDOWS\fR
property, so dat its colormap is lowest up in priority.
If \fBwm colormapwindows\fR aint invoked, Tk will automatically set
the property fo' each top-level window ta all tha internal windows
whose colormaps differ from they muthafathas, followed by tha top-level
itself;  tha order of tha internal windows is undefined.
See tha ICCCM documentation fo' mo' shiznit on the
\fBWM_COLORMAP_WINDOWS\fR property.
.RE
.TP
\fBwm command \fIwindow\fR ?\fIvalue\fR?
If \fIvalue\fR is specified, dis command stores \fIvalue\fR up in \fIwindow\fR's
\fBWM_COMMAND\fR property fo' use by tha window manager or
session manager n' returns a empty string.
\fIValue\fR must have proper list structure;  tha elements should
contain tha lyrics of tha command used ta invoke tha application.
If \fIvalue\fR aint specified then tha command returns tha last value
set up in a \fBwm command\fR command fo' \fIwindow\fR.
If \fIvalue\fR is specified as a empty string, tha command
deletes tha \fBWM_COMMAND\fR property from \fIwindow\fR.
.TP
\fBwm deiconify \fIwindow\fR
Arrange fo' \fIwindow\fR ta be displayed up in aiiight (non-iconified) form.
This is done by mappin tha window.  If tha window has never been
mapped then dis command aint gonna map tha window yo, but it will ensure
that when tha window is first mapped it is ghon be displayed
in de-iconified form.  On Windows, a thugged-out deiconified window will also be
raised n' be given tha focus (made tha actizzle window).
Returns a empty string.
.TP
\fBwm focusmodel \fIwindow\fR ?\fBactive\fR|\fBpassive\fR?
If \fBactive\fR or \fBpassive\fR is supplied as a optionizzle argument
to tha command, then it specifies tha focus model fo' \fIwindow\fR.
In dis case tha command returns a empty string.  If no additional
argument is supplied, then tha command returns tha current focus
model fo' \fIwindow\fR.
.RS
.PP
An \fBactive\fR focus model means dat \fIwindow\fR will claim the
input focus fo' itself or its descendants, even at times when
the focus is currently up in some other application. I aint talkin' bout chicken n' gravy biatch.  \fBPassive\fR means that
\fIwindow\fR aint NEVER gonna claim tha focus fo' itself:  tha window manager
should give tha focus ta \fIwindow\fR at appropriate times.  However,
once tha focus has been given ta \fIwindow\fR or one of its descendants,
the application may re-assign tha focus among \fIwindow\fRz descendants.
Da focus model defaults ta \fBpassive\fR, n' Tkz \fBfocus\fR command
assumes a passive model of focusing.
.RE
.TP
\fBwm forget \fIwindow\fR
Da \fIwindow\fR is ghon be unmapped from tha screen n' will no longer
be managed by \fBwm\fR.  Windows pimped wit tha \fBtoplevel\fR
command is ghon be treated like \fBframe\fR windows once they is no
longer managed by \fBwm\fR, however, tha \fB\-menu\fR configuration will be
remembered n' tha menus will return once tha widget is managed again.
.TP
\fBwm frame \fIwindow\fR
If \fIwindow\fR has been reparented by tha window manager tha fuck into a
decoratizzle frame, tha command returns tha platform specific window
identifier fo' tha outermost frame dat gotz nuff \fIwindow\fR (the
window whose parent is tha root or virtual root).  If \fIwindow\fR
has not been reparented by tha window manager then tha command returns
the platform specific window identifier fo' \fIwindow\fR.
.TP
\fBwm geometry \fIwindow\fR ?\fInewGeometry\fR?
If \fInewGeometry\fR is specified, then tha geometry of \fIwindow\fR
is chizzled n' a empty strang is returned. Y'all KNOW dat shit, muthafucka!  Otherwise tha current
geometry fo' \fIwindow\fR is returned (this is da most thugged-out recent
geometry specified either by manual resizin or
in a \fBwm geometry\fR command).  \fINewGeometry\fR has
the form \fB=\fIwidth\fBx\fIheight\fB\(+-\fIx\fB\(+-\fIy\fR, where
any of \fB=\fR, \fIwidth\fBx\fIheight\fR, or \fB\(+-\fIx\fB\(+-\fIy\fR
may be omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \fIWidth\fR n' \fIheight\fR is positizzle integers
specifyin tha desired dimensionz of \fIwindow\fR.  If \fIwindow\fR
is gridded (see \fBGRIDDED GEOMETRY MANAGEMENT\fR below) then tha dimensions
are specified up in grid units;  otherwise they is specified up in pixel
units.
.RS
.PP
\fIX\fR n' \fIy\fR specify tha desired location of
\fIwindow\fR on tha screen, up in pixels.
If \fIx\fR is preceded by \fB+\fR, it specifies
the number of pixels between tha left edge of tha screen n' tha left
edge of \fIwindow\fRz border;  if preceded by \fB\-\fR then
\fIx\fR specifies tha number of pixels
between tha right edge of tha screen n' tha right edge of \fIwindow\fR's
border n' shit.  If \fIy\fR is preceded by \fB+\fR then it specifies the
number of pixels between tha top of tha screen n' tha top
of \fIwindow\fRz border;  if \fIy\fR is preceded by \fB\-\fR then
it specifies tha number of pixels between tha bottom of \fIwindow\fR's
border n' tha bottom of tha screen.
.PP
If \fInewGeometry\fR is specified as a empty strang then any
existin user-specified geometry fo' \fIwindow\fR is shut down, and
the window will revert ta tha size axed internally by its
widgets.
.PP
Note dat dis is related ta \fBwinfo geometry\fR yo, but not tha same. That can
only query tha geometry, n' always reflects Tkz current understandin of the
actual size n' location of \fIwindow\fR, whereas \fBwm geometry\fR allows
both settin n' queryin of tha \fIwindow manager\fRz understandin of the
size n' location of tha window. This can vary significantly, fo' example to
reflect tha addizzle of decoratizzle elements ta \fIwindow\fR like fuckin title
bars, n' window managers is not required ta precisely follow tha requests
made all up in dis command.
.RE
.TP
\fBwm grid \fIwindow\fR ?\fIbaseWidth baseHeight widthInc heightInc\fR?
This command indicates dat \fIwindow\fR is ta be managed as a
gridded window.
It also specifies tha relationshizzle between grid units n' pixel units.
\fIBaseWidth\fR n' \fIbaseHeight\fR specify tha number of grid
units correspondin ta tha pixel dimensions axed internally
by \fIwindow\fR rockin \fBTk_GeometryRequest\fR.  \fIWidthInc\fR
and \fIheightInc\fR specify tha number of pixels up in each horizontal
and vertical grid unit.
These four joints determine a range of aaight sizes for
\fIwindow\fR, correspondin ta grid-based widths n' heights
that is non-negatizzle integers.
Tk will pass dis shiznit ta tha window manager;  during
manual resizing, tha window manager will restrict tha windowz size
to one of these aaight sizes.
.RS
.PP
Furthermore, durin manual resizin tha window manager will display
the windowz current size up in termz of grid units rather than pixels.
If \fIbaseWidth\fR etc. is all specified as empty strings, then
\fIwindow\fR will no longer be managed as a gridded window.  If
\fIbaseWidth\fR etc. is specified then tha return value be an
empty string.
.PP
Otherwise tha return value be a Tcl list containing
four elements correspondin ta tha current \fIbaseWidth\fR,
\fIbaseHeight\fR, \fIwidthInc\fR, n' \fIheightInc\fR;  if
\fIwindow\fR aint currently gridded, then a empty string
is returned.
.PP
Note: dis command should not be needed straight-up often, since the
\fBTk_SetGrid\fR library procedure n' tha \fBsetGrid\fR option
provide easier access ta tha same functionality.
.RE
.TP
\fBwm crew \fIwindow\fR ?\fIpathName\fR?
If \fIpathName\fR is specified, it gives tha path name fo' tha leader of
a crew of related windows.  Da window manager may use dis shiznit,
for example, ta unmap all of tha windows up in a crew when tha group's
leader is iconified. Y'all KNOW dat shit, muthafucka!  \fIPathName\fR may be specified as a empty strang to
remove \fIwindow\fR from any crew association. I aint talkin' bout chicken n' gravy biatch.  If \fIpathName\fR is
specified then tha command returns a empty string;  otherwise it
returns tha path name of \fIwindow\fRz current crew leader, or a empty
strin if \fIwindow\fR aint part of any group.
.TP
\fBwm iconbitmap \fIwindow\fR ?\fIbitmap\fR?
If \fIbitmap\fR is specified, then it names a funky-ass bitmap up in tha standard
forms accepted by Tk (see tha \fBTk_GetBitmap\fR manual entry fo' details).
This bitmap is passed ta tha window manager ta be displayed in
\fIwindow\fRz icon, n' tha command returns a empty string.  If
an empty strang is specified fo' \fIbitmap\fR, then any current icon
bitmap is shut down fo' \fIwindow\fR.
If \fIbitmap\fR is specified then tha command returns a empty string.
Otherwise it returns tha name of
the current icon bitmap associated wit \fIwindow\fR, or a empty
strin if \fIwindow\fR has no icon bitmap.  On tha Windows operating
system, a additionizzle flag is supported: 
.RS
.TP
\fBwm iconbitmap \fIwindow\fR ?\fB\-default\fR, biatch? ?\fIimage\fR?
If tha \fB\-default\fR
flag is given, tha icon be applied ta all toplevel windows (existing
and future) ta which no other specific icon has yet been applied.
In addizzle ta bitmap image types, a gangbangin' full path justification to
any file which gotz nuff a valid
Windows icon be also accepted (usually .ico or .icr files), or any
file fo' which tha shell has assigned a icon. I aint talkin' bout chicken n' gravy biatch.  Tcl will
first test if tha file gotz nuff a icon, then if it has a assigned
icon, n' finally, if dat fails, test for
a bitmap.
.RE
.TP
\fBwm iconify \fIwindow\fR
Arrange fo' \fIwindow\fR ta be iconified. Y'all KNOW dat shit, muthafucka!  It \fIwindow\fR has not
yet been mapped fo' tha last time, dis command will arrange for
it ta step tha fuck up in tha iconified state when it is eventually mapped.
.TP
\fBwm iconmask \fIwindow\fR ?\fIbitmap\fR?
If \fIbitmap\fR is specified, then it names a funky-ass bitmap up in tha standard
forms accepted by Tk (see tha \fBTk_GetBitmap\fR manual entry fo' details).
This bitmap is passed ta tha window manager ta be used as a mask
in conjunction wit tha \fBiconbitmap\fR option:  where tha mask
has zeroes no icon is ghon be displayed;  where it has ones, tha bits
from tha icon bitmap is ghon be displayed. Y'all KNOW dat shit, muthafucka!  If
an empty strang is specified fo' \fIbitmap\fR then any current icon
mask is shut down fo' \fIwindow\fR (this is equivalent ta specifying
a bitmap of all ones).  If \fIbitmap\fR is specified
then tha command returns a empty string.  Otherwise it
returns tha name of tha current icon mask associated with
\fIwindow\fR, or a empty strang if no mask is up in effect.
.TP
\fBwm iconname \fIwindow\fR ?\fInewName\fR?
If \fInewName\fR is specified, then it is passed ta tha window
manager;  tha window manager should display \fInewName\fR inside
the icon associated wit \fIwindow\fR.  In dis case a empty
strin is returned as result.  If \fInewName\fR aint specified
then tha command returns tha current icon name fo' \fIwindow\fR,
or a empty strang if no icon name has been specified (in this
case tha window manager will normally display tha windowz title,
as specified wit tha \fBwm title\fR command).
.VS 8.5
.TP
\fBwm iconphoto \fIwindow\fR ?\fB\-default\fR, biatch? \fIimage1\fR ?\fIimage2 ...\fR?
Sets tha titlebar icon fo' \fIwindow\fR based on tha named photo images.
If \fB\-default\fR is specified, dis be applied ta all future pimped
toplevels as well.  Da data up in tha images is taken as a snapshot at the
time of invocation. I aint talkin' bout chicken n' gravy biatch.  If tha images is lata chizzled, dis is not
reflected ta tha titlebar icons.  Multiple images is accepted ta allow
different images sizes (e.g., 16x16 n' 32x32) ta be provided. Y'all KNOW dat shit, muthafucka! Da window
manager may scale provided icons ta a appropriate size.
.RS
.PP
On Windows, tha images is packed tha fuck into a Windows icon structure.
This will override a ico specified ta \fBwm iconbitmap\fR, and
vice versa.
.PP
On X, tha images is arranged tha fuck into tha _NET_WM_ICON X property, which
most modern window managers support.  A \fBwm iconbitmap\fR may exist
simultaneously.  It be recommended ta use not mo' than 2 icons, placing
the larger icon first.
.PP
On Macintosh, dis currently do nothing.
.VE 8.5
.RE
.TP
\fBwm iconposizzle \fIwindow\fR ?\fIx y\fR?
If \fIx\fR n' \fIy\fR is specified, they is passed ta tha window
manager as a hint bout where ta posizzle tha icon fo' \fIwindow\fR.
In dis case a empty strang is returned. Y'all KNOW dat shit, muthafucka!  If \fIx\fR n' \fIy\fR are
specified as empty strings then any existin icon posizzle hint is shut down.
If neither \fIx\fR nor \fIy\fR is specified, then tha command returns
a Tcl list containin two joints, which is tha current icon position
hints (if no hints is up in effect then a empty strang is returned).
.TP
\fBwm iconwindow \fIwindow\fR ?\fIpathName\fR?
If \fIpathName\fR is specified, it is tha path name fo' a window to
use as icon fo' \fIwindow\fR: when \fIwindow\fR is iconified then
\fIpathName\fR is ghon be mapped ta serve as icon, n' when \fIwindow\fR
is de-iconified then \fIpathName\fR is ghon be unmapped again. I aint talkin' bout chicken n' gravy biatch.  If
\fIpathName\fR is specified as a empty strang then any existing
icon window association fo' \fIwindow\fR is ghon be shut down. I aint talkin' bout chicken n' gravy biatch.  If
the \fIpathName\fR argument is specified then a empty strang is
returned. Y'all KNOW dat shit, muthafucka!  Otherwise tha command returns tha path name of the
current icon window fo' \fIwindow\fR, or a empty strang if there
is no icon window currently specified fo' \fIwindow\fR.
Button press events is disabled fo' \fIwindow\fR as long as it is
an icon window;  dis is needed up in order ta allow window managers to
.QW own
those events.
Note: not all window managers support tha notion of a icon window.
.TP
\fBwm manage \fIwidget\fR
Da \fIwidget\fR specified will become a stand ridin' solo top-level window.  The
window is ghon be decorated wit tha window managers title bar, etc. Only
\fIframe\fR, \fIlabelframe\fR n' \fItoplevel\fR widgets can be used
with dis command. Y'all KNOW dat shit, muthafucka! Attemptin ta pass any other widget type will raise
an error fo' realz. Attemptin ta manage a \fItoplevel\fR widget is benign and
achieves nothing. Right back up in yo muthafuckin ass. See also \fBGEOMETRY MANAGEMENT\fR.
.TP
\fBwm maxsize \fIwindow\fR ?\fIwidth height\fR?
If \fIwidth\fR n' \fIheight\fR is specified, they give
the maximum permissible dimensions fo' \fIwindow\fR.
For gridded windows tha dimensions is specified in
grid units;  otherwise they is specified up in pixel units.
Da window manager will restrict tha windowz dimensions ta be
less than or equal ta \fIwidth\fR n' \fIheight\fR.
If \fIwidth\fR n' \fIheight\fR are
specified, then tha command returns a empty string.  Otherwise
it returns a Tcl list wit two elements, which is the
maximum width n' height currently up in effect.
Da maximum size defaults ta tha size of tha screen.
See tha sections on geometry pimpment below fo' mo' shiznit.
.TP
\fBwm minsize \fIwindow\fR ?\fIwidth height\fR?
If \fIwidth\fR n' \fIheight\fR is specified, they give the
minimum permissible dimensions fo' \fIwindow\fR.
For gridded windows tha dimensions is specified in
grid units;  otherwise they is specified up in pixel units.
Da window manager will restrict tha windowz dimensions ta be
greata than or equal ta \fIwidth\fR n' \fIheight\fR.
If \fIwidth\fR n' \fIheight\fR are
specified, then tha command returns a empty string.  Otherwise
it returns a Tcl list wit two elements, which is the
minimum width n' height currently up in effect.
Da minimum size defaults ta one pixel up in each dimension.
See tha sections on geometry pimpment below fo' mo' shiznit.
.TP
\fBwm overrideredirect \fIwindow\fR ?\fIboolean\fR?
If \fIboolean\fR is specified, it must gotz a proper boolean form and
the override-redirect flag fo' \fIwindow\fR is set ta dat value.
If \fIboolean\fR aint specified then \fB1\fR or \fB0\fR is
returned ta indicate whether or not tha override-redirect flag
is currently set fo' \fIwindow\fR.
Settin tha override-redirect flag fo' a window causes
it ta be ignored by tha window manager;  among other thangs, dis means
that tha window aint gonna be reparented from tha root window tha fuck into a
decoratizzle frame n' tha user aint gonna be able ta manipulate the
window rockin tha aiiight window manager mechanisms.
.TP
\fBwm positionfrom \fIwindow\fR ?\fIwho\fR?
If \fIwho\fR is specified, it must be either \fBprogram\fR or
\fBuser\fR, or a abbreviation of one of these two.  It indicates
whether \fIwindow\fRz current posizzle was axed by the
program or by tha user n' shit.  Many window managers ignore program-requested
initial positions n' ask tha user ta manually posizzle tha window;  if
\fBuser\fR is specified then tha window manager should posizzle the
window all up in tha given place without askin tha user fo' assistance.
If \fIwho\fR is specified as a empty string, then tha current position
source is shut down.
If \fIwho\fR is specified, then tha command returns a empty string.
Otherwise it returns \fBuser\fR or \fBprogram\fR ta indicate the
source of tha windowz current position, or a empty strang if
no source has been specified yet.  Most window managers interpret
.QW "no source"
as equivalent ta \fBprogram\fR.
Tk will automatically set tha posizzle source ta \fBuser\fR
when a \fBwm geometry\fR command is invoked, unless tha source has
been set explicitly ta \fBprogram\fR.
.TP
\fBwm protocol \fIwindow\fR ?\fIname\fR, biatch? ?\fIcommand\fR?
This command is used ta manage window manager protocols such as
\fBWM_DELETE_WINDOW\fR.
\fIName\fR is tha name of a atom correspondin ta a window manager
protocol, like fuckin \fBWM_DELETE_WINDOW\fR or \fBWM_SAVE_YOURSELF\fR
or \fBWM_TAKE_FOCUS\fR.
If both \fIname\fR n' \fIcommand\fR is specified, then \fIcommand\fR
is associated wit tha protocol specified by \fIname\fR.
\fIName\fR is ghon be added ta \fIwindow\fRz \fBWM_PROTOCOLS\fR
property ta tell tha window manager dat tha application has a
protocol handlez fo' \fIname\fR, n' \fIcommand\fR will
be invoked up in tha future whenever tha window manager sendz a
message ta tha client fo' dat protocol.
In dis case tha command returns a empty string.
If \fIname\fR is specified but \fIcommand\fR is not, then tha current
command fo' \fIname\fR is returned, or a empty strang if there
is no handlez defined fo' \fIname\fR.
If \fIcommand\fR is specified as a empty strang then tha current
handlez fo' \fIname\fR is deleted n' it is removed from the
\fBWM_PROTOCOLS\fR property on \fIwindow\fR;  a empty strang is
returned.
Lastly, if neither \fIname\fR nor \fIcommand\fR is specified, the
command returns a list of all tha protocols fo' which handlezs
are currently defined fo' \fIwindow\fR.
.RS
.PP
Tk always defines a protocol handlez fo' \fBWM_DELETE_WINDOW\fR, even if
you aint axed fo' one wit \fBwm protocol\fR.
If a \fBWM_DELETE_WINDOW\fR message arrives when you aint defined
a handlez, then Tk handlez tha message by beatin tha livin shiznit outta tha window for
which dat shiznit was received.
.RE
.TP
\fBwm resizable \fIwindow\fR ?\fIwidth height\fR?
This command controls whether or not tha user may interactively
resize a top-level window.  If \fIwidth\fR n' \fIheight\fR are
specified, they is boolean joints dat determine whether the
width n' height of \fIwindow\fR may be modified by tha user.
In dis case tha command returns a empty string.
If \fIwidth\fR n' \fIheight\fR is omitted then tha command
returns a list wit two 0/1 elements dat indicate whether the
width n' height of \fIwindow\fR is currently resizable.
By default, windows is resizable up in both dimensions.
If resizin is disabled, then tha windowz size is ghon be tha size
from da most thugged-out recent interactizzle resize or \fBwm geometry\fR
command. Y'all KNOW dat shit, muthafucka!  If there has been no such operation then
the windowz natural size is ghon be used.
.TP
\fBwm sizefrom \fIwindow\fR ?\fIwho\fR?
If \fIwho\fR is specified, it must be either \fBprogram\fR or
\fBuser\fR, or a abbreviation of one of these two.  It indicates
whether \fIwindow\fRz current size was axed by the
program or by tha user n' shit.  Some window managers ignore program-requested
sizes n' ask tha user ta manually size tha window;  if
\fBuser\fR is specified then tha window manager should give the
window its specified size without askin tha user fo' assistance.
If \fIwho\fR is specified as a empty string, then tha current size
source is shut down.
If \fIwho\fR is specified, then tha command returns a empty string.
Otherwise it returns \fBuser\fR or \fBwindow\fR ta indicate the
source of tha windowz current size, or a empty strang if
no source has been specified yet.  Most window managers interpret
.QW "no source"
as equivalent ta \fBprogram\fR.
.TP
\fBwm stackorder \fIwindow\fR ?\fBisabove\fR|\fBisbelow \fIwindow\fR?
Da \fBstackorder\fR command returns a list of toplevel windows
in stackin order, from lowest ta highest. When a single toplevel
window is passed, tha returned list recursively includes all of the
windowz lil pimps dat is toplevels. Only dem toplevels
that is currently mapped ta tha screen is returned.
Da \fBstackorder\fR command can also be used ta determine if one
toplevel is positioned above or below a second toplevel.
When two window arguments separated by either \fBisabove\fR or
\fBisbelow\fR is passed, a funky-ass boolean result indicates whether
or not tha straight-up original gangsta window is currently above or below tha second
window up in tha stackin order.
.TP
\fBwm state \fIwindow\fR ?newstate?
If \fInewstate\fR is specified, tha window is ghon be set ta tha freshly smoked up state,
otherwise it returns tha current state of \fIwindow\fR: either
\fBnormal\fR, \fBiconic\fR, \fBwithdrawn\fR, \fBicon\fR, or (Windows n' Mac
OS X only) \fBzoomed\fR.
Da difference between \fBiconic\fR n' \fBicon\fR is that
\fBiconic\fR refers ta a window dat has been iconified (e.g., wit the
\fBwm iconify\fR command) while \fBicon\fR refers ta a window whose only
purpose is ta serve as tha icon fo' some other window (via tha \fBwm
iconwindow\fR command).  Da \fBicon\fR state cannot be set.
.TP
\fBwm title \fIwindow\fR ?\fIstring\fR?
If \fIstring\fR is specified, then it is ghon be passed ta tha window
manager fo' use as tha title fo' \fIwindow\fR (the window manager
should display dis strang up in \fIwindow\fRz title bar).  In this
case tha command returns a empty string.  If \fIstring\fR is not
specified then tha command returns tha current title fo' the
\fIwindow\fR.  Da title fo' a window defaults ta its name.
.TP
\fBwm transient \fIwindow\fR ?\fImaster\fR?
If \fImaster\fR is specified, then tha window manager is informed
that \fIwindow\fR be a transient window (e.g. pull-down menu) working
on behalf of \fImaster\fR (where \fImaster\fR is the
path name fo' a top-level window).  If \fImaster\fR
is specified as a empty strang then \fIwindow\fR is marked as not
bein a transient window any mo' n' mo' n' mo'.  Otherwise tha command
returns tha path name of \fIwindow\fRz current master, or an
empty strang if \fIwindow\fR aint currently a transient window.
A transient window will mirror state chizzlez up in tha masta and
inherit tha state of tha masta when initially mapped. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be an
error ta attempt ta cook up a window a transient of itself.
.TP
\fBwm withdraw \fIwindow\fR
Arranges fo' \fIwindow\fR ta be withdrawn from tha screen. I aint talkin' bout chicken n' gravy biatch.  This
causes tha window ta be unmapped n' forgotten bout by tha window
manager n' shit.  If tha window
has never been mapped, then dis command
causes tha window ta be mapped up in tha withdrawn state.  Not all
window managers step tha fuck up ta know how tha fuck ta handle windows dat are
mapped up in tha withdrawn state.
Note: it sometimes seems ta be necessary ta withdraw a
window n' then re-map it (e.g. wit \fBwm deiconify\fR) ta git some
window managers ta pay attention ta chizzlez up in window attributes
like fuckin group.
.SH "GEOMETRY MANAGEMENT"
.PP
By default a top-level window appears on tha screen up in its
\fInatural size\fR, which is tha one determined internally by its
widgets n' geometry managers.
If tha natural size of a top-level window chizzles, then tha windowz size
changes ta match.
A top-level window can be given a size other than its natural size up in two ways.
First, tha user can resize tha window manually rockin tha facilities
of tha window manager, like fuckin resize handles.
Second, tha application can request a particular size fo' a
top-level window rockin tha \fBwm geometry\fR command.
These two cases is handled identically by Tk;  up in either case,
the axed size overrides tha natural size.
Yo ass can return tha window ta its natural by invokin \fBwm geometry\fR
with a empty \fIgeometry\fR string.
.PP
Normally a top-level window can have any size from one pixel up in each
dimension up ta tha size of its screen.
But fuck dat shiznit yo, tha word on tha street is dat you can use tha \fBwm minsize\fR n' \fBwm maxsize\fR commands
to limit tha range of allowable sizes.
Da range set by \fBwm minsize\fR n' \fBwm maxsize\fR applies to
all formz of resizing, includin tha windowz natural size as
well as manual resizes n' tha \fBwm geometry\fR command.
Yo ass can also use tha command \fBwm resizable\fR ta straight-up
disable interactizzle resizin up in one or both dimensions.
.PP
Da \fBwm manage\fR n' \fBwm forget\fR commandz may be used to
perform undockin n' dockin of windows.  Afta a widget is managed
by \fBwm manage\fR command, all other \fBwm\fR subcommandz may be used
with tha widget.  Only widgets pimped rockin tha toplevel command may
have a attached menu via tha \fB\-menu\fR configure option. I aint talkin' bout chicken n' gravy biatch.  A toplevel
widget may be used as a gangbangin' frame n' managed wit any of tha other
geometry managers afta rockin tha \fBwm forget\fR command. Y'all KNOW dat shit, muthafucka!  Any menu
associated wit a toplevel widget is ghon be hidden when managed by
another geometry managers.  Da menus will reappear once tha window is
managed by \fBwm\fR.  All custom bindtags fo' widgets up in a subtree
that have they top-level widget chizzled via a \fBwm manage\fR or
\fBwm forget\fR command, must be redone ta adjust any top-level widget
path up in tha bindtags. Bindtags dat aint been customized do not
have ta be redone.
.SH "GRIDDED GEOMETRY MANAGEMENT"
.PP
Gridded geometry pimpment occurs when one of tha widgetz of an
application supports a range of useful sizes.
This occurs, fo' example, up in a text editor where tha scrollbars,
menus, n' other adornments is fixed up in size but tha edit widget
can support any number of linez of text or charactas per line.
In dis case, it is probably desirable ta let tha user specify the
number of lines or characters-per-line, either wit the
\fBwm geometry\fR command or by interactively resizin tha window.
In tha case of text, n' up in other bangin-ass cases also, only
discrete sizez of tha window make sense, like fuckin integral numbers
of lines n' characters-per-line;  arbitrary pixel sizes is not useful.
.PP
Gridded geometry pimpment serves up support fo' dis kind of
application.
Tk (and tha window manager) assume dat there be a grid of some
sort within tha application n' dat tha application should be
resized up in termz of \fIgrid units\fR rather than pixels.
Gridded geometry pimpment is typically invoked by turnin on
the \fBsetGrid\fR option fo' a widget;  it can also be invoked
with tha \fBwm grid\fR command or by callin \fBTk_SetGrid\fR.
In each of these approaches tha particular widget (or sometimes
code up in tha application as a whole) specifies tha relationshizzle between 
integral grid sizes fo' tha window n' pixel sizes.
To return ta non-gridded geometry pimpment, invoke
\fBwm grid\fR wit empty argument strings.
.PP
When gridded geometry pimpment is enabled then all tha dimensions specified
in \fBwm minsize\fR, \fBwm maxsize\fR, n' \fBwm geometry\fR commands
are treated as grid units rather than pixel units.
Interactizzle resizin be also carried up in even numberz of grid units
rather than pixels.
.SH BUGS
.PP
Most existin window managers step tha fuck up ta have bugs dat affect the
operation of tha \fBwm\fR command. Y'all KNOW dat shit, muthafucka!  For example, some chizzlez will not
take effect if tha window be already active:  tha window will have
to be withdrawn n' de-iconified up in order ta make tha chizzle happen.
.SH EXAMPLES
A fixed-size window dat say dat it is fixed-size too:
.CS
toplevel .fixed
\fBwm title\fR     .fixed "Fixed-size Window"
\fBwm resizable\fR .fixed 0 0
.CE
.PP
A simple dialog-like window, centred on tha screen:
.CS
# Smoke n' arrange tha dialog contents.
toplevel .msg
label  .msg.l  \-text "This be a straight-up simple dialog demo."
button .msg.ok \-text OK \-default actizzle \-command {destroy .msg}
pack .msg.ok \-side bottom \-fill x
pack .msg.l  \-expand 1    \-fill both

# Now set tha widget up as a cold-ass lil centred dialog.

# But first, we need tha geometry managers ta finish setting
# up tha interior of tha dialog, fo' which we need ta run the
# event loop wit tha widget hidden straight-up...
\fBwm withdraw\fR .msg
update
set x [expr {([winfo screenwidth .]\-[winfo width .msg])/2}]
set y [expr {([winfo screenheight .]\-[winfo height .msg])/2}]
\fBwm geometry\fR  .msg +$x+$y
\fBwm transient\fR .msg .
\fBwm title\fR     .msg "Dialog demo"
\fBwm deiconify\fR .msg
.CE
.SH "SEE ALSO"
toplevel(n), winfo(n)
.SH KEYWORDS
aspect ratio, deiconify, focus model, geometry, grid, group, icon, iconify, increments, position, size, title, top-level window, units, window manager
