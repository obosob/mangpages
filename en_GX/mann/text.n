'\"
'\" Copyright (c) 1992 Da Regentz of tha Universitizzle of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
'\" 
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type, biatch? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version, biatch? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH text n 8.5 Tk "Tk Built-In Commands"
.BS
'\" Note:  do not modify tha .SH NAME line immediately below!
.SH NAME
text, tk_textCopy, tk_textCut, tk_textPaste \- Smoke n' manipulate text widgets
.SH SYNOPSIS
.nf
\fBtext\fR \fIpathName \fR?\fIoptions\fR?
\fBtk_textCopy\fR \fIpathName\fR
\fBtk_textCut\fR \fIpathName\fR
\fBtk_textPaste\fR \fIpathName\fR
.SO
\-background	\-highlightthickness	\-relief
\-borderwidth	\-insertbackground	\-selectbackground
\-cursor	\-insertborderwidth	\-selectborderwidth
\-exportselection	\-insertofftime	\-selectforeground
\-font	\-insertontime	\-setgrid
\-foreground	\-insertwidth	\-takefocus
\-highlightbackground	\-padx	\-xscrollcommand
\-highlightcolor	\-pady	\-yscrollcommand
.SE
.SH "WIDGET-SPECIFIC OPTIONS"
.OP \-autoseparators autoSeparators AutoSeparators
Specifies a funky-ass boolean dat say whether separators is automatically
inserted up in tha undo stack. Only meaningful when tha \fB\-undo\fR
option is true.
.OP \-blockcursor blockCursor BlockCursor
.VS 8.5
Specifies a funky-ass boolean dat say whether tha blinkin insertion cursor
should be drawn as a cold-ass lil character-sized rectangular block.  If false
(the default) a thin vertical line is used fo' tha insertion cursor.
.VE 8.5
.OP \-endline endLine EndLine
.VS 8.5
Specifies a integer line index representin tha line of tha underlying
textual data store dat should be just afta tha last line contained in
the widget.
This allows a text widget ta reflect only a portion of a larger piece
of text.   Instead of a integer, tha empty strang can be provided to
this configuration option, which will configure tha widget ta end
at tha straight-up last line up in tha textual data store.
.VE 8.5
.OP \-height height Height
Specifies tha desired height fo' tha window, up in unitz of characters
in tha font given by tha \fB\-font\fR option.
Must be at least one.
.OP \-inactiveselectbackground inactiveSelectBackground Foreground
.VS 8.5
Specifies tha colour ta use fo' tha selection (the \fBsel\fR tag) when
the window aint gots tha input focus.  If empty, \fB{}\fR, then no
selection is shown when tha window aint gots tha focus.
.VE 8.5
.OP \-maxundo maxUndo MaxUndo
Specifies tha maximum number of compound undo actions on tha undo
stack fo' realz. A zero or a wack value imply a unlimited undo stack.
.OP \-spacing1 spacing1 Spacing1
Requests additionizzle space above each text line up in tha widget,
usin any of tha standard forms fo' screen distances.
If a line wraps, dis option only applies ta tha straight-up original gangsta line
on tha display.
This option may be overridden wit \fB\-spacing1\fR options in
tags.
.OP \-spacing2 spacing2 Spacing2
For lines dat wrap (so dat they cover mo' than one line on the
display) dis option specifies additionizzle space ta provide between
the display lines dat represent a single line of text.
Da value may have any of tha standard forms fo' screen distances.
This option may be overridden wit \fB\-spacing2\fR options in
tags.
.OP \-spacing3 spacing3 Spacing3
Requests additionizzle space below each text line up in tha widget,
usin any of tha standard forms fo' screen distances.
If a line wraps, dis option only applies ta tha last line
on tha display.
This option may be overridden wit \fB\-spacing3\fR options in
tags.
.OP \-startline startLine StartLine
.VS 8.5
Specifies a integer line index representin tha straight-up original gangsta line of the
underlyin textual data store dat should be contained up in tha widget.
This allows a text widget ta reflect only a portion of a larger piece
of text.  Instead of a integer, tha empty strang can be provided to
this configuration option, which will configure tha widget ta start
at tha straight-up first line up in tha textual data store.
.VE 8.5
.OP \-state state State
Specifies one of two states fo' tha text:  \fBnormal\fR or \fBdisabled\fR.
If tha text is disabled then charactas may not be banged or deleted
and no insertion cursor is ghon be displayed, even if tha input focus is
in tha widget.
.OP \-tabs tabs Tabs
Specifies a set of tab stops fo' tha window.  Da optionz value consists
of a list of screen distances givin tha positionz of tha tab stops,
each of which be a gangbangin' finger-lickin' distizzle relatizzle ta tha left edge of tha widget
(excludin borders, padding, etc).  Each
posizzle may optionally be followed up in tha next list element
by one of tha keywordz \fBleft\fR, \fBright\fR, \fBcenter\fR,
or \fBnumeric\fR, which specifies how tha fuck ta justify
text relatizzle ta tha tab stop.  \fBLeft\fR is tha default; it causes
the text followin tha tab characta ta be positioned wit its left edge
at tha tab position. I aint talkin' bout chicken n' gravy biatch.  \fBRight\fR means dat tha right edge of tha text
followin tha tab characta is positioned all up in tha tab position, and
\fBcenter\fR means dat tha text is centered all up in tha tab position.
\fBNumeric\fR means dat tha decimal point up in tha text is positioned
at tha tab position;  if there is no decimal point then tha least
significant digit of tha number is positioned just ta tha left of the
tab position;  if there is no number up in tha text then tha text is
right-justified all up in tha tab position.
For example,
.QW "\fB\-tabs {2c left 4c 6c center}\fR"
creates three tab stops at two-centimeta intervals;  tha straight-up original gangsta two use left
justification n' tha third uses centa justification.
.RS
.PP
If tha list of tab stops aint gots enough elements ta cover all
of tha tabs up in a text line, then Tk extrapolates freshly smoked up tab stops using
the spacin n' alignment from tha last tab stop up in tha list.  Tab
distances must be strictly positive, n' must always increase from one
tab stop ta tha next (if not, a error is thrown).
Da value of tha \fBtabs\fR option may be overridden by \fB\-tabs\fR
options up in tags.
.PP
If no \fB\-tabs\fR option is specified, or if it is specified as
an empty list, then Tk uses default tabs spaced every last muthafuckin eight
(average size) characters.  To big up a gangbangin' finger-lickin' different standard spacing,
for example every last muthafuckin 4 characters, simply configure tha widget with
.QW "\fB\-tabs \N'34'[expr {4 * [font measure $font 0]}] left\N'34' \-tabstyle wordprocessor\fR" .
.RE
.OP \-tabstyle tabStyle TabStyle
Specifies how tha fuck ta interpret tha relationshizzle between tab stops on a line
and tabs up in tha text of dat line.  Da value must be \fBtabular\fR (the
default) or \fBwordprocessor\fR. Note dat tabs is interpreted as they
are encountered up in tha text.  If tha tab steez is \fBtabular\fR then the
\fIn\fR'th tab characta up in tha linez text is ghon be associated with
the \fIn\fR'th
tab stop defined fo' dat line.  If tha tab characterz x coordinate
falls ta tha right of tha \fIn\fR'th tab stop, then a gap of a single space
will be banged as a gangbangin' fallback.  If tha tab steez is \fBwordprocessor\fR
then any tab characta bein laid up will use (and be defined by) the
first tab stop ta tha right of tha precedin charactas already laid out
on dat line.  Da value of tha \fBtabstyle\fR option may be overridden
by \fB\-tabstyle\fR options up in tags.
.OP \-undo undo Undo
Specifies a funky-ass boolean dat say whether tha undo mechanizzle be actizzle or
not.
.OP \-width width Width
Specifies tha desired width fo' tha window up in unitz of characters
in tha font given by tha \fB\-font\fR option.
If tha font aint gots a uniform width then tha width of tha character
.QW 0
is used up in translatin from characta units ta screen units.
.OP \-wrap wrap Wrap
Specifies how tha fuck ta handle lines up in tha text dat is too long ta be
displayed up in a single line of tha textz window.
Da value must be \fBnone\fR or \fBchar\fR or \fBword\fR.
A wrap mode of \fBnone\fR means dat each line of text appears as
exactly one line on tha screen;  extra charactas dat do not fit
on tha screen is not displayed.
In tha other modes each line of text is ghon be fucked up tha fuck into several
screen lines if necessary ta keep all tha charactas visible.
In \fBchar\fR mode a screen line break may occur afta any character;
in \fBword\fR mode a line break will only be made at word boundaries.
.BE

.SH DESCRIPTION
.PP
Da \fBtext\fR command creates a freshly smoked up window (given by the
\fIpathName\fR argument) n' make it tha fuck into a text widget.
Additional
options, busted lyrics bout above, may be specified on tha command line
or up in tha option database
to configure aspectz of tha text like fuckin its default background color
and relief.  Da \fBtext\fR command returns the
path name of tha freshly smoked up window.
.PP
A text widget displays one or mo' linez of text n' allows that
text ta be edited.
Text widgets support four different kindz of annotations on the
text, called tags, marks, embedded windows or embedded images.
Tags allow different portionz of tha text
to be displayed wit different fonts n' colors.
In addition, Tcl commandz can be associated wit tags so
that scripts is invoked when particular actions like fuckin keystrokes
and mouse button presses occur up in particular rangez of tha text.
See \fBTAGS\fR below fo' mo' details.
.PP
Da second form of annotation consistz of floatin markers up in tha text
called
.QW marks .
Marks is used ta keep track of various bangin-ass positions up in the
text as it is edited.
See \fBMARKS\fR below fo' mo' details.
.PP
Da third form of annotation allows arbitrary windows ta be
embedded up in a text widget.
See \fBEMBEDDED WINDOWS\fR below fo' mo' details.
.PP
Da fourth form of annotation allows Tk images ta be embedded up in a text
widget.
See \fBEMBEDDED IMAGES\fR below fo' mo' details.
.PP
Da text widget also has a funky-ass built-in undo/redo mechanism.
See \fBTHE UNDO MECHANISM\fR below fo' mo' details.
.PP
.VS 8.5
Da text widget allows fo' tha creation of peer widgets, n' you can put dat on yo' toast.  These are
other text widgets which share tha same underlyin data (text, marks,
tags, images, etc).  See \fBPEER WIDGETS\fR below fo' mo' details.
.VE 8.5
.SH INDICES
.PP
Many of tha widget commandz fo' texts take one or mo' indices
as arguments.
An index be a strang used ta indicate a particular place within
a text, like fuckin a place ta bang charactas or one endpoint of a
range of charactas ta delete.
Indices have tha syntax
.CS
\fIbase modifier modifier modifier ...\fR
.CE
Where \fIbase\fR gives a startin point n' tha \fImodifier\fRs
adjust tha index from tha startin point (e.g. move forward or
backward one character).  Every index must contain a \fIbase\fR,
but tha \fImodifier\fRs is optional.
.VS 8.5
Most modifiers (as documented below) allow
an optionizzle submodifier n' shit.  Valid submodifiers is \fBany\fR
and \fBdisplay\fR. If tha submodifier be abbreviated, then it must be
followed by whitespace yo, but otherwise there need be no space between the
submodifier n' tha followin \fImodifier\fR.  Typically tha \fBdisplay\fR
submodifier adjusts tha meanin of tha followin \fImodifier\fR ta make
it refer ta visual or non-elided units rather than logical units yo, but
this is explained fo' each relevant case below.  Lastly, where \fIcount\fR
is used as part of a modifier, it can be positizzle or negative, so
.QW "\fIbase\fR \- \-3 lines"
is perfectly valid (and equivalent to
.QW "\fIbase\fR +3lines" ).
.VE 8.5
.PP
Da \fIbase\fR fo' a index must have one of tha followin forms:
.TP 12
\fIline\fB.\fIchar\fR
Indicates \fIchar\fR'th characta on line \fIline\fR.
Lines is numbered from 1 fo' consistency wit other UNIX programs
that use dis numberin scheme.
Within a line, charactas is numbered from 0.
If \fIchar\fR is \fBend\fR then it refers ta tha newline character
that endz tha line.
.TP 12
\fB@\fIx\fB,\fIy\fR
Indicates tha characta dat covers tha pixel whose x n' y coordinates
within tha textz window is \fIx\fR n' \fIy\fR.
.TP 12
\fBend\fR
Indicates tha end of tha text (the characta just afta tha last
newline).
.TP 12
\fImark\fR
Indicates tha characta just afta tha mark whose name is \fImark\fR.
.TP 12
\fItag\fB.first\fR
Indicates tha straight-up original gangsta characta up in tha text dat has been tagged with
\fItag\fR.
This form generates a error if no charactas is currently tagged
with \fItag\fR.
.TP 12
\fItag\fB.last\fR
Indicates tha characta just afta tha last one up in tha text dat has
been tagged wit \fItag\fR.
This form generates a error if no charactas is currently tagged
with \fItag\fR.
.TP 12
\fIpathName\fR
Indicates tha posizzle of tha embedded window whose name is
\fIpathName\fR.
This form generates a error if there is no embedded window
by tha given name.
.TP 12
\fIimageName\fR
Indicates tha posizzle of tha embedded image whose name is
\fIimageName\fR.
This form generates a error if there is no embedded image
by tha given name.
.PP
If tha \fIbase\fR could match mo' than one of tha above forms, such
as a \fImark\fR n' \fIimageName\fR both havin tha same value, then
the form earlier up in tha above list takes precedence.
If modifiers follow tha base index, each one of dem must have one
of tha forms listed below.  Keywordz like fuckin \fBchars\fR n' \fBwordend\fR
may be abbreviated as long as tha abbreviation is unambiguous.
.TP
\fB+ \fIcount\fR ?\fIsubmodifier\fR, biatch? \fBchars\fR
.VS 8.5
Adjust tha index forward by \fIcount\fR characters, movin ta lata lines
in tha text if necessary.  If there be fewer than \fIcount\fR characters
in tha text afta tha current index, then set tha index ta tha last index
in tha text.  Spaces on either side of \fIcount\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If the
\fBdisplay\fR submodifier is given, elided charactas is skipped over
without bein counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fBany\fR is given, then all charactas are
counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For oldschool reasons, if neither modifier is given then the
count straight-up takes place up in unitz of index positions (see \fBindices\fR
for details).  This behaviour may be chizzled up in a gangbangin' future major release,
so if you need a index count, yo ass is encouraged ta use \fBindices\fR
instead wherever possible.
.VE 8.5
.TP
\fB\- \fIcount\fR ?\fIsubmodifier\fR, biatch? \fBchars\fR
Adjust tha index backward by \fIcount\fR characters, movin ta earlier
lines up in tha text if necessary.  If there be fewer than \fIcount\fR
charactas up in tha text before tha current index, then set tha index to
.VS 8.5
the first index up in tha text (1.0).  Spaces on either side of \fIcount\fR
are optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha \fBdisplay\fR submodifier is given, elided
charactas is skipped over without bein counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fBany\fR is
given, then all charactas is counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For oldschool reasons, if
neither modifier is given then tha count straight-up takes place up in units of
index positions (see \fBindices\fR fo' details).  This behaviour may be
changed up in a gangbangin' future major release, so if you need a index count, yo ass is
encouraged ta use \fBindices\fR instead wherever possible.
.VE 8.5
.TP
\fB+ \fIcount\fR ?\fIsubmodifier\fR, biatch? \fBindices\fR
.VS 8.5
Adjust tha index forward by \fIcount\fR index positions, movin ta later
lines up in tha text if necessary.  If there be fewer than \fIcount\fR
index positions up in tha text afta tha current index, then set tha index
to tha last index posizzle up in tha text.  Spaces on either side of
\fIcount\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Note dat a index posizzle is either a single
characta or a single embedded image or embedded window.  If the
\fBdisplay\fR submodifier is given, elided indices is skipped over
without bein counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fBany\fR is given, then all indices are
counted; dis be also tha default behaviour if no modifier is given.
.VE 8.5
.TP
\fB\- \fIcount\fR ?\fIsubmodifier\fR, biatch? \fBindices\fR
.VS 8.5
Adjust tha index backward by \fIcount\fR index positions, movin to
earlier lines up in tha text if necessary.  If there be fewer than
\fIcount\fR index positions up in tha text before tha current index, then
set tha index ta tha straight-up original gangsta index posizzle (1.0) up in tha text.  Spaces on
either side of \fIcount\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha \fBdisplay\fR
submodifier is given, elided indices is skipped over without being
counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fBany\fR is given, then all indices is counted; dis is
also tha default behaviour if no modifier is given.
.VE 8.5
.TP
\fB+ \fIcount\fR ?\fIsubmodifier\fR, biatch? \fBlines\fR
.VS 8.5
Adjust tha index forward by \fIcount\fR lines, retainin tha same
characta posizzle within tha line.  If there be fewer than \fIcount\fR
lines afta tha line containin tha current index, then set tha index to
refer ta tha same characta posizzle on tha last line of tha text.  Then,
if tha line aint long enough ta contain a cold-ass lil characta all up in tha indicated
characta position, adjust tha characta posizzle ta refer ta tha last
characta of tha line (the newline).  Spaces on either side of
\fIcount\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha \fBdisplay\fR submodifier is given,
then each visual display line is counted separately.  Otherwise, if
\fBany\fR (or no modifier) is given, then each logical line (no matter
how nuff times it is visually wrapped) counts just once.  If tha relevant
lines is not wrapped, then these two methodz of countin is equivalent.
.VE 8.5
.TP
\fB\- \fIcount\fR ?\fIsubmodifier\fR, biatch? \fBlines\fR
.VS 8.5
Adjust tha index backward by \fIcount\fR logical lines, retainin the
same characta posizzle within tha line.  If there be fewer than
\fIcount\fR lines before tha line containin tha current index, then set
the index ta refer ta tha same characta posizzle on tha straight-up original gangsta line of
the text.  Then, if tha line aint long enough ta contain a cold-ass lil characta at
the indicated characta position, adjust tha characta posizzle ta refer
to tha last characta of tha line (the newline).  Spaces on either side
of \fIcount\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha \fBdisplay\fR submodifier is given,
then each visual display line is counted separately.  Otherwise, if
\fBany\fR (or no modifier) is given, then each logical line (no matter
how nuff times it is visually wrapped) counts just once.  If tha relevant
lines is not wrapped, then these two methodz of countin is equivalent.
.VE 8.5
.TP
?\fIsubmodifier\fR, biatch? \fBlinestart\fR
.VS 8.5
Adjust tha index ta refer ta tha straight-up original gangsta index on tha line.  If the
\fBdisplay\fR submodifier is given, dis is tha straight-up original gangsta index on the
display line, otherwise on tha logical line.
.VE 8.5
.TP
?\fIsubmodifier\fR, biatch? \fBlineend\fR
.VS 8.5
Adjust tha index ta refer ta tha last index on tha line (the
newline).  If tha \fBdisplay\fR submodifier is given, dis is tha last
index on tha display line, otherwise on tha logical line.
.VE 8.5
.TP
?\fIsubmodifier\fR, biatch? \fBwordstart\fR
.VS 8.5
Adjust tha index ta refer ta tha straight-up original gangsta characta of tha word containing
the current index.  A word consistz of any number of adjacent characters
that is letters, digits, or underscores, or a single characta dat is
not one of these n' you can put dat on yo' toast.  If tha \fBdisplay\fR submodifier is given, dis only
examines non-elided characters, otherwise all charactas (elided or not)
are examined.
.VE 8.5
.TP
?\fIsubmodifier\fR, biatch? \fBwordend\fR
.VS 8.5
Adjust tha index ta refer ta tha characta just afta tha last one of the
word containin tha current index.  If tha current index refers ta the
last characta of tha text then it aint modified. Y'all KNOW dat shit, muthafucka!  If tha \fBdisplay\fR
submodifier is given, dis only examines non-elided characters, otherwise
all charactas (elided or not) is examined.
.PP
If mo' than one modifier is present then they is applied in
left-to-right order n' shit.  For example, tha index
.QW "\fBend \- 1 chars\fR"
refers ta tha next-to-last characta up in tha text and
.QW "\fBinsert lyricstart \- 1 c\fR"
refers ta tha characta just before
the first one up in tha word containin tha insertion cursor. Shiiit, dis aint no joke.  Modifiers
are applied one by one up in dis left ta right order, n' afta each step
the resultin index is constrained ta be a valid index up in tha text
widget.  So, fo' example, tha index
.QW "\fB1.0 \-1c +1c\fR"
refers ta tha index
.QW \fB2.0\fR .
.PP
Where modifiers result up in index chizzlez by display lines, display chars
or display indices, n' tha \fIbase\fR refers ta a index inside an
elided tag,
that base index is considered ta be equivalent ta tha straight-up original gangsta following
non-elided index.
.VE 8.5
.SH TAGS
.PP
Da first form of annotation up in text widgets be a tag.
A tag be a textual strang dat be associated wit a shitload of tha characters
in a text.
Tags may contain arbitrary charactas yo, but it is probably dopest to
avoid rockin tha characters
.QW " "
(space), \fB+\fR, or \fB\-\fR:
these charactas have special meanin up in indices, so tags containing
them cannot be used as indices.
There may be any number of tags associated wit charactas up in a
text.
Each tag may refer ta a single character, a range of characters, or
several rangez of characters.
An individual characta may have any number of tags associated wit dat shit.
.PP
A prioritizzle order is defined among tags, n' dis order is used in
implementin a shitload of tha tag-related functions busted lyrics bout below.
When a tag is defined (by associatin it wit charactas or setting
its display options or bindin commandz ta it), it is given
a prioritizzle higher than any existin tag.
Da prioritizzle order of tags may be redefined rockin the
.QW "\fIpathName \fBtag raise\fR"
and
.QW "\fIpathName \fBtag lower\fR"
widget commands.
.PP
Tags serve three purposes up in text widgets.
First, they control tha way shiznit is displayed on tha screen.
By default, charactas is displayed as determined by the
\fB\-background\fR, \fB\-font\fR, n' \fB\-foreground\fR options fo' the
text widget.
But fuck dat shiznit yo, tha word on tha street is dat display options may be associated wit individual tags
usin the
.QW "\fIpathName \fBtag configure\fR"
widget command.
If a cold-ass lil characta has been tagged, then tha display options associated
with tha tag override tha default display style.
Da followin options is currently supported fo' tags:
.TP
\fB\-background \fIcolor\fR
\fIColor\fR specifies tha background color ta use fo' characters
associated wit tha tag.
It may have any of tha forms accepted by \fBTk_GetColor\fR.
.TP
\fB\-bgstipple \fIbitmap\fR
\fIBitmap\fR specifies a funky-ass bitmap dat is used as a stipple pattern
for tha background.
It may have any of tha forms accepted by \fBTk_GetBitmap\fR.
If \fIbitmap\fR has not been specified, or if it is specified
as a empty string, then a solid fill is ghon be used fo' the
background.
.TP
\fB\-borderwidth \fIpixels\fR
\fIPixels\fR specifies tha width of a 3-D border ta draw around
the background.
It may have any of tha forms accepted by \fBTk_GetPixels\fR.
This option is used up in conjunction wit tha \fB\-relief\fR
option ta give a 3-D appearizzle ta tha background fo' characters;
it is ignored unless tha \fB\-background\fR option
has been set fo' tha tag.
.TP
\fB\-elide \fIboolean\fR
\fIElide\fR specifies whether tha data should
be elided. Y'all KNOW dat shit, muthafucka!  Elided data (characters, images, embedded windows, etc) is
not displayed n' takes no space on screen yo, but further on behaves just
as aiiight data.
.TP
\fB\-fgstipple \fIbitmap\fR
\fIBitmap\fR specifies a funky-ass bitmap dat is used as a stipple pattern
when drawin text n' other foreground shiznit such as
underlines.
It may have any of tha forms accepted by \fBTk_GetBitmap\fR.
If \fIbitmap\fR has not been specified, or if it is specified
as a empty string, then a solid fill is ghon be used.
.TP
\fB\-font \fIfontName\fR
\fIFontName\fR is tha name of a gangbangin' font ta use fo' drawin characters.
It may have any of tha forms accepted by \fBTk_GetFont\fR.
.TP
\fB\-foreground \fIcolor\fR
\fIColor\fR specifies tha color ta use when drawin text n' other
foreground shiznit like fuckin underlines.
It may have any of tha forms accepted by \fBTk_GetColor\fR.
.TP
\fB\-justify \fIjustify\fR
If tha straight-up original gangsta non-elided characta of a gangbangin' finger-lickin' display line has a tag fo' which this
option has been specified, then \fIjustify\fR determines how tha fuck to
justify tha line.
It must be one of \fBleft\fR, \fBright\fR, or \fBcenter\fR.
If a line wraps, then tha justification fo' each line on the
display is determined by tha straight-up original gangsta non-elided characta of dat display line.
.TP
\fB\-lmargin1 \fIpixels\fR
If tha straight-up original gangsta non-elided characta of a text line has a tag fo' which this
option has been specified, then \fIpixels\fR specifies how
much tha line should be indented from tha left edge of the
window.
\fIPixels\fR may have any of tha standard forms fo' screen
distances.
If a line of text wraps, dis option only applies ta the
first line on tha display;  tha \fB\-lmargin2\fR option controls
the indentation fo' subsequent lines.
.TP
\fB\-lmargin2 \fIpixels\fR
If tha straight-up original gangsta non-elided characta of a gangbangin' finger-lickin' display line has a tag fo' which this
option has been specified, n' if tha display line aint the
first fo' its text line (i.e., tha text line has wrapped), then
\fIpixels\fR specifies how tha fuck much tha line should be indented from
the left edge of tha window.
\fIPixels\fR may have any of tha standard forms fo' screen
distances.
This option is only used when wrappin is enabled, n' it only
applies ta tha second n' lata display lines fo' a text line.
.TP
\fB\-offset \fIpixels\fR
\fIPixels\fR specifies a amount by which tha textz baseline
should be offset vertically from tha baseline of tha overall
line, up in pixels.
For example, a positizzle offset can be used fo' superscripts
and a wack offset can be used fo' subscripts.
\fIPixels\fR may have any of tha standard forms fo' screen
distances.
.TP
\fB\-overstrike \fIboolean\fR
Specifies whether or not ta draw a horizontal rule through
the middle of characters.
\fIBoolean\fR may have any of tha forms accepted by \fBTcl_GetBoolean\fR.
.TP
\fB\-relief \fIrelief\fR
\fIRelief\fR specifies tha 3-D relief ta use fo' drawin backgrounds,
in any of tha forms accepted by \fBTk_GetRelief\fR.
This option is used up in conjunction wit tha \fB\-borderwidth\fR
option ta give a 3-D appearizzle ta tha background fo' characters;
it is ignored unless tha \fB\-background\fR option
has been set fo' tha tag.
.TP
\fB\-rmargin \fIpixels\fR
If tha straight-up original gangsta non-elided characta of a gangbangin' finger-lickin' display line has a tag fo' which this
option has been specified, then \fIpixels\fR specifies how tha fuck wide
a margin ta leave between tha end of tha line n' tha right
edge of tha window.
\fIPixels\fR may have any of tha standard forms fo' screen
distances.
This option is only used when wrappin is enabled.
If a text line wraps, tha right margin fo' each line on the
display is determined by tha straight-up original gangsta non-elided characta of dat display
line.
.TP
\fB\-spacing1 \fIpixels\fR
\fIPixels\fR specifies how tha fuck much additionizzle space should be
left above each text line, rockin any of tha standard forms for
screen distances.
If a line wraps, dis option only applies ta tha first
line on tha display.
.TP
\fB\-spacing2 \fIpixels\fR
For lines dat wrap, dis option specifies how tha fuck much additional
space ta leave between tha display lines fo' a single text line.
\fIPixels\fR may have any of tha standard forms fo' screen
distances.
.TP
\fB\-spacing3 \fIpixels\fR
\fIPixels\fR specifies how tha fuck much additionizzle space should be
left below each text line, rockin any of tha standard forms for
screen distances.
If a line wraps, dis option only applies ta tha last
line on tha display.
.TP
\fB\-tabs \fItabList\fR
\fITabList\fR specifies a set of tab stops up in tha same form
as fo' tha \fB\-tabs\fR option fo' tha text widget.  This
option only applies ta a gangbangin' finger-lickin' display line if it applies ta the
first non-elided characta on dat display line.
If dis option is specified as a empty string, it cancels
the option, leavin it unspecified fo' tha tag (the default).
If tha option is specified as a non-empty strang dat is
an empty list, like fuckin \fB\-tags\0{\0}\fR, then it requests
default 8-characta tabs as busted lyrics bout fo' tha \fB\-tags\fR
widget option.
.TP
\fB\-tabstyle \fIstyle\fR
\fIStyle\fR specifies either tha \fItabular\fR or
\fIwordprocessor\fR steez of tabbin ta use fo' tha text widget.
This option only applies ta a gangbangin' finger-lickin' display line if it applies ta the
first non-elided characta on dat display line.
If dis option is specified as a empty string, it cancels
the option, leavin it unspecified fo' tha tag (the default).
.TP
\fB\-underline \fIboolean\fR
\fIBoolean\fR specifies whether or not ta draw a underline underneath
characters.
It may have any of tha forms accepted by \fBTcl_GetBoolean\fR.
.TP
\fB\-wrap \fImode\fR
\fIMode\fR specifies how tha fuck ta handle lines dat is wider than the
textz window.
It has tha same ol' dirty legal joints as tha \fB\-wrap\fR option
for tha text widget:  \fBnone\fR, \fBchar\fR, or \fBword\fR.
If dis tag option is specified, it overrides tha \fB\-wrap\fR option
for tha text widget.
.PP
If a cold-ass lil characta has nuff muthafuckin tags associated wit it, n' if their
display options conflict, then tha optionz of tha highest priority
tag is used.
If a particular display option has not been specified fo' a
particular tag, or if it is specified as a empty string, then
that option aint NEVER gonna be used;  tha next-highest-priority
tagz option will used instead.
If no tag specifies a particular display option, then tha default
style fo' tha widget is ghon be used.
.PP
Da second purpose fo' tags is event bindings.
Yo ass can associate bindings wit a tag up in much tha same way you can
associate bindings wit a widget class:  whenever particular X
events occur on charactas wit tha given tag, a given
Tcl command is ghon be executed.
Tag bindings can be used ta give behaviors ta rangez of characters;
among other thangs, dis allows hypertext-like
features ta be implemented.
For details, peep tha description of the
.QW "\fIpathName \fBtag bind\fR"
widget command below.
.VS 8.5
Tag bindings is shared between all peer widgets
(includin any bindings fo' tha special \fBsel\fR tag).
.VE 8.5
.PP
Da third use fo' tags is up in managin tha selection.
See \fBTHE SELECTION\fR below.
.VS 8.5
With tha exception of tha special \fBsel\fR
tag, all tags is shared between peer text widgets, n' may be
manipulated on a equal basis from any such widget.  Da \fBsel\fR
tag exists separately n' independently up in each peer text widget (but
any tag bindings ta \fBsel\fR is shared).
.VE 8.5
.SH MARKS
.PP
Da second form of annotation up in text widgets be a mark.
Marks is used fo' rememberin particular places up in a text.
They is suttin' like tags, up in dat they have names and
they refer ta places up in tha file yo, but a mark aint associated
with particular characters.
Instead, a mark be associated wit tha gap between two characters.
Only a single posizzle may be associated wit a mark at any given
time.
If tha charactas round a mark is deleted tha mark will still
remain;  it will just have freshly smoked up neighbor characters.
In contrast, if tha charactas containin a tag is deleted then
the tag will no longer have a association wit charactas in
the file.
Marks may be manipulated wit the
.QW "\fIpathName \fBmark\fR"
widget
command, n' they current locations may be determined by rockin the
mark name as a index up in widget commands.
.PP
Each mark also has a
.QW gravitizzle ,
which is either \fBleft\fR or \fBright\fR.
Da gravitizzle fo' a mark specifies what tha fuck happens ta tha mark when
text is banged all up in tha deal wit tha mark.
If a mark has left gravity, then tha mark is treated as if it
were attached ta tha characta on its left, so tha mark will
remain ta tha left of any text banged all up in tha mark position.
If tha mark has right gravity, freshly smoked up text banged all up in tha mark
posizzle will step tha fuck up ta tha left of tha mark (so dat tha mark
remains rightmost).  Da gravitizzle fo' a mark defaults ta \fBright\fR.
.PP
Da name space fo' marks is different from dat fo' tags:  the
same name may be used fo' both a mark n' a tag yo, but they will refer
to different thangs.
.PP
Two marks have special significance.
First, tha mark \fBinsert\fR be associated wit tha insertion cursor,
as busted lyrics bout under \fBTHE INSERTION CURSOR\fR below.
Second, tha mark \fBcurrent\fR be associated wit tha character
closest ta tha mouse n' be adjusted automatically ta track the
mouse posizzle n' any chizzlez ta tha text up in tha widget (one
exception:  \fBcurrent\fR aint updated up in response ta mouse
motions if a mouse button is down;  tha update is ghon be deferred
until all mouse buttons done been busted out).
Neither of these special marks may be deleted.
.VS 8.5
With tha exception of
these two special marks, all marks is shared between peer text
widgets, n' may be manipulated on a equal basis from any peer.
.VE 8.5
.SH "EMBEDDED WINDOWS"
.PP
Da third form of annotation up in text widgets be a embedded window.
Each embedded window annotation causes a window ta be displayed
at a particular point up in  tha text.
There may be any number of embedded windows up in a text widget,
and any widget may be used as a embedded window (subject ta the
usual rulez fo' geometry pimpment, which require tha text window
to be tha parent of tha embedded window or a thugged-out descendant of its
parent).
Da embedded windowz posizzle on tha screen is ghon be updated as the
text is modified or scrolled, n' it is ghon be mapped n' unmapped as
it moves tha fuck into n' outta tha visible area of tha text widget.
Each embedded window occupies one
.VS 8.5
unit's
.VE 8.5
worth of index space
in tha text widget, n' it may be referred ta either by tha name
of its embedded window or by its posizzle up in tha widget's
index space.
If tha range of text containin tha embedded window is deleted then
the window is destroyed.
.VS 8.5
Similarly if tha text widget as a whole is deleted, then tha window is
destroyed.
.VE 8.5
.PP
When a embedded window be added ta a text widget wit the
\fIpathName \fBwindow create\fR widget command, nuff muthafuckin configuration
options may be associated wit dat shit.
These options may be  modified lata wit tha \fIpathName \fBwindow configure\fR
widget command.
Da followin options is currently supported:
.TP
\fB\-align \fIwhere\fR
If tha window aint as tall as tha line up in which it is displayed,
this option determines where tha window is displayed up in tha line.
\fIWhere\fR must have one of tha joints \fBtop\fR (align tha top of tha window
with tha top of tha line), \fBcenter\fR (centa tha window
within tha range of tha line), \fBbottom\fR (align tha bottom of the
window wit tha bottom of tha linez area),
or \fBbaseline\fR (align tha bottom of tha window wit tha baseline
of tha line).
.TP
\fB\-create \fIscript\fR
Specifies a Tcl script dat may be evaluated ta create tha window
for tha annotation.
If no \fB\-window\fR option has been specified fo' tha annotation
this script is ghon be evaluated when tha annotation be bout to
be displayed on tha screen.
\fIScript\fR must create a window fo' tha annotation n' return
the name of dat window as its result.
.VS 8.5
Two substitutions is ghon be performed up in \fIscript\fR before evaluation.
\fI%W\fR is ghon be substituted by tha name of tha parent text widget,
and \fI%%\fR is ghon be substituted by a single \fI%\fR.
.VE 8.5
If tha annotationz window should eva be deleted, \fIscript\fR
will be evaluated again n' again n' again tha next time tha annotation is displayed.
.TP
\fB\-padx \fIpixels\fR
\fIPixels\fR specifies tha amount of extra space ta leave on
each side of tha embedded window.
It may have any of tha usual forms defined fo' a screen distance.
.TP
\fB\-pady \fIpixels\fR
\fIPixels\fR specifies tha amount of extra space ta leave on
the top n' on tha bottom of tha embedded window.
It may have any of tha usual forms defined fo' a screen distance.
.TP
\fB\-stretch \fIboolean\fR
If tha axed height of tha embedded window is less than the
height of tha line up in which it is displayed, dis option can be
used ta specify whether tha window should be stretched vertically
to fill its line.
If tha \fB\-pady\fR option has been specified as well, then the
axed paddin is ghon be retained even if tha window is
stretched.
.TP
\fB\-window \fIpathName\fR
Specifies tha name of a window ta display up in tha annotation.
.VS 8.5
Note dat if a \fIpathName\fR has been set, then lata configurin a
window ta tha empty strang aint gonna delete tha widget correspondin to
the oldschool \fIpathName\fR. Rather it will remove tha association between
the oldschool \fIpathName\fR n' tha text widget.  If multiple peer widgets
are up in use, it is probably simpla ta use tha \fB\-create\fR option if
embedded windows is desired up in each peer.
.VE 8.5
.SH "EMBEDDED IMAGES"
.PP
Da final form of annotation up in text widgets be a embedded image.
Each embedded image annotation causes a image ta be displayed
at a particular point up in  tha text.
There may be any number of embedded images up in a text widget,
and a particular image may be embedded up in multiple places up in tha same
text widget.
Da embedded imagez posizzle on tha screen is ghon be updated as the
text is modified or scrolled.
Each embedded image occupies one
.VS 8.5
unit's
.VE 8.5
worth of index space
in tha text widget, n' it may be referred ta either by
its posizzle up in tha widgetz index space, or tha name it be assigned
when tha image is banged tha fuck into tha text widget wit \fIpathName \fBimage create\fR.
If tha range of text containin tha embedded image is deleted then
that copy of tha image is removed from tha screen.
.PP
When a embedded image be added ta a text widget wit tha \fIpathName \fBimage
create\fR widget command, a name unique ta dis instizzle of tha image
is returned. Y'all KNOW dat shit, muthafucka!  This name may then be used ta refer ta dis image
instance.  Da name is taken ta be tha value of tha \fB\-name\fR option
(busted lyrics bout below).  If tha \fB\-name\fR option aint provided, the
\fB\-image\fR name is used instead. Y'all KNOW dat shit, muthafucka!  If tha \fIimageName\fR be already
in use up in tha text widget, then \fB#\fInn\fR be added ta tha end of the
\fIimageName\fR, where \fInn\fR be a arbitrary integer n' shit.  This insures
the \fIimageName\fR is unique.
Once dis name be assigned ta dis instizzle of tha image, it do not
change, even though tha \fB\-image\fR or \fB\-name\fR joints can be chizzled
with \fIpathName \fBimage configure\fR.
.PP
When a embedded image be added ta a text widget wit the
\fIpathName \fBimage create\fR widget command, nuff muthafuckin configuration
options may be associated wit dat shit.
These options may be modified lata wit tha \fIpathName \fBimage configure\fR
widget command.
Da followin options is currently supported:
.TP
\fB\-align \fIwhere\fR
If tha image aint as tall as tha line up in which it is displayed,
this option determines where tha image is displayed up in tha line.
\fIWhere\fR must have one of tha joints \fBtop\fR (align tha top of tha image
with tha top of tha line), \fBcenter\fR (centa tha image
within tha range of tha line), \fBbottom\fR (align tha bottom of the
image wit tha bottom of tha linez area),
or \fBbaseline\fR (align tha bottom of tha image wit tha baseline
of tha line).
.TP
\fB\-image \fIimage\fR
Specifies tha name of tha Tk image ta display up in tha annotation.
If \fIimage\fR aint a valid Tk image, then a error is returned.
.TP
\fB\-name \fIImageName\fR
Specifies tha name by which dis image instizzle may be referenced in
the text widget. If \fIImageName\fR aint supplied, then the
name of tha Tk image is used instead.
If tha \fIimageName\fR be already up in use, \fI#nn\fR be appended to
the end of tha name as busted lyrics bout above.
.TP
\fB\-padx \fIpixels\fR
\fIPixels\fR specifies tha amount of extra space ta leave on
each side of tha embedded image.
It may have any of tha usual forms defined fo' a screen distance.
.TP
\fB\-pady \fIpixels\fR
\fIPixels\fR specifies tha amount of extra space ta leave on
the top n' on tha bottom of tha embedded image.
It may have any of tha usual forms defined fo' a screen distance.
.SH "THE SELECTION"
.PP
Selection support is implemented via tags.
If tha \fBexportSelection\fR option fo' tha text widget is true
then tha \fBsel\fR tag is ghon be associated wit tha selection:
.IP [1]
Whenever charactas is tagged wit \fBsel\fR tha text widget
will claim ballershizzle of tha selection.
.IP [2]
Attempts ta retrieve the
selection is ghon be serviced by tha text widget, returnin all the
charactas wit tha \fBsel\fR tag.
.IP [3]
If tha selection is fronted away by another application or by another
window within dis application, then tha \fBsel\fR tag is ghon be removed
from all charactas up in tha text.
.IP [4]
Whenever tha \fBsel\fR tag range chizzlez a virtual event
\fB<<Selection>>\fR is generated.
.PP
Da \fBsel\fR tag be automatically defined when a text widget is
created, n' it may not be deleted wit the
.QW "\fIpathName \fBtag delete\fR"
widget command. Y'all KNOW dat shit, muthafucka!  Furthermore, tha \fBselectBackground\fR,
\fBselectBorderWidth\fR, n' \fBselectForeground\fR options for
the text widget is tied ta tha \fB\-background\fR,
\fB\-borderwidth\fR, n' \fB\-foreground\fR options fo' tha \fBsel\fR
tag:  chizzlez up in either will automatically be reflected up in the
other.
.VS 8.5
Also the
\fB\-inactiveselectbackground\fR option fo' tha text widget is used
instead of \fB\-selectbackground\fR when tha text widget do not have
the focus.  This allows programmatic control over tha visualization of
the \fBsel\fR tag fo' foreground n' background windows, or ta have
\fBsel\fR not shown at all (when \fB\-inactiveselectbackground\fR is
empty) fo' background windows.  Each peer text widget has its own
\fBsel\fR tag which can be separately configured n' set.
.VE 8.5
.SH "THE INSERTION CURSOR"
.PP
Da mark named \fBinsert\fR has special significizzle up in text widgets.
It be defined automatically when a text widget is pimped n' it
may not be unset wit the
.QW "\fIpathName \fBmark unset\fR"
widget command.
Da \fBinsert\fR mark represents tha posizzle of tha insertion
cursor, n' tha insertion cursor will automatically be drawn at
this point whenever tha text widget has tha input focus.
.SH "THE MODIFIED FLAG"
Da text widget can keep track of chizzlez ta tha content of tha widget
by meanz of tha modified flag. Insertin or deletin text will set
this flag. Da flag can be queried, set n' cleared programmatically
as well. Whenever tha flag chizzlez state a \fB<<Modified>>\fR virtual
event is generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. See tha \fIpathName \fBedit modified\fR widget command for
more details.
.SH "THE UNDO MECHANISM"
.PP
Da text widget has a unlimited undo n' redo mechanizzle (when the
\fB\-undo\fR widget option is true) which recordz every last muthafuckin bang and
delete action on a stack.
.PP
Boundaries (called
.QW separators )
are banged between edit actions.  The
purpose of these separators is ta crew inserts, deletes n' replaces
into one compound edit action. I aint talkin' bout chicken n' gravy biatch.  When unfuckin wit a cold-ass lil chizzle every last muthafuckin thang between
two separators is ghon be undone.  Da undone chizzlez is then moved ta the
redo stack, so dat a undone edit can be redone again. I aint talkin' bout chicken n' gravy biatch.  Da redo stack
is cleared whenever freshly smoked up edit actions is recorded on tha undo stack.  The
undo n' redo stacks can be cleared ta keep they depth under control.
.PP
Separators is banged automatically when tha \fB\-autoseparators\fR
widget option is true.  Yo ass can bang separators programmatically as
well.  If a separator be already present all up in tha top of tha undo stack
no other is ghon be inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  That means dat two separators on tha undo
stack is always separated by at least one bang or delete action.
.PP
Da undo mechanizzle be also linked ta tha modified flag.  This means
that unfuckin wit or refuckin wit chizzlez can take a modified text widget back
to tha unmodified state or vice versa.  Da modified flag is ghon be set
automatically ta tha appropriate state.  This automatic coupling
does not work when tha modified flag has been set by tha user, until
the flag has been reset again.
.PP
See below fo' tha \fIpathName \fBedit\fR widget command dat controls tha undo
mechanism.
.SH "PEER WIDGETS"
.PP
.VS 8.5
Da text widget has a separate store of all its data concernin each
linez textual contents, marks, tags, images n' windows, n' tha undo
stack.
.PP
While dis data store cannot be accessed directly (i.e. without a text
widget as a intermediary), multiple text widgets can be pimped, each
of which present different views on tha same underlyin data.  Such
text widgets is known as peer text widgets.
.PP
As text be added, deleted, edited n' coloured up in any one widget, n' as
images, marks, tags is adjusted, all such chizzlez is ghon be reflected in
all peers.
.PP
All data n' markup is shared, except fo' all dem lil' small-ass details.  First,
the \fBsel\fR tag may be set n' configured (in its display style)
differently fo' each peer n' shit.  Second, each peer has its own \fBinsert\fR
and \fBcurrent\fR mark positions (but all other marks is shared).
Third, embedded windows, which is arbitrary other widgets, cannot be
shared between peers.  This means tha \fB\-window\fR option of embedded
windows is independently set fo' each peer (it be advisable ta use
the \fB\-create\fR script capabilitizzles ta allow each peer ta create its
own embedded windows as needed).  Fourth, all of tha configuration
optionz of each peer (e.g. \fB\-font\fR, etc) can be set independently,
with tha exception of \fB\-undo\fR, \fB\-maxUndo\fR, \fB\-autoSeparators\fR
(i.e. all undo, redo n' modified state thangs is shared).
.PP
Finally any single peer need not contain all lines from tha underlying
data store.  When bustin a peer, a cold-ass lil contiguous range of lines (e.g.
only lines 52 all up in 125) may be specified. Y'all KNOW dat shit, muthafucka!  This allows a peer to
contain just a lil' small-ass portion of tha overall text.  Da range of lines
will expand n' contract as text is banged or deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da peer will
only eva display complete linez of text (one cannot share just part of
a line).  If tha peerz contents contracts ta not a god damn thang (i.e. all complete
lines up in tha peer widget done been deleted from another widget), then it
is impossible fo' freshly smoked up lines ta be inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da peer will simply become
an empty shell on which tha background can be configured yo, but which will
never show any content (without manual reconfiguration of tha start and
end lines).  Note dat a peer which do not contain all of the
underlyin data store still has indices numbered from
.QW 1.0
to
.QW end .
It be simply dat dem indices reflect a subset of tha total data, and
data outside tha contained range aint accessible ta tha peer n' shit.  This
means dat tha command \fIpeerName \fBindex end\fR may return like different
values up in different peers.  Similarly, commandz like \fIpeerName \fBtag
ranges\fR aint gonna return index ranges outside dat which is meaningful
to tha peer n' shit.  Da configuration options \fB\-startline\fR and
\fB\-endline\fR may be used ta control how tha fuck much of tha underlyin data is
contained up in any given text widget.
.PP
Note dat peers is straight-up peers.  Deletin the
.QW original
text widget aint gonna cause any other peers ta be deleted, or otherwise
affected.
.PP
See below fo' tha \fIpathName \fBpeer\fR widget command dat controls the
creation of peer widgets.
.VE 8.5
.SH "WIDGET COMMAND"
.PP
Da \fBtext\fR command creates a freshly smoked up Tcl command whose
name is tha same ol' dirty as tha path name of tha textz window.  This
command may be used ta invoke various
operations on tha widget.  It has tha followin general form:
.CS
\fIpathName option \fR?\fIarg arg ...\fR?
.CE
\fIPathName\fR is tha name of tha command, which is tha same ol' dirty as
the text widgetz path name.  \fIOption\fR n' tha \fIarg\fRs
determine tha exact behavior of tha command. Y'all KNOW dat shit, muthafucka!  Da following
commandz is possible fo' text widgets:
.TP
\fIpathName \fBbbox \fIindex\fR
Returns a list of four elements describin tha screen area
of tha characta given by \fIindex\fR.
Da first two elementz of tha list give tha x n' y coordinates
of tha upper-left corner of tha area occupied by the
character, n' tha last two elements give tha width n' height
of tha area.
If tha characta is only partially visible on tha screen, then
the return value reflects just tha visible part.
If tha characta aint visible on tha screen then tha return
value be a empty list.
.TP
\fIpathName \fBcget\fR \fIoption\fR
Returns tha current value of tha configuration option given
by \fIoption\fR.
\fIOption\fR may have any of tha joints accepted by tha \fBtext\fR
command.
.TP
\fIpathName \fBcompare\fR \fIindex1 op index2\fR
Compares tha indices given by \fIindex1\fR n' \fIindex2\fR according
to tha relationizzle operator given by \fIop\fR, n' returns 1 if
the relationshizzle is satisfied n' 0 if it is not.
\fIOp\fR must be one of tha operators <, <=, ==, >=, >, or !=.
If \fIop\fR is == then 1 is returned if tha two indices refer to
the same character, if \fIop\fR is < then 1 is returned if \fIindex1\fR
refers ta a earlier characta up in tha text than \fIindex2\fR, and
so on.
.TP
\fIpathName \fBconfigure\fR ?\fIoption\fR, biatch? \fI?value option value ...\fR?
Query or modify tha configuration optionz of tha widget.
If no \fIoption\fR is specified, returns a list describin all of
the available options fo' \fIpathName\fR (see \fBTk_ConfigureInfo\fR for
information on tha format of dis list).  If \fIoption\fR is specified
with no \fIvalue\fR, then tha command returns a list describin the
one named option (this list is ghon be identical ta tha corresponding
sublist of tha value returned if no \fIoption\fR is specified).  If
one or mo' \fIoption\-value\fR pairs is specified, then tha command
modifies tha given widget option(s) ta have tha given value(s);  in
this case tha command returns a empty string.
\fIOption\fR may have any of tha joints accepted by tha \fBtext\fR
command.
.VS 8.5
.TP
\fIpathName \fBcount\fR \fI?options\fR, biatch? \fIindex1 index2\fR
Counts tha number of relevant thangs between tha two indices.
If \fIindex1\fR be afta \fIindex2\fR, tha result is ghon be a wack number
(and dis holdz fo' each of tha possible options).
Da actual shit which is counted depend on the
options given. I aint talkin' bout chicken n' gravy biatch.  Da result be a list of integers, one fo' tha result of
each countin option given. I aint talkin' bout chicken n' gravy biatch.  Valid countin options is \fB\-chars\fR,
\fB\-displaychars\fR, \fB\-displayindices\fR, \fB\-displaylines\fR,
\fB\-indices\fR, \fB\-lines\fR, \fB\-xpixels\fR n' \fB\-ypixels\fR. The
default value, if no option is specified, is \fB\-indices\fR. There be an
additionizzle possible option \fB\-update\fR which be a modifier n' shit.  If given,
then all subsequent options ensure dat any possible outta date
information is recalculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This currently only has any effect fo' the
\fI\-ypixels\fR count (which, if \fB\-update\fR aint given, will use tha text
widgetz current cached value fo' each line).  Da count options are
interpreted as bigs up:
.RS
.IP \fB\-chars\fR
count all characters, whether elided or not.  Do not count
embedded windows or images.
.IP \fB\-displaychars\fR
count all non-elided characters.
.IP \fB\-displayindices\fR
count all non-elided characters, windows n' images.
.IP \fB\-displaylines\fR
count all display lines (i.e. countin one fo' each
time a line wraps) from tha line of tha straight-up original gangsta index up ta yo, but not
includin tha display line of tha second index.  Therefore if they are
both on tha same display line, zero is ghon be returned. Y'all KNOW dat shit, muthafucka!  By definition
displaylines is visible n' therefore dis only counts portions of
actual visible lines.
.IP \fB\-indices\fR
count all charactas n' embedded windows or images (i.e.
everythang which counts up in text-widget index space), whether they are
elided or not.
.IP \fB\-lines\fR
count all logical lines (irrespectizzle of wrapping) from
the line of tha straight-up original gangsta index up ta yo, but not includin tha line of the
second index.  Therefore if they is both on tha same line, zero will be
returned. Y'all KNOW dat shit, muthafucka!  Logical lines is counted whether they is currently visible
(non-elided) or not.
.IP \fB\-xpixels\fR
count tha number of horizontal pixels from tha first
pixel of tha straight-up original gangsta index ta (but not including) tha straight-up original gangsta pixel of the
second index.  To count tha total desired width of tha text widget
(assumin wrappin aint enabled), first find tha longest line n' then
use
.QW ".text count \-xpixels \N'34'${line}.0\N'34' \N'34'${line}.0 lineend\N'34'" .
.IP \fB\-ypixels\fR
count tha number of vertical pixels from tha straight-up original gangsta pixel
of tha straight-up original gangsta index ta (but not including) tha straight-up original gangsta pixel of tha second
index.  If both indices is on tha same display line, zero will be
returned. Y'all KNOW dat shit, muthafucka!  To count tha total number of vertical pixels up in tha text
widget, use
.QW ".text count \-ypixels 1.0 end" ,
and ta ensure dis is up ta date, use
.QW ".text count \-update \-ypixels 1.0 end" .
.PP
Da command returns a positizzle or wack integer correspondin ta the
number of shit counted between tha two indices.  One such integer is
returned fo' each countin option given, so a list is returned if more
than one option was supplied. Y'all KNOW dat shit, muthafucka!  For example
.QW ".text count \-xpixels \-ypixels 1.3 4.5"
is perfectly valid n' will return a list of two elements.
.RE
.VE 8.5
.TP
\fIpathName \fBdebug \fR?\fIboolean\fR?
If \fIboolean\fR is specified, then it must have one of tha legit or
false joints accepted by Tcl_GetBoolean.
If tha value be a legit one then internal consistency checks will be
turned on up in tha B-tree code associated wit text widgets.
If \fIboolean\fR has a gangbangin' false value then tha debuggin checks will
be turned off.
In either case tha command returns a empty string.
If \fIboolean\fR aint specified then tha command returns \fBon\fR
or \fBoff\fR ta indicate whether or not debuggin is turned on.
There be a single debuggin switch shared by all text widgets:  turning
debuggin on or off up in any widget turns it on or off fo' all widgets.
For widgets wit big-ass amountz of text, tha consistency checks may
cause a noticeable slow-down.
.RS
.PP
When debuggin is turned on, tha drawin routinez of tha text widget
set tha global variablez \fBtk_textRedraw\fR n' \fBtk_textRelayout\fR
to tha listz of indices dat is redrawn. I aint talkin' bout chicken n' gravy biatch.  Da jointz of these variables
are tested by Tkz test suite.
.RE
.TP
\fIpathName \fBdelete \fIindex1 \fR?\fIindex2 ...\fR?
Delete a range of charactas from tha text.
If both \fIindex1\fR n' \fIindex2\fR is specified, then delete
all tha charactas startin wit tha one given by \fIindex1\fR
and stoppin just before \fIindex2\fR (i.e. tha characta at
\fIindex2\fR aint deleted).
If \fIindex2\fR do not specify a posizzle lata up in tha text
than \fIindex1\fR then no charactas is deleted.
If \fIindex2\fR aint specified then tha single characta at
\fIindex1\fR is deleted.
It aint allowable ta delete charactas up in a way dat would leave
the text without a newline as tha last character.
Da command returns a empty string.
If mo' indices is given, multiple rangez of text is ghon be deleted.
All indices is first checked fo' validitizzle before any deletions is made.
They is sorted n' tha text is removed from tha last range ta the
first range so deleted text do not cause a undesired index shifting
side-effects, n' you can put dat on yo' toast.  If multiple ranges wit tha same start index is given,
then tha longest range is used. Y'all KNOW dat shit, muthafucka!  If overlappin ranges is given, then
they is ghon be merged tha fuck into spans dat do not cause deletion of text
outside tha given ranges cuz of text shifted durin deletion.
.TP
\fIpathName \fBdlineinfo \fIindex\fR
Returns a list wit five elements describin tha area occupied
by tha display line containin \fIindex\fR.
Da first two elementz of tha list give tha x n' y coordinates
of tha upper-left corner of tha area occupied by the
line, tha third n' fourth elements give tha width n' height
of tha area, n' tha fifth element gives tha posizzle of tha baseline
for tha line, measured down from tha top of tha area.
All of dis shiznit is measured up in pixels.
If tha current wrap mode is \fBnone\fR n' tha line extendz beyond
the boundariez of tha window,
the area returned reflects tha entire area of tha line, includin the
portions dat is outta tha window.
If tha line is shorta than tha full width of tha window then the
area returned reflects just tha portion of tha line dat is occupied
by charactas n' embedded windows.
If tha display line containin \fIindex\fR aint visible on
the screen then tha return value be a empty list.
.TP
\fIpathName \fBdump \fR?\fIswitches\fR, biatch? \fIindex1 \fR?\fIindex2\fR?
Return tha contentz of tha text widget from \fIindex1\fR up to,
but not includin \fIindex2\fR,
includin tha text and
information bout marks, tags, n' embedded windows.
If \fIindex2\fR aint specified, then it defaults to
one characta past \fIindex1\fR.  Da shiznit is returned
in tha followin format:
.LP
.RS
\fIkey1 value1 index1 key2 value2 index2\fR ...
.LP
Da possible \fIkey\fR joints is \fBtext\fR, \fBmark\fR,
\fBtagon\fR, \fBtagoff\fR, \fBimage\fR, n' \fBwindow\fR.  Da corresponding
\fIvalue\fR is tha text, mark name, tag name, image name, or window name.
Da \fIindex\fR shiznit is tha index of the
start of tha text, mark, tag transition, image or window.
One or mo' of tha followin switches (or abbreviations thereof)
may be specified ta control tha dump:
.TP
\fB\-all\fR
Return shiznit bout all elements: text, marks, tags, images n' windows.
This is tha default.
.TP
\fB\-command \fIcommand\fR
Instead of returnin tha shiznit as tha result of tha dump operation,
invoke tha \fIcommand\fR on each element of tha text widget within tha range.
Da command has three arguments appended ta it before it is evaluated:
the \fIkey\fR, \fIvalue\fR, n' \fIindex\fR.
.TP
\fB\-image\fR
Include shiznit bout images up in tha dump thangs up in dis biatch.
.TP
\fB\-mark\fR
Include shiznit bout marks up in tha dump thangs up in dis biatch.
.TP
\fB\-tag\fR
Include shiznit bout tag transitions up in tha dump thangs up in dis biatch. Tag
information is returned as \fBtagon\fR n' \fBtagoff\fR elements that
indicate tha begin n' end of each range of each tag, respectively.
.TP
\fB\-text\fR
Include shiznit bout text up in tha dump thangs up in dis biatch.  Da value is the
text up ta tha next element or tha end of range indicated by \fIindex2\fR.
A text element do not span newlines.  A multi-line block of text that
gotz nuff no marks or tag transitions will still be dumped as a set
of text segments dat each end wit a newline.  Da newline is part
of tha value.
.TP
\fB\-window\fR
Include shiznit bout embedded windows up in tha dump thangs up in dis biatch.
Da value of a window is its Tk pathname, unless tha window
has not been pimped yet.  (It must gotz a cold-ass lil create script.)
In dis case a empty strang is returned, n' you must query the
window by its index posizzle ta git mo' shiznit.
.RE
.TP
\fIpathName \fBedit \fIoption \fR?\fIarg arg ...\fR?
This command controls tha undo mechanizzle n' tha modified flag.  The
exact behavior of tha command dependz on tha \fIoption\fR argument
that bigs up tha \fBedit\fR argument.  Da followin formz of the
command is currently supported:
.RS
.TP
\fIpathName \fBedit modified ?\fIboolean\fR?
If \fIboolean\fR aint specified, returns tha modified flag of the
widget. Da insert, delete, edit undo n' edit redo commandz or the
user can set or clear tha modified flag.  If \fIboolean\fR is
specified, sets tha modified flag of tha widget ta \fIboolean\fR.
.TP
\fIpathName \fBedit redo\fR
When tha \fB\-undo\fR option is true, reapplies tha last undone edits
provided no other edits was done since then. I aint talkin' bout chicken n' gravy biatch. Generates a error when
the redo stack is empty.  Do not a god damn thang when tha \fB\-undo\fR option is
false.
.TP
\fIpathName \fBedit reset\fR
Clears tha undo n' redo stacks.
.TP
\fIpathName \fBedit separator\fR
Inserts a separator (boundary) on tha undo stack. Do not a god damn thang when
the \fB\-undo\fR option is false.
.TP
\fIpathName \fBedit undo\fR
Undoes tha last edit action when tha \fB\-undo\fR option is true.  An
edit action is defined as all tha bang n' delete commandz dat are
recorded on tha undo stack up in between two separators. Generates an
error when tha undo stack is empty.  Do not a god damn thang when tha \fB\-undo\fR
option is false.
.RE
.TP
\fIpathName \fBget\fR \fI?\-displaychars?\fR \fI\-\- index1\fR ?\fIindex2 ...\fR?
Return a range of charactas from tha text.
Da return value is ghon be all tha charactas up in tha text starting
with tha one whose index is \fIindex1\fR n' endin just before
the one whose index is \fIindex2\fR (the characta at \fIindex2\fR
will not be returned).
If \fIindex2\fR is omitted then tha single characta at \fIindex1\fR
is returned.
If there be no charactas up in tha specified range (e.g. \fIindex1\fR
is past tha end of tha file or \fIindex2\fR is less than or equal
to \fIindex1\fR) then a empty strang is returned.
If tha specified range gotz nuff embedded windows, no shiznit
about dem is included up in tha returned string.
If multiple index pairs is given, multiple rangez of text is ghon be returned
in a list.  Invalid ranges aint gonna be represented wit empty strings in
the list.  Da ranges is returned up in tha order passed ta \fIpathName \fBget\fR.
.VS 8.5
If tha \fB\-displaychars\fR option is given, then, within each range,
only dem charactas which is not elided is ghon be returned. Y'all KNOW dat shit, muthafucka!  This may
have tha effect dat a shitload of tha returned ranges is empty strings.
.VE 8.5
.TP
\fIpathName \fBimage \fIoption \fR?\fIarg arg ...\fR?
This command is used ta manipulate embedded images.
Da behavior of tha command dependz on tha \fIoption\fR argument
that bigs up tha \fBtag\fR argument.
Da followin formz of tha command is currently supported:
.RS
.TP
\fIpathName \fBimage cget\fR \fIindex option\fR
Returns tha value of a cold-ass lil configuration option fo' a embedded image.
\fIIndex\fR identifies tha embedded image, n' \fIoption\fR
specifies a particular configuration option, which must be one of
the ones listed up in tha section \fBEMBEDDED IMAGES\fR.
.TP
\fIpathName \fBimage configure \fIindex\fR ?\fIoption value ...\fR?
Query or modify tha configuration options fo' a embedded image.
If no \fIoption\fR is specified, returns a list describin all of
the available options fo' tha embedded image at \fIindex\fR
(see \fBTk_ConfigureInfo\fR fo' shiznit on tha format of dis list).
If \fIoption\fR is specified wit no \fIvalue\fR, then tha command
returns a list describin tha one named option (this list will be
identical ta tha correspondin sublist of tha value returned if no
\fIoption\fR is specified).
If one or mo' \fIoption\-value\fR pairs is specified, then tha command
modifies tha given option(s) ta have tha given value(s);  in
this case tha command returns a empty string.
See \fBEMBEDDED IMAGES\fR fo' shiznit on tha options that
are supported.
.TP
\fIpathName \fBimage create \fIindex\fR ?\fIoption value ...\fR?
This command creates a freshly smoked up image annotation, which will appear
in tha text all up in tha posizzle given by \fIindex\fR.
Any number of \fIoption\-value\fR pairs may be specified to
configure tha annotation.
Returns a unique identifier dat may be used as a index ta refer to
this image.
See \fBEMBEDDED IMAGES\fR fo' shiznit on tha options that
are supported, n' a thugged-out description of tha identifier returned.
.TP
\fIpathName \fBimage names\fR
Returns a list whose elements is tha namez of all image instances currently
embedded up in \fIwindow\fR.
.RE
.TP
\fIpathName \fBindex \fIindex\fR
Returns tha posizzle correspondin ta \fIindex\fR up in tha form
\fIline.char\fR where \fIline\fR is tha line number n' \fIchar\fR
is tha characta number.
\fIIndex\fR may have any of tha forms busted lyrics bout under \fBINDICES\fR above.
.TP
\fIpathName \fBinsert \fIindex chars \fR?\fItagList chars tagList ...\fR?
Inserts all of tha \fIchars\fR arguments just before tha characta at
\fIindex\fR.
If \fIindex\fR refers ta tha end of tha text (the characta after
the last newline) then tha freshly smoked up text is banged just before the
last newline instead.
If there be a single \fIchars\fR argument n' no \fItagList\fR, then
the freshly smoked up text will receive any tags dat is present on both the
characta before n' tha characta afta tha insertion point; if a tag
is present on only one of these charactas then it aint gonna be
applied ta tha freshly smoked up text.
If \fItagList\fR is specified then it consistz of a list of
tag names;  tha freshly smoked up charactas will receive all of tha tags in
this list n' no others, regardless of tha tags present around
the insertion point.
If multiple \fIchars\fR\-\fItagList\fR argument pairs is present,
they produce tha same effect as if a separate \fIpathName \fBinsert\fR widget
command had been issued fo' each pair, up in order.
Da last \fItagList\fR argument may be omitted.
.TP
\fIpathName \fBmark \fIoption \fR?\fIarg arg ...\fR?
This command is used ta manipulate marks.  Da exact behavior of
the command dependz on tha \fIoption\fR argument dat bigs up
the \fBmark\fR argument.  Da followin formz of tha command
are currently supported:
.RS
.TP
\fIpathName \fBmark gravitizzle \fImarkName\fR ?\fIdirection\fR?
If \fIdirection\fR aint specified, returns \fBleft\fR or \fBright\fR
to indicate which of its adjacent charactas \fImarkName\fR be attached
to.
If \fIdirection\fR is specified, it must be \fBleft\fR or \fBright\fR;
the gravitizzle of \fImarkName\fR is set ta tha given value.
.TP
\fIpathName \fBmark names\fR
Returns a list whose elements is tha namez of all tha marks that
are currently set.
.TP
\fIpathName \fBmark next \fIindex\fR
Returns tha name of tha next mark at or afta \fIindex\fR.
If \fIindex\fR is specified up in numerical form, then tha search for
the next mark begins at dat index.
If \fIindex\fR is tha name of a mark, then tha search for
the next mark begins immediately afta dat mark.
This can still return a mark all up in tha same posizzle if
there is multiple marks all up in tha same index.
These semantics mean dat tha \fBmark next\fR operation can be used to
step all up in all tha marks up in a text widget up in tha same order
as tha mark shiznit returned by tha \fIpathName \fBdump\fR operation.
If a mark has been set ta tha special \fBend\fR index,
then it appears ta be \fIafter\fR \fBend\fR wit respect ta tha \fIpathName \fBmark next\fR operation.
An empty strang is returned if there be no marks afta \fIindex\fR.
.TP
\fIpathName \fBmark previous \fIindex\fR
Returns tha name of tha mark at or before \fIindex\fR.
If \fIindex\fR is specified up in numerical form, then tha search for
the previous mark begins wit tha characta just before dat index.
If \fIindex\fR is tha name of a mark, then tha search for
the next mark begins immediately before dat mark.
This can still return a mark all up in tha same posizzle if
there is multiple marks all up in tha same index.
These semantics mean dat tha \fIpathName \fBmark previous\fR operation can be used to
step all up in all tha marks up in a text widget up in tha reverse order
as tha mark shiznit returned by tha \fIpathName \fBdump\fR operation.
An empty strang is returned if there be no marks before \fIindex\fR.
.TP
\fIpathName \fBmark set \fImarkName index\fR
Sets tha mark named \fImarkName\fR ta a posizzle just before the
characta at \fIindex\fR.
If \fImarkName\fR already exists, it is moved from its oldschool position;
if it do not exist, a freshly smoked up mark is pimped.
This command returns a empty string.
.TP
\fIpathName \fBmark unset \fImarkName \fR?\fImarkName markName ...\fR?
Remove tha mark correspondin ta each of tha \fImarkName\fR arguments.
Da removed marks aint gonna be usable up in indices n' aint gonna be
returned by future calls to
.QW "\fIpathName \fBmark names\fR" .
This command returns a empty string.
.RE
.TP
\fIpathName \fBpeer\fR \fIoption args\fR
.VS 8.5
This command is used ta create n' query widget peers.  It has
two forms, dependin on \fIoption\fR:
.RS
.TP
\fIpathName \fBpeer create \fInewPathName\fR ?\fIoptions\fR?
Creates a peer text widget wit tha given \fInewPathName\fR, n' any
optionizzle standard configuration options (as fo' tha \fItext\fR command).
By default tha peer gonna git tha same start n' end line as the
parent widget yo, but these can be overridden wit tha standard
configuration options.
.TP
\fIpathName \fBpeer names\fR
Returns a list of peerz of dis widget (this do not include tha widget
itself).  Da order within dis list is undefined.
.RE
.TP
\fIpathName \fBreplace\fR \fIindex1 index2 chars\fR ?\fItagList chars tagList ...\fR?
Replaces tha range of charactas between \fIindex1\fR n' \fIindex2\fR
with tha given charactas n' tags.  See tha section on \fIpathName
\fBinsert\fR fo' a explanation of tha handlin of tha \fItagList...\fR
arguments, n' tha section on \fIpathName
\fBdelete\fR fo' a explanation of tha handlin of tha indices.  If
\fIindex2\fR correspondz ta a index earlier up in tha text than
\fIindex1\fR, a error is ghon be generated.
.RS
.PP
Da deletion n' insertion is arranged so dat no unnecessary
scrollin of tha window or movement of insertion cursor occurs.  In
addizzle tha undo/redo stack is erectly modified, if undo operations
are actizzle up in tha text widget.  Da command returns a empty string.
.RE
.VE 8.5
.TP
\fIpathName \fBscan\fR \fIoption args\fR
This command is used ta implement scannin on texts, n' you can put dat on yo' toast.  It has
two forms, dependin on \fIoption\fR:
.RS
.TP
\fIpathName \fBscan mark \fIx y\fR
Recordz \fIx\fR n' \fIy\fR n' tha current view up in tha text window,
for use up in conjunction wit lata \fIpathName \fBscan dragto\fR commands.
Typically dis command be associated wit a mouse button press in
the widget.  It returns a empty string.
.TP
\fIpathName \fBscan dragto \fIx y\fR
This command computes tha difference between its \fIx\fR n' \fIy\fR
arguments n' tha \fIx\fR n' \fIy\fR arguments ta tha last
\fIpathName \fBscan mark\fR command fo' tha widget.
It then adjusts tha view by 10 times tha difference up in coordinates.
This command is typically associated
with mouse motion events up in tha widget, ta produce tha effect of
draggin tha text at high speed all up in tha window.  Da return
value be a empty string.
.RE
.TP
\fIpathName \fBsearch \fR?\fIswitches\fR, biatch? \fIpattern index \fR?\fIstopIndex\fR?
Searches tha text up in \fIpathName\fR startin at \fIindex\fR fo' a range
of charactas dat matches \fIpattern\fR.
If a match is found, tha index of tha straight-up original gangsta characta up in tha match is
returned as result;  otherwise a empty strang is returned.
One or mo' of tha followin switches (or abbreviations thereof)
may be specified ta control tha search:
.RS
.TP
\fB\-forwards\fR
Da search will proceed forward all up in tha text, findin tha first
matchin range startin at or afta tha posizzle given by \fIindex\fR.
This is tha default.
.TP
\fB\-backwards\fR
Da search will proceed backward all up in tha text, findin the
matchin range closest ta \fIindex\fR whose first character
is before \fIindex\fR
.VS 8.5
(it aint allowed ta be at \fIindex\fR).  Note that, fo' a variety of
reasons, backwardz searches can be substantially slower than forwards
searches (particularly when rockin \fB\-regexp\fR), so it is recommended
that performance-critical code use forward searches.
.VE 8.5
.TP
\fB\-exact\fR
Use exact matching:  tha charactas up in tha matchin range must be
identical ta dem up in \fIpattern\fR.
This is tha default.
.TP
\fB\-regexp\fR
Treat \fIpattern\fR as a regular expression n' match it against
the text rockin tha rulez fo' regular expressions (see tha \fBregexp\fR
command fo' details).
.VS 8.5
Da default matchin automatically passes
both tha \fB\-lineanchor\fR n' \fB\-linestop\fR options
to tha regexp engine (unless \fB\-nolinestop\fR is used), so that
\fI^$\fR match beginnin n' end of line, n' \fI.\fR, \fI[^\fR
sequences aint NEVER gonna match tha newline characta \fI\en\fR.
.VE 8.5
.TP
\fB\-nolinestop\fR
.VS 8.5
This allows \fI.\fR n' \fI[^\fR sequences ta match tha newline
characta \fI\en\fR, which they will otherwise not do (see tha \fBregexp\fR
command fo' details). This option is only meaningful if \fB\-regexp\fR
is also given, n' a error is ghon be thrown otherwise.  For example,
to match tha entire text, use
.QW "\fIpathName \fBsearch \-nolinestop \-regexp\fR \N'34'.*\N'34' 1.0" .
.VE 8.5
.TP
\fB\-nocase\fR
Ignore case differences between tha pattern n' tha text.
.TP
\fB\-count\fI varName\fR
Da argument followin \fB\-count\fR gives tha name of a variable;
if a match is found, tha number of index positions between beginnin and
end of tha matchin range is ghon be stored up in tha variable.  If there be no
embedded images or windows up in tha matchin range (and there be no
elided charactas if \fB\-elide\fR aint given), dis is equivalent ta the
number of charactas matched. Y'all KNOW dat shit, muthafucka!  In either case, tha range \fImatchIdx\fR to
\fImatchIdx + $count chars\fR will return tha entire matched text.
.TP
\fB\-all\fR
.VS 8.5
Find all matches up in tha given range n' return a list of tha indices of
the first characta of each match.  If a \fB\-count\fI varName\fR switch is
given, then \fIvarName\fR be also set ta a list containin one element
for each successful match.  Note that, even fo' exact searches, the
elementz of dis list may be different, if there be embedded images,
windows or hidden text.  Searches wit \fB\-all\fR behave hella
similarly ta tha Tcl command \fBregexp \-all\fR, up in dat overlapping
matches is not normally returned. Y'all KNOW dat shit, muthafucka!  For example, applyin an
\fB\-all\fR search of tha pattern
.QW \ew+
against
.QW "wassup there"
will just match twice, once fo' each word, n' matching
.QW "Z[a\-z]+Z"
against
.QW ZooZooZoo
will just match once.
.VE 8.5
.TP
\fB\-overlap\fR
.VS 8.5
When struttin \fB\-all\fR searches, tha aiiight behaviour is that
matches which overlap a already-found match aint gonna be returned. Y'all KNOW dat shit, muthafucka!  This
switch chizzlez dat behaviour so dat all matches which is not straight-up
enclosed within another match is returned. Y'all KNOW dat shit, muthafucka!  For example, applyin an
\fB\-overlap\fR search of tha pattern
.QW \ew+
against
.QW "wassup there"
will just match twice (i.e. no different ta just \fB\-all\fR),
but matching
.QW Z[a\-z]+Z
against
.QW ZooZooZoo
will now match twice.
An error is ghon be thrown if dis switch is used without \fB\-all\fR.
.VE 8.5
.TP
\fB\-strictlimits\fR
.VS 8.5
When struttin any search, tha aiiight behaviour is that
the start n' stop limits is checked wit respect ta the
start of tha matchin text.  With tha \fB\-strictlimits\fR flag,
the entire matchin range must lie inside tha start n' stop
limits specified fo' tha match ta be valid.
.VE 8.5
.TP
\fB\-elide\fR
Find elided (hidden) text as well. By default only displayed text is
searched.
.TP
\fB\-\|\-\fR
This switch has no effect except ta terminizzle tha list of switches:
the next argument is ghon be treated as \fIpattern\fR even if it starts
with \fB\-\fR.
.PP
.VS 8.5
Da matchin range may be within a single line of text, or run across
multiple lines (if partz of tha pattern can match a new-line).  For
regular expression matchin one can use tha various newline-matching
features like fuckin \fB$\fR ta match tha end of a line, \fB^\fR ta match
the beginnin of a line, n' ta control
whether \fB.\fR be allowed ta match a new-line.
.VE 8.5
If \fIstopIndex\fR is specified, tha search stops at dat index:
for forward searches, no match at or afta \fIstopIndex\fR will
be considered;  fo' backward searches, no match earlier up in the
text than \fIstopIndex\fR is ghon be considered.
If \fIstopIndex\fR is omitted, tha entire text is ghon be searched:
when tha beginnin or end of tha text is reached, tha search
continues all up in tha other end until tha startin location is reached
again;  if \fIstopIndex\fR is specified, no wrap-around will occur.
This means that, fo' example, if tha search is \fB\-forwards\fR
but \fIstopIndex\fR is earlier up in tha text than \fIstartIndex\fR,
nothang will eva be found. Y'all KNOW dat shit, muthafucka!  See \fBKNOWN BUGS\fR below fo' a number of
minor limitationz of tha \fIpathName \fBsearch\fR command.
.RE
.TP
\fIpathName \fBsee \fIindex\fR
Adjusts tha view up in tha window so dat tha characta given by \fIindex\fR
is straight-up visible.
If \fIindex\fR be already visible then tha command do nothing.
If \fIindex\fR be a gangbangin' finger-lickin' dirty-ass short distizzle outta view, tha command
adjusts tha view just enough ta make \fIindex\fR visible at the
edge of tha window.
If \fIindex\fR is far outta view, then tha command centers
\fIindex\fR up in tha window.
.TP
\fIpathName \fBtag \fIoption \fR?\fIarg arg ...\fR?
This command is used ta manipulate tags.  Da exact behavior of the
command dependz on tha \fIoption\fR argument dat bigs up the
\fBtag\fR argument.  Da followin formz of tha command is currently
supported:
.RS
.TP
\fIpathName \fBtag add \fItagName index1 \fR?\fIindex2 index1 index2 ...\fR?
Associate tha tag \fItagName\fR wit all of tha charactas starting
with \fIindex1\fR n' endin just before
\fIindex2\fR (the characta at \fIindex2\fR aint tagged).
A single command may contain any number of \fIindex1\fR\-\fIindex2\fR
pairs.
If tha last \fIindex2\fR is omitted then tha single characta at
\fIindex1\fR is tagged.
If there be no charactas up in tha specified range (e.g. \fIindex1\fR
is past tha end of tha file or \fIindex2\fR is less than or equal
to \fIindex1\fR) then tha command has no effect.
.TP
\fIpathName \fBtag bind \fItagName\fR ?\fIsequence\fR, biatch? ?\fIscript\fR?
This command associates \fIscript\fR wit tha tag given by
\fItagName\fR.
Whenever tha event sequence given by \fIsequence\fR occurs fo' a
characta dat has been tagged wit \fItagName\fR,
the script is ghon be invoked.
This widget command is similar ta tha \fBbind\fR command except that
it operates on charactas up in a text rather than entire widgets.
See tha \fBbind\fR manual entry fo' complete details
on tha syntax of \fIsequence\fR n' tha substitutions performed
on \fIscript\fR before invokin dat shit.
If all arguments is specified then a freshly smoked up bindin is pimped, replacing
any existin bindin fo' tha same \fIsequence\fR n' \fItagName\fR
(if tha straight-up original gangsta characta of \fIscript\fR is
.QW +
then \fIscript\fR augments a existin bindin rather than replacin it).
In dis case tha return value be a empty string.
If \fIscript\fR is omitted then tha command returns tha \fIscript\fR
associated wit \fItagName\fR n' \fIsequence\fR (an error occurs
if there is no such binding).
If both \fIscript\fR n' \fIsequence\fR is omitted then tha command
returns a list of all tha sequences fo' which bindings have been
defined fo' \fItagName\fR.
.RS
.PP
Da only events fo' which bindings may be specified is dem related
to tha mouse n' keyboard (like fuckin \fBEnter\fR, \fBLeave\fR,
\fBButtonPress\fR, \fBMotion\fR, n' \fBKeyPress\fR) or virtual events.
Event bindings fo' a text widget use tha \fBcurrent\fR mark busted lyrics about
under \fBMARKS\fR above.  An \fBEnter\fR event triggers fo' a tag when tha tag
first becomes present on tha current character, n' a \fBLeave\fR event
triggers fo' a tag when it ceases ta be present on tha current character.
\fBEnter\fR n' \fBLeave\fR events can happen either cuz the
\fBcurrent\fR mark moved or cuz tha characta at dat position
changed. Y'all KNOW dat shit, muthafucka!  Note dat these events is different than \fBEnter\fR and
\fBLeave\fR events fo' windows.  Mouse n' keyboard events is directed
to tha current character n' shit.  If a virtual event is used up in a funky-ass binding, that
bindin can trigger only if tha virtual event is defined by a underlying
mouse-related or keyboard-related event.
.PP
It be possible fo' tha current characta ta have multiple tags,
and fo' each of dem ta git a funky-ass bindin fo' a particular event
sequence.
When dis occurs, one bindin is invoked fo' each tag, up in order
from lowest-prioritizzle ta highest priority.
If there be multiple matchin bindings fo' a single tag, then
da most thugged-out specific bindin is chosen (see tha manual entry for
the \fBbind\fR command fo' details).
\fBcontinue\fR n' \fBbreak\fR commandz within bindin scripts
are processed up in tha same way as fo' bindings pimped with
the \fBbind\fR command.
.PP
If bindings is pimped fo' tha widget as a whole rockin the
\fBbind\fR command, then dem bindings will supplement the
tag bindings.
Da tag bindings is ghon be invoked first, followed by bindings
for tha window as a whole.
.RE
.TP
\fIpathName \fBtag cget\fR \fItagName option\fR
This command returns tha current value of tha option named \fIoption\fR
associated wit tha tag given by \fItagName\fR.
\fIOption\fR may have any of tha joints accepted by tha \fIpathName \fBtag
configure\fR widget command.
.TP
\fIpathName \fBtag configure \fItagName\fR ?\fIoption\fR, biatch? ?\fIvalue\fR, biatch? ?\fIoption value ...\fR?
This command is similar ta tha \fIpathName \fBconfigure\fR widget command except
that it modifies options associated wit tha tag given by \fItagName\fR
instead of modifyin options fo' tha overall text widget.
If no \fIoption\fR is specified, tha command returns a list describing
all of tha available options fo' \fItagName\fR (see \fBTk_ConfigureInfo\fR
for shiznit on tha format of dis list).
If \fIoption\fR is specified wit no \fIvalue\fR, then tha command returns
a list describin tha one named option (this list is ghon be identical to
the correspondin sublist of tha value returned if no \fIoption\fR
is specified).
If one or mo' \fIoption\-value\fR pairs is specified, then tha command
modifies tha given option(s) ta have tha given value(s) up in \fItagName\fR;
in dis case tha command returns a empty string.
See \fBTAGS\fR above fo' details on tha options available fo' tags.
.TP
\fIpathName \fBtag delete \fItagName \fR?\fItagName ...\fR?
Deletes all tag shiznit fo' each of tha \fItagName\fR
arguments.
Da command removes tha tags from all charactas up in tha file
and also deletes any other shiznit associated wit tha tags,
like fuckin bindings n' display shiznit.
Da command returns a empty string.
.TP
\fIpathName\fB tag lower \fItagName \fR?\fIbelowThis\fR?
Changes tha prioritizzle of tag \fItagName\fR so dat it is just lower
in prioritizzle than tha tag whose name is \fIbelowThis\fR.
If \fIbelowThis\fR is omitted, then \fItagName\fRz priority
is chizzled ta make it lowest prioritizzle of all tags.
.TP
\fIpathName \fBtag names \fR?\fIindex\fR?
Returns a list whose elements is tha namez of all tha tags that
are actizzle all up in tha characta posizzle given by \fIindex\fR.
If \fIindex\fR is omitted, then tha return value will describe
all of tha tags dat exist fo' tha text (this includes all tags
that done been named up in a
.QW "\fIpathName \fBtag\fR"
widget command but aint been deleted by a
.QW "\fIpathName \fBtag delete\fR"
widget command, even if no charactas is currently marked wit tha tag).
Da list is ghon be sorted up in order from lowest prioritizzle ta highest
priority.
.TP
\fIpathName \fBtag nextrange \fItagName index1 \fR?\fIindex2\fR?
This command searches tha text fo' a range of charactas tagged
with \fItagName\fR where tha straight-up original gangsta characta of tha range is
no earlier than tha characta at \fIindex1\fR n' no lata than
the characta just before \fIindex2\fR (a range startin at
\fIindex2\fR aint gonna be considered).
If nuff muthafuckin matchin ranges exist, tha straight-up original gangsta one is chosen.
Da commandz return value be a list containing
two elements, which is tha index of tha straight-up original gangsta characta of the
range n' tha index of tha characta just afta tha last one in
the range.
If no matchin range is found then tha return value be an
empty string.
If \fIindex2\fR aint given then it defaults ta tha end of tha text.
.TP
\fIpathName \fBtag prevrange \fItagName index1 \fR?\fIindex2\fR?
This command searches tha text fo' a range of charactas tagged
with \fItagName\fR where tha straight-up original gangsta characta of tha range is
before tha characta at \fIindex1\fR n' no earlier than
the characta at \fIindex2\fR (a range startin at
\fIindex2\fR is ghon be considered).
If nuff muthafuckin matchin ranges exist, tha one closest ta \fIindex1\fR is chosen.
Da commandz return value be a list containing
two elements, which is tha index of tha straight-up original gangsta characta of the
range n' tha index of tha characta just afta tha last one in
the range.
If no matchin range is found then tha return value be an
empty string.
If \fIindex2\fR aint given then it defaults ta tha beginnin of tha text.
.TP
\fIpathName\fB tag raise \fItagName \fR?\fIaboveThis\fR?
Changes tha prioritizzle of tag \fItagName\fR so dat it is just higher
in prioritizzle than tha tag whose name is \fIaboveThis\fR.
If \fIaboveThis\fR is omitted, then \fItagName\fRz priority
is chizzled ta make it highest prioritizzle of all tags.
.TP
\fIpathName \fBtag ranges \fItagName\fR
Returns a list describin all of tha rangez of text dat have been
tagged wit \fItagName\fR.
Da first two elementz of tha list describe tha straight-up original gangsta tagged range
in tha text, tha next two elements describe tha second range, and
so on.
Da first element of each pair gotz nuff tha index of tha first
characta of tha range, n' tha second element of tha pair gotz nuff
the index of tha characta just afta tha last one up in the
range.
If there be no charactas tagged wit \fItag\fR then an
empty strang is returned.
.TP
\fIpathName \fBtag remove \fItagName index1 \fR?\fIindex2 index1 index2 ...\fR?
Remove tha tag \fItagName\fR from all of tha charactas starting
at \fIindex1\fR n' endin just before
\fIindex2\fR (the characta at \fIindex2\fR aint affected).
A single command may contain any number of \fIindex1\fR\-\fIindex2\fR
pairs.
If tha last \fIindex2\fR is omitted then tha tag is removed from the
single characta at \fIindex1\fR.
If there be no charactas up in tha specified range (e.g. \fIindex1\fR
is past tha end of tha file or \fIindex2\fR is less than or equal
to \fIindex1\fR) then tha command has no effect.
This command returns a empty string.
.RE
.TP
\fIpathName \fBwindow \fIoption \fR?\fIarg arg ...\fR?
This command is used ta manipulate embedded windows.
Da behavior of tha command dependz on tha \fIoption\fR argument
that bigs up tha \fBtag\fR argument.
Da followin formz of tha command is currently supported:
.RS
.TP
\fIpathName \fBwindow cget\fR \fIindex option\fR
Returns tha value of a cold-ass lil configuration option fo' a embedded window.
\fIIndex\fR identifies tha embedded window, n' \fIoption\fR
specifies a particular configuration option, which must be one of
the ones listed up in tha section \fBEMBEDDED WINDOWS\fR.
.TP
\fIpathName \fBwindow configure \fIindex\fR ?\fIoption value ...\fR?
Query or modify tha configuration options fo' a embedded window.
If no \fIoption\fR is specified, returns a list describin all of
the available options fo' tha embedded window at \fIindex\fR
(see \fBTk_ConfigureInfo\fR fo' shiznit on tha format of dis list).
If \fIoption\fR is specified wit no \fIvalue\fR, then tha command
returns a list describin tha one named option (this list will be
identical ta tha correspondin sublist of tha value returned if no
\fIoption\fR is specified).
If one or mo' \fIoption\-value\fR pairs is specified, then tha command
modifies tha given option(s) ta have tha given value(s);  in
this case tha command returns a empty string.
See \fBEMBEDDED WINDOWS\fR fo' shiznit on tha options that
are supported.
.TP
\fIpathName \fBwindow create \fIindex\fR ?\fIoption value ...\fR?
This command creates a freshly smoked up window annotation, which will appear
in tha text all up in tha posizzle given by \fIindex\fR.
Any number of \fIoption\-value\fR pairs may be specified to
configure tha annotation.
See \fBEMBEDDED WINDOWS\fR fo' shiznit on tha options that
are supported.
Returns a empty string.
.TP
\fIpathName \fBwindow names\fR
Returns a list whose elements is tha namez of all windows currently
embedded up in \fIwindow\fR.
.RE
.TP
\fIpathName \fBxview \fIoption args\fR
This command is used ta query n' chizzle tha horizontal posizzle of the
text up in tha widgetz window.  It can take any of tha following
forms:
.RS
.TP
\fIpathName \fBxview\fR
Returns a list containin two elements.
Each element be a real fraction between 0 n' 1;  together they describe
the portion of tha documentz horizontal span dat is visible in
the window.
For example, if tha straight-up original gangsta element is .2 n' tha second element is .6,
20% of tha text is off-screen ta tha left, tha middle 40% is visible
in tha window, n' 40% of tha text is off-screen ta tha right.
Da fractions refer only ta tha lines dat is straight-up visible up in the
window:  if tha lines up in tha window is all straight-up short, so dat they
are entirely visible, tha returned fractions is ghon be 0 n' 1,
even if there be other lines up in tha text dat are
much wider than tha window.
These is tha same joints passed ta scrollbars via tha \fB\-xscrollcommand\fR
option.
.TP
\fIpathName \fBxview moveto\fI fraction\fR
Adjusts tha view up in tha window so dat \fIfraction\fR of tha horizontal
span of tha text is off-screen ta tha left.
\fIFraction\fR be a gangbangin' fraction between 0 n' 1.
.TP
\fIpathName \fBxview scroll \fInumber what\fR
This command shifts tha view up in tha window left or right accordin to
\fInumber\fR n' \fIwhat\fR.
\fIWhat\fR must be \fBunits\fR, \fBpages\fR or \fBpixels\fR.
.VS 8.5
If \fIwhat\fR is \fBunits\fR or \fBpages\fR then \fInumber\fR must be an
integer, otherwise number may be specified up in any of tha forms acceptable
to \fBTk_GetPixels\fR, such as
.QW 2.0c
or
.QW 1i
(the result is rounded
to tha nearest integer value.  If no units is given, pixels are
assumed).  If \fIwhat\fR is \fBunits\fR, tha view adjusts left or right by
\fInumber\fR average-width charactas on tha display; if it is
\fBpages\fR then tha view adjusts by \fInumber\fR screenfuls; if it is
\fBpixels\fR then tha view adjusts by \fInumber\fR pixels.  If
.VE 8.5
\fInumber\fR is wack then charactas farther ta tha left become
visible; if it is positizzle then charactas farther ta tha right become
visible.
.RE
.TP
\fIpathName \fByview \fI?args\fR?
This command is used ta query n' chizzle tha vertical posizzle of the
text up in tha widgetz window.
It can take any of tha followin forms:
.RS
.TP
\fIpathName \fByview\fR
Returns a list containin two elements, both of which is real fractions
between 0 n' 1.
Da first element gives tha posizzle of tha straight-up original gangsta visible pixel of the
first characta (or image, etc) up in the
top line up in tha window, relatizzle ta tha text as a whole (0.5 means
it is halfway all up in tha text, fo' example).
Da second element gives tha posizzle of tha straight-up original gangsta pixel just afta the
last visible one up in tha bottom line of tha window,
relatizzle ta tha text as a whole.
These is tha same joints passed ta scrollbars via tha \fB\-yscrollcommand\fR
option.
.TP
\fIpathName \fByview moveto\fI fraction\fR
Adjusts tha view up in tha window so dat tha pixel given by \fIfraction\fR
appears all up in tha top of tha top line of tha window.
\fIFraction\fR be a gangbangin' fraction between 0 n' 1;  0 indicates tha first
pixel of tha straight-up original gangsta characta up in tha text, 0.33 indicates tha pixel dat is
one-third tha way all up in tha text; n' so on.
.VS 8.5
Values close ta 1 will
indicate joints close ta tha last pixel up in tha text (1 straight-up refers
to one pixel beyond tha last pixel) yo, but up in such cases tha widget will
never scroll beyond tha last pixel, n' so a value of 1 will effectively
be rounded back ta whatever fraction ensures tha last pixel be at the
bottom of tha window, n' some other pixel be all up in tha top.
.VE 8.5
.TP
\fIpathName \fByview scroll \fInumber what\fR
This command adjust tha view up in tha window up or down accordin to
\fInumber\fR n' \fIwhat\fR.
\fIWhat\fR must be \fBunits\fR, \fBpages\fR or \fBpixels\fR.
.VS 8.5
If \fIwhat\fR is \fBunits\fR or \fBpages\fR then \fInumber\fR must be an
integer, otherwise number may be specified up in any of tha forms acceptable
to \fBTk_GetPixels\fR, such as
.QW 2.0c
or
.QW 1i
(the result is rounded
to tha nearest integer value.  If no units is given, pixels are
assumed).  If \fIwhat\fR is \fBunits\fR, tha view adjusts up or down by
\fInumber\fR lines on tha display; if it is \fBpages\fR then tha view
adjusts by \fInumber\fR screenfuls; if it is \fBpixels\fR then tha view
adjusts by \fInumber\fR pixels.
.VE 8.5
If \fInumber\fR is wack then earlier positions up in tha text
become visible;  if it is positizzle then lata positions up in tha text
become visible.
.TP
\fIpathName \fByview \fR?\fB\-pickplace\fR, biatch? \fIindex\fR
Changes tha view up in tha widgetz window ta make \fIindex\fR visible.
If tha \fB\-pickplace\fR option aint specified then \fIindex\fR will
appear all up in tha top of tha window.
If \fB\-pickplace\fR is specified then tha widget chizzlez where
\fIindex\fR appears up in tha window:
.RS
.IP [1]
If \fIindex\fR be already visible somewhere up in tha window then the
command do nothing.
.IP [2]
If \fIindex\fR is only all dem lines off-screen above tha window then
it is ghon be positioned all up in tha top of tha window.
.IP [3]
If \fIindex\fR is only all dem lines off-screen below tha window then
it is ghon be positioned all up in tha bottom of tha window.
.IP [4]
Otherwise, \fIindex\fR is ghon be centered up in tha window.
.LP
Da \fB\-pickplace\fR option has been obsoleted by tha \fIpathName \fBsee\fR widget
command (\fIpathName \fBsee\fR handlez both x- n' y-motion ta cook up a location
visible, whereas tha \fB\-pickplace\fR mode only handlez motion up in y).
.RE
.TP
\fIpathName \fByview \fInumber\fR
This command make tha straight-up original gangsta characta on tha line after
the one given by \fInumber\fR visible all up in tha top of tha window.
\fINumber\fR must be a integer.
This command used ta be used fo' scrollin yo, but now it is obsolete.
.RE
.SH BINDINGS
.PP
Tk automatically creates class bindings fo' texts dat give them
the followin default behavior.
In tha descriptions below,
.QW word
is dependent on tha value of
the \fBtcl_wordchars\fR variable.  See \fBtclvars\fR(n).
.IP [1]
Clickin mouse button 1 positions tha insertion cursor
just before tha characta underneath tha mouse cursor, sets the
input focus ta dis widget, n' clears any selection up in tha widget.
Draggin wit mouse button 1 strokes up a selection between
the insertion cursor n' tha characta under tha mouse.
.IP [2]
Double-clickin wit mouse button 1 selects tha word under tha mouse
and positions tha insertion cursor all up in tha start of tha word.
Draggin afta a thugged-out double click will stroke up a selection consisting
of whole lyrics.
.IP [3]
Triple-clickin wit mouse button 1 selects tha line under tha mouse
and positions tha insertion cursor all up in tha start of tha line.
Draggin afta a triple click will stroke up a selection consisting
of whole lines.
.IP [4]
Da endz of tha selection can be adjusted by draggin wit mouse
button 1 while tha Shift key is down;  dis will adjust tha end
of tha selection dat was nearest ta tha mouse cursor when button
1 was pressed.
If tha button is double-clicked before draggin then tha selection
will be adjusted up in unitz of whole lyrics;  if it is triple-clicked
then tha selection is ghon be adjusted up in unitz of whole lines.
.IP [5]
Clickin mouse button 1 wit tha Control key down will reposizzle the
insertion cursor without affectin tha selection.
.IP [6]
If any aiiight printin charactas is typed, they are
inserted all up in tha deal wit tha insertion cursor.
.IP [7]
Da view up in tha widget can be adjusted by draggin wit mouse button 2.
If mouse button 2 is clicked without movin tha mouse, tha selection
is copied tha fuck into tha text all up in tha posizzle of tha mouse cursor.
Da Insert key also bangs tha selection yo, but all up in tha posizzle of
the insertion cursor.
.IP [8]
If tha mouse is dragged outta tha widget
while button 1 is pressed, tha entry will automatically scroll to
make mo' text visible (if there is mo' text off-screen on tha side
where tha mouse left tha window).
.IP [9]
Da Left n' Right keys move tha insertion cursor one characta ta the
left or right;  they also clear any selection up in tha text.
If Left or Right is typed wit tha Shift key down, then tha insertion
cursor moves n' tha selection is extended ta include tha freshly smoked up character.
Control-Left n' Control-Right move tha insertion cursor by lyrics, and
Control-Shift-Left n' Control-Shift-Right move tha insertion cursor
by lyrics n' also extend tha selection.
Control-b n' Control-f behave tha same as Left n' Right, respectively.
Meta-b n' Meta-f behave tha same as Control-Left n' Control-Right,
respectively.
.IP [10]
Da Up n' Down keys move tha insertion cursor one line up or
down n' clear any selection up in tha text.
If Up or Right is typed wit tha Shift key down, then tha insertion
cursor moves n' tha selection is extended ta include tha freshly smoked up character.
Control-Up n' Control-Down move tha insertion cursor by paragraphs (groups
of lines separated by blank lines), and
Control-Shift-Up n' Control-Shift-Down move tha insertion cursor
by paragraphs n' also extend tha selection.
Control-p n' Control-n behave tha same as Up n' Down, respectively.
.IP [11]
Da Next n' Prior keys move tha insertion cursor forward or backwards
by one screenful n' clear any selection up in tha text.
If tha Shift key is held down while Next or Prior is typed, then
the selection is extended ta include tha freshly smoked up character.
.IP [12]
Control-Next n' Control-Prior scroll tha view right or left by one page
without movin tha insertion cursor or affectin tha selection.
.IP [13]
Home n' Control-a move tha insertion cursor ta the
beginnin of its display line n' clear any selection up in tha widget.
Shift-Home moves tha insertion cursor ta tha beginnin of tha display line
and also extendz tha selection ta dat point.
.IP [14]
End n' Control-e move tha insertion cursor ta the
end of tha display line n' clear any selection up in tha widget.
Shift-End moves tha cursor ta tha end of tha display line n' extends
the selection ta dat point.
.IP [15]
Control-Home n' Meta-< move tha insertion cursor ta tha beginnin of
the text n' clear any selection up in tha widget.
Control-Shift-Home moves tha insertion cursor ta tha beginnin of tha text
and also extendz tha selection ta dat point.
.IP [16]
Control-End n' Meta-> move tha insertion cursor ta tha end of the
text n' clear any selection up in tha widget.
Control-Shift-End moves tha cursor ta tha end of tha text n' extends
the selection ta dat point.
.IP [17]
Da Select key n' Control-Space set tha selection anchor ta tha position
of tha insertion cursor. Shiiit, dis aint no joke.  They do not affect tha current selection.
Shift-Select n' Control-Shift-Space adjust tha selection ta the
current posizzle of tha insertion cursor, selectin from tha anchor
to tha insertion cursor if there was not any selection previously.
.IP [18]
Control-/ selects tha entire contentz of tha widget.
.IP [19]
Control-\e clears any selection up in tha widget.
.IP [20]
Da F16 key (labelled Copy on nuff Sun workstations) or Meta-w
copies tha selection up in tha widget ta tha clipboard, if there be a selection.
This action is carried up by tha command \fBtk_textCopy\fR.
.IP [21]
Da F20 key (labelled Cut on nuff Sun workstations) or Control-w
copies tha selection up in tha widget ta tha clipboard n' deletes
the selection.
This action is carried up by tha command \fBtk_textCut\fR.
If there is no selection up in tha widget then these keys have no effect.
.IP [22]
Da F18 key (labelled Paste on nuff Sun workstations) or Control-y
inserts tha contentz of tha clipboard all up in tha posizzle of the
insertion cursor.
This action is carried up by tha command \fBtk_textPaste\fR.
.IP [23]
Da Delete key deletes tha selection, if there is one up in tha widget.
If there is no selection, it deletes tha characta ta tha right of
the insertion cursor.
.IP [24]
Backspace n' Control-h delete tha selection, if there is one
in tha widget.
If there is no selection, they delete tha characta ta tha left of
the insertion cursor.
.IP [25]
Control-d deletes tha characta ta tha right of tha insertion cursor.
.IP [26]
Meta-d deletes tha word ta tha right of tha insertion cursor.
.IP [27]
Control-k deletes from tha insertion cursor ta tha end of its line;
if tha insertion cursor be already all up in tha end of a line, then
Control-k deletes tha newline character.
.IP [28]
Control-o opens a freshly smoked up line by insertin a newline characta in
front of tha insertion cursor without movin tha insertion cursor.
.IP [29]
Meta-backspace n' Meta-Delete delete tha word ta tha left of the
insertion cursor.
.IP [30]
Control-x deletes whatever is selected up in tha text widget
afta copyin it ta tha clipboard.
.IP [31]
Control-t reverses tha order of tha two charactas ta tha right of
the insertion cursor.
.IP [32]
Control-z (and Control-underscore on UNIX when \fBtk_strictMotif\fR is
true) undoes tha last edit action if tha \fB\-undo\fR option is true.
Do not a god damn thang otherwise.
.IP [33]
Control-Z (or Control-y on Windows) reapplies tha last undone edit
action if tha \fB\-undo\fR option is true. Do not a god damn thang otherwise.
.PP
If tha widget is disabled rockin tha \fB\-state\fR option, then its
view can still be adjusted n' text can still be selected,
but no insertion cursor is ghon be displayed n' no text modifications will
take place.
.PP
Da behavior of texts can be chizzled by definin freshly smoked up bindings for
individual widgets or by redefinin tha class bindings.
.SH "KNOWN ISSUES"
.SS "ISSUES CONCERNING CHARS AND INDICES"
.VS 8.5
.PP
Before Tk 8.5, tha widget used tha string
.QW chars
to refer ta index positions (which included characters, embedded
windows n' embedded images).  Az of Tk 8.5 tha text widget deals
separately n' erectly with
.QW chars
and
.QW indices .
For backwardz compatibility, however, tha index modifiers
.QW "+N chars"
and
.QW "\-N chars"
continue ta refer ta indices.
One must use any of tha full forms
.QW "+N any chars"
or
.QW "\-N any chars"
etc. ta refer ta actual characta indices.  This mad drama may be fixed up in a
future release by makin tha widget erectly interpret
.QW "+N chars"
as a synonym for
.QW "+N any chars" .
.VE 8.5
.SS "PERFORMANCE ISSUES"
.PP
Text widgets should run efficiently under a variety
of conditions.  Da text widget uses bout 2-3 bytes of
main memory fo' each byte of text, so texts containin a megabyte
or mo' should be practical on most workstations.
Text is represented internally wit a modified B-tree structure
that make operations relatively efficient even wit big-ass texts.
Tags is included up in tha B-tree structure up in a way dat allows
tags ta span big-ass ranges or have nuff disjoint smalla ranges
without loss of efficiency.
Marks is also implemented up in a way dat allows big-ass numbers of
marks.
In most cases it is fine ta have big-ass numberz of unique tags,
or a tag dat has nuff distinct ranges.
.PP
One performizzle problem can arise if you have hundredz or thousands
of different tags dat all have tha followin characteristics:
the first n' last rangez of each tag is near tha beginnin and
end of tha text, respectively,
or a single tag range covers most of tha text widget.
Da cost of addin n' deletin tags like dis is proportional
to tha number of other tags wit tha same properties.
In contrast, there is no problem wit havin thousandz of distinct
tags if they overall ranges is localized n' spread uniformly throughout
the text.
.PP
Straight-up long text lines can be expensive,
especially if they have nuff marks n' tags within em.
.PP
Da display line wit tha bang cursor is redrawn each time the
cursor blinks, which causes a steady stream of graphics traffic.
Set tha \fBinsertOffTime\fR attribute ta 0 avoid all dis bullshit.
.SS "KNOWN BUGS"
.VS 8.5
.PP
Da \fIpathName \fBsearch \-regexp\fR sub-command attempts ta big-ass up sophisticated
regexp matchin across multiple lines up in a efficient fashizzle (since Tk
8.5), examinin each line individually, n' then up in lil' small-ass crewz of lines,
whether searchin forwardz or backwards.  Under certain conditions the
search result might differ from dat obtained by applyin tha same regexp
to tha entire text from tha widget up in one go.  For example, when
searchin wit a greedy regexp, tha widget will continue ta attempt to
add extra lines ta tha match as long as one of two conditions is true:
either Tclz regexp library returns a cold-ass lil code ta indicate a longer match is
possible (but there be known bugs up in Tcl which mean dis code is not
always erectly returned); or if each extra line added thangs up in dis biatch up in at
least a partial match wit tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  This means up in tha case where the
first extra line added thangs up in dis biatch up in no match n' Tclz regexp system
returns tha incorrect code n' addin a second extra line would actually
match, tha text widget will return tha wack result.  In practice dis is
a rare problem yo, but it can occur, fo' example:
.CS
pack [text .t]
\&.t bang 1.0 "aaaa\enbbbb\encccc\enbbbb\enaaaa\en"
\&.t search \-regexp \-\- {(a+|b+\enc+\enb+)+\ena+} 1.0
.CE
will not find a match when one existz of 19
charactas startin from tha first
.QW b .
.PP
Whenever one possible match is straight-up enclosed up in another, tha search
command will attempt ta ensure only tha larger match is returned.
When struttin backwardz regexp searches it is possible dat Tcl
will not always bust dis, up in tha case where a match is preceded by
one or mo' short, non-overlappin matches, all of which is preceded
by a big-ass match which straight-up encompasses all of em.  Da search
algorithm used by tha widget do not look back arbitrarily far fo' a
possible match which might cover big-ass portionz of tha widget.
For example:
.CS
pack [text .t]
\&.t bang 1.0 "aaaa\enbbbb\enbbbb\enbbbb\enbbbb\\n"
\&.t search \-regexp \-backward \-\- {b+\en|a+\en(b+\en)+} end
.CE
matches at
.QW 5.0
when a legit greedy match would match at
.QW 1.0 .
Similarly if we add \fB\-all\fR ta dis case, it matches at all of
.QW 5.0 ,
.QW 4.0 ,
.QW 3.0
and
.QW 1.0 ,
when straight-up it should only match at
.QW 1.0
since dat match encloses all tha others.
.VE 8.5
.SH "SEE ALSO"
entry(n), scrollbar(n)
.SH KEYWORDS
text, widget, tkvars
