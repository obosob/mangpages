'\"
'\" Copyright (c) 1992-1994 Da Regentz of tha Universitizzle of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\" Copyright (c) 1997-1999 Scriptics Corporation.
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
'\"
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type, biatch? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version, biatch? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH canvas n 8.3 Tk "Tk Built-In Commands"
.BS
'\" Note:  do not modify tha .SH NAME line immediately below!
.SH NAME
canvas \- Smoke n' manipulate canvas widgets
.SH SYNOPSIS
\fBcanvas\fR \fIpathName \fR?\fIoptions\fR?
.SO
\-background	\-borderwidth	\-cursor
\-highlightbackground	\-highlightcolor	\-highlightthickness
\-insertbackground	\-insertborderwidth	\-insertofftime
\-insertontime	\-insertwidth	\-relief
\-selectbackground	\-selectborderwidth	\-selectforeground
\-takefocus	\-xscrollcommand	\-yscrollcommand
.SE
.SH "WIDGET-SPECIFIC OPTIONS"
.OP \-closeenough closeEnough CloseEnough
Specifies a gangbangin' floating-point value indicatin how tha fuck close tha mouse cursor
must be ta a item before it is considered ta be
.QW inside
the item. Defaults ta 1.0.
.OP \-confine confine Confine
Specifies a funky-ass boolean value dat indicates whether or not it should be
allowable ta set tha canvass view outside tha region defined by the
\fBscrollRegion\fR argument.
Defaults ta true, which means dat tha view will
be constrained within tha scroll region.
.OP \-height height Height
Specifies a thugged-out desired window height dat tha canvas widget should request from
its geometry manager n' shit.  Da value may be specified up in any
of tha forms busted lyrics bout up in tha \fBCOORDINATES\fR section below.
.OP \-scrollregion scrollRegion ScrollRegion
Specifies a list wit four coordinates describin tha left, top, right, and
bottom coordinatez of a rectangular region.
This region is used fo' scrollin purposes n' is considered ta be
the boundary of tha shiznit up in tha canvas.
Each of tha coordinates may be specified
in any of tha forms given up in tha \fBCOORDINATES\fR section below.
.OP \-state state State
Modifies tha default state of tha canvas where \fIstate\fR may be set to
one of: \fBnormal\fR, \fBdisabled\fR, or \fBhidden\fR. Individual canvas
objects all have they own state option which may override tha default
state.  Many options can take separate justifications such dat the
appearizzle of tha item can be different up in different thangs. The
options dat start wit \fBactive\fR control tha appearizzle when tha mouse
pointa is over it, while tha option startin wit \fBdisabled\fR controls
the appearizzle when tha state is disabled. Y'all KNOW dat shit, muthafucka!  Canvas shit which are
\fBdisabled\fR aint gonna react ta canvas bindings.
.OP \-width width width
Specifies a thugged-out desired window width dat tha canvas widget should request from
its geometry manager n' shit.  Da value may be specified up in any
of tha forms busted lyrics bout up in tha \fBCOORDINATES\fR section below.
.OP \-xscrollincrement xScrollIncrement ScrollIncrement
Specifies a increment fo' horizontal scrolling, up in any of tha usual forms
permitted fo' screen distances.  If tha value of dis option is pimped outer
than zero, tha horizontal view up in tha window is ghon be constrained so that
the canvas x coordinizzle all up in tha left edge of tha window be always a even
multiple of \fBxScrollIncrement\fR;  furthermore, tha units fo' scrolling
(e.g., tha chizzle up in view when tha left n' right arrowz of a scrollbar
are selected) will also be \fBxScrollIncrement\fR.  If tha value of
this option is less than or equal ta zero, then horizontal scrolling
is unconstrained.
.OP \-yscrollincrement yScrollIncrement ScrollIncrement
Specifies a increment fo' vertical scrolling, up in any of tha usual forms
permitted fo' screen distances.  If tha value of dis option is pimped outer
than zero, tha vertical view up in tha window is ghon be constrained so that
the canvas y coordinizzle all up in tha top edge of tha window be always a even
multiple of \fByScrollIncrement\fR;  furthermore, tha units fo' scrolling
(e.g., tha chizzle up in view when tha top n' bottom arrowz of a scrollbar
are selected) will also be \fByScrollIncrement\fR.  If tha value of
this option is less than or equal ta zero, then vertical scrolling
is unconstrained.
.BE
.SH INTRODUCTION
.PP
Da \fBcanvas\fR command creates a freshly smoked up window (given
by tha \fIpathName\fR argument) n' make it tha fuck into a cold-ass lil canvas widget.
Additionizzle options, busted lyrics bout above, may be specified on the
command line or up in tha option database
to configure aspectz of tha canvas like fuckin its flavas n' 3-D relief.
Da \fBcanvas\fR command returns its
\fIpathName\fR argument.  At tha time dis command is invoked,
there must not exist a window named \fIpathName\fR yo, but
\fIpathName\fRz parent must exist.
.PP
Canvas widgets implement structured graphics.
A canvas displays any number of \fIitems\fR, which may be thangs like
rectangles, circles, lines, n' text.
Items may be manipulated (e.g. moved or re-colored) n' commandz may
be associated wit shit up in much tha same way dat tha \fBbind\fR
command allows commandz ta be bound ta widgets, n' you can put dat on yo' toast.  For example,
a particular command may be associated wit tha <Button-1> event
so dat tha command is invoked whenever button 1 is pressed with
the mouse cursor over a item.
This means dat shit up in a cold-ass lil canvas can have behaviors defined by
the Tcl scripts bound ta em.
.SH "DISPLAY LIST"
.PP
Da shit up in a cold-ass lil canvas is ordered fo' purposez of display,
with tha straight-up original gangsta item up in tha display list bein displayed
first, followed by tha next item up in tha list, n' so on.
Items lata up in tha display list obscure dem dat are
earlier up in tha display list n' is sometimes referred ta as being
.QW "on top"
of earlier items.
When a freshly smoked up item is pimped it is placed all up in tha end of the
display list, on top of every last muthafuckin thang else.
Widget commandz may be used ta re-arrange tha order of the
display list.
.PP
Window shit is a exception ta tha above rules.  Da underlying
window systems require dem always ta be drawn on top of other items.
In addition, tha stackin order of window items
is not affected by any of tha canvas widget commands; you must use
the \fBraise\fR n' \fBlower\fR Tk commandz instead.
.SH "ITEM IDS AND TAGS"
.PP
Items up in a cold-ass lil canvas widget may be named up in either of two ways:
by id or by tag.
Each item has a unique identifyin number, which be assigned to
that item when it is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da id of a item never chizzles
and id numbers is never re-used within tha gametime of a
canvas widget.
.PP
Each item may also have any number of \fItags\fR associated
with dat shit.  A tag is just a strang of characters, n' it may
take any form except dat of a integer.
For example,
.QW x123
is OK but
.QW 123
is not.
Da same tag may be associated wit nuff different items.
This is commonly done ta crew shit up in various interesting
ways;  fo' example, all selected shit might be given tha tag
.QW selected .
.PP
Da tag \fBall\fR is implicitly associated wit every last muthafuckin item
in tha canvas;  it may be used ta invoke operations on
all tha shit up in tha canvas.
.PP
Da tag \fBcurrent\fR is managed automatically by Tk;
it applies ta tha \fIcurrent item\fR, which is the
topmost item whose drawn area covers tha posizzle of
the mouse cursor (different item types interpret dis up in varyin ways; peep the
individual item type documentation fo' details).
If tha mouse aint up in tha canvas widget or aint over
an item, then no item has tha \fBcurrent\fR tag.
.PP
When specifyin shit up in canvas widget commands, if the
specifier be a integer then it be assumed ta refer to
the single item wit dat id.
If tha specifier aint a integer, then it be assumed to
refer ta all of tha shit up in tha canvas dat gotz a tag
matchin tha specifier.
Da symbol \fItagOrId\fR is used below ta indicate that
an argument specifies either a id dat selects a single
item or a tag dat selects zero or mo' items.
.PP
\fItagOrId\fR may contain a logical expressions of
tags by rockin operators:
.QW \fB&&\fR ,
.QW \fB||\fR ,
.QW \fB^\fR ,
.QW \fB!\fR ,
and parenthesized subexpressions.  For example:
.CS
      .c find withtag {(a&&!b)||(!a&&b)}
.CE
or equivalently:
.CS
      .c find withtag {a^b}
.CE
will find only dem shit wit either
.QW a
or
.QW b
tags yo, but not both.
.PP
Some widget commandz only operate on a single item at a
time;  if \fItagOrId\fR is specified up in a way that
names multiple items, then tha aiiight behavior is for
the command ta use tha straight-up original gangsta (lowest) of these shit in
the display list dat is suitable fo' tha command.
Exceptions is noted up in tha widget command descriptions
below.
.SH "COORDINATES"
.PP
All coordinates related ta canvases is stored as floating-point
numbers.
Coordinates n' distances is specified up in screen units,
which is floating-point numbers optionally followed
by one of nuff muthafuckin letters.
If no letta is supplied then tha distizzle is up in pixels.
If tha letta is \fBm\fR then tha distizzle is up in millimetas on
the screen;  if it is \fBc\fR then tha distizzle is up in centimeters;
\fBi\fR means inches, n' \fBp\fR means printas points (1/72 inch).
Larger y-coordinates refer ta points lower on tha screen;  larger
x-coordinates refer ta points farther ta tha right.
Coordinates can be specified either as a even number of parameters,
or as a single list parameta containin a even number of x n' y
coordinizzle joints.
.SS TRANSFORMATIONS
.PP
Normally tha origin of tha canvas coordinizzle system be at the
upper-left corner of tha window containin tha canvas.
It be possible ta adjust tha origin of tha canvas
coordinizzle system relatizzle ta tha origin of tha window rockin the
\fBxview\fR n' \fByview\fR widget commands;  dis is typically used
for scrolling.
Canvases do not support scalin or rotation of tha canvas coordinate
system relatizzle ta tha window coordinizzle system.
.PP
Individual shit may be moved or scaled rockin widget commands
busted lyrics bout below yo, but they may not be rotated.
.PP
Note dat tha default origin of tha canvass visible area is
coincident wit tha origin fo' tha whole window as dat make bindings
usin tha mouse posizzle easier ta work with; you only need ta use the
\fBcanvasx\fR n' \fBcanvasy\fR widget commandz if you adjust the
origin of tha visible area.  But fuck dat shiznit yo, tha word on tha street is dat dis also means dat any focus
rin (as controlled by tha \fB\-highlightthickness\fR option) and
window border (as controlled by tha \fB\-borderwidth\fR option) must
be taken tha fuck into account before you git ta tha visible area of the
canvas.
.SH "INDICES"
.PP
Text shit support tha notion of a \fIindex\fR fo' identifying
particular positions within tha item.
In a similar fashion, line n' polygon shit support \fIindex\fR for
identifying, insertin n' deletin subsetz of they coordinates.
Indices is used fo' commandz like fuckin insertin or deleting
a range of charactas or coordinates, n' settin tha insertion
cursor position. I aint talkin' bout chicken n' gravy biatch fo' realz. An index may be specified up in any of a number
of ways, n' different typez of shit may support different forms
for specifyin indices.
Text shit support tha followin forms fo' a index;  if you
define freshly smoked up typez of text-like items, it would be advisable to
support as nuff of these forms as practical.
Note dat it is possible ta refer ta tha characta just after
the last one up in tha text item;  dis is necessary fo' such
tasks as insertin freshly smoked up text all up in tha end of tha item.
Lines n' Polygons do not support tha insertion cursor
and tha selection. I aint talkin' bout chicken n' gravy biatch. Their indices is supposed ta be even
always, cuz coordinates always step tha fuck up in pairs.
.TP 10
\fInumber\fR
A decimal number givin tha posizzle of tha desired character
within tha text item.
0 refers ta tha straight-up original gangsta character, 1 ta tha next character, and
so on. I aint talkin' bout chicken n' gravy biatch. If indexes is odd fo' lines n' polygons, they will be
automatically decremented by one.
A number less than 0 is treated as if it was zero, n' a
number pimped outa than tha length of tha text item is treated
as if it was equal ta tha length of tha text item. For
polygons, numbers less than 0 or pimped outa then tha length
of tha coordinizzle list is ghon be adjusted by addin or subtracting
the length until tha result is between zero n' tha length,
inclusive.
.TP 10
\fBend\fR
Refers ta tha characta or coordinizzle just afta tha last one
in tha item (same as tha number of charactas or coordinates
in tha item).
.TP 10
\fBinsert\fR
Refers ta tha characta just before which tha insertion cursor
is drawn up in dis item. Not valid fo' lines n' polygons.
.TP 10
\fBsel.first\fR
Refers ta tha straight-up original gangsta selected characta up in tha item.
If tha selection aint up in dis item then dis form is illegal.
.TP 10
\fBsel.last\fR
Refers ta tha last selected characta up in tha item.
If tha selection aint up in dis item then dis form is illegal.
.TP 10
\fB@\fIx,y\fR
Refers ta tha characta or coordinizzle all up in tha point given by \fIx\fR and
\fIy\fR, where \fIx\fR n' \fIy\fR is specified up in tha coordinate
system of tha canvas.
If \fIx\fR n' \fIy\fR lie outside tha coordinates covered by the
text item, then they refer ta tha straight-up original gangsta or last characta up in the
line dat is closest ta tha given point.
.SH "DASH PATTERNS"
.PP
Many shit support tha notion of a thugged-out dash pattern fo' outlines.
.PP
Da first possible syntax be a list of integers. Each element
represents tha number of pixelz of a line segment. Only tha odd
segments is drawn rockin the
.QW outline
color. Shiiit, dis aint no joke. Da other segments is drawn transparent.
.PP
Da second possible syntax be a cold-ass lil characta list containin only
5 possible characters
.QW "\fB.,\-_ \fR" .
Da space can be used
to enpimpin' tha space between other line elements, n' cannot
occur as tha straight-up original gangsta posizzle up in tha string. Right back up in yo muthafuckin ass. Some examples:
.CS
\-dash .     \(-> \-dash {2 4}
\-dash \-     \(-> \-dash {6 4}
\-dash \-.    \(-> \-dash {6 4 2 4}
\-dash \-..   \(-> \-dash {6 4 2 4 2 4}
\-dash {. }  \(-> \-dash {2 8}
\-dash ,     \(-> \-dash {4 4}
.CE
.PP
Da main difference of dis syntax wit tha previous is dat it
is shape-conserving. This means dat all joints up in tha dash
list is ghon be multiplied by tha line width before display. This
assures that
.QW .
will always be displayed as a thugged-out dot and
.QW \-
always as a thugged-out dash regardless of tha line width.
.PP
On systems which support only a limited set of dash patterns, tha dash
pattern is ghon be displayed as tha closest dash pattern dat be available.
For example, on Windows only tha straight-up original gangsta 4 of tha above examplez are
available.  Da last 2 examplez is ghon be displayed identically ta tha first
one.
.SH "WIDGET COMMAND"
.PP
Da \fBcanvas\fR command creates a freshly smoked up Tcl command whose
name is \fIpathName\fR.  This
command may be used ta invoke various
operations on tha widget.  It has tha followin general form:
.CS
\fIpathName option \fR?\fIarg arg ...\fR?
.CE
\fIOption\fR n' tha \fIarg\fRs
determine tha exact behavior of tha command.
Da followin widget commandz is possible fo' canvas widgets:
.TP
\fIpathName \fBaddtag \fItag searchSpec \fR?\fIarg arg ...\fR?
For each item dat meets tha constraints specified by
\fIsearchSpec\fR n' tha \fIarg\fRs, add
\fItag\fR ta tha list of tags associated wit tha item if it
is not already present on dat list.
It be possible dat no shit will satisfy tha constraints
given by \fIsearchSpec\fR n' \fIarg\fRs, up in which case the
command has no effect.
This command returns a empty strang as result.
\fISearchSpec\fR n' \fIarg\fRz may take any of tha following
forms:
.RS
.TP
\fBabove \fItagOrId\fR
Selects tha item just afta (above) tha one given by \fItagOrId\fR
in tha display list.
If \fItagOrId\fR denotes mo' than one item, then tha last (topmost)
of these shit up in tha display list is used.
.TP
\fBall\fR
Selects all tha shit up in tha canvas.
.TP
\fBbelow \fItagOrId\fR
Selects tha item just before (below) tha one given by \fItagOrId\fR
in tha display list.
If \fItagOrId\fR denotes mo' than one item, then tha straight-up original gangsta (lowest)
of these shit up in tha display list is used.
.TP
\fBclosest \fIx y \fR?\fIhalo\fR, biatch? ?\fIstart\fR?
Selects tha item closest ta tha point given by \fIx\fR n' \fIy\fR.
If mo' than one item be all up in tha same closest distizzle (e.g. two
items overlap tha point), then tha top-most of these shit (the
last one up in tha display list) is used.
If \fIhalo\fR is specified, then it must be a non-negative
value.
Any item closer than \fIhalo\fR ta tha point is considered to
overlap dat shit.
Da \fIstart\fR argument may be used ta step circularly through
all tha closest items.
If \fIstart\fR is specified, it names a item rockin a tag or id
(if by tag, it selects tha straight-up original gangsta item up in tha display list with
the given tag).
Instead of selectin tha topmost closest item, dis form will
select tha topmost closest item dat is below \fIstart\fR in
the display list;  if no such item exists, then tha selection
behaves as if tha \fIstart\fR argument had not been specified.
.TP
\fBenclosed\fR \fIx1\fR \fIy1\fR \fIx2\fR \fIy2\fR
Selects all tha shit straight-up enclosed within tha rectangular
region given by \fIx1\fR, \fIy1\fR, \fIx2\fR, n' \fIy2\fR.
\fIX1\fR must be no pimped outa then \fIx2\fR n' \fIy1\fR must be
no pimped outa than \fIy2\fR.
.TP
\fBoverlapping\fR \fIx1\fR \fIy1\fR \fIx2\fR \fIy2\fR
Selects all tha shit dat overlap or is enclosed within the
rectangular region given by \fIx1\fR, \fIy1\fR, \fIx2\fR,
and \fIy2\fR.
\fIX1\fR must be no pimped outa then \fIx2\fR n' \fIy1\fR must be
no pimped outa than \fIy2\fR.
.TP
\fBwithtag \fItagOrId\fR
Selects all tha shit given by \fItagOrId\fR.
.RE
.TP
\fIpathName \fBbbox \fItagOrId\fR ?\fItagOrId tagOrId ...\fR?
Returns a list wit four elements givin a approximate boundin box
for all tha shit named by tha \fItagOrId\fR arguments.
Da list has tha form
.QW "\fIx1 y1 x2 y2\fR"
such dat tha drawn
areaz of all tha named elements is within tha region bounded by
\fIx1\fR on tha left, \fIx2\fR on tha right, \fIy1\fR on tha top,
and \fIy2\fR on tha bottom.
Da return value may overestimate tha actual boundin box by
a few pixels.
If no shit match any of tha \fItagOrId\fR arguments or if the
matchin shit have empty boundin boxes (i.e. they have nothing
to display)
then a empty strang is returned.
.TP
\fIpathName \fBbind \fItagOrId\fR ?\fIsequence\fR, biatch? ?\fIcommand\fR?
This command associates \fIcommand\fR wit all tha shit given by
\fItagOrId\fR such dat whenever tha event sequence given by
\fIsequence\fR occurs fo' one of tha shit tha command will
be invoked.
This widget command is similar ta tha \fBbind\fR command except that
it operates on shit up in a cold-ass lil canvas rather than entire widgets.
See tha \fBbind\fR manual entry fo' complete details
on tha syntax of \fIsequence\fR n' tha substitutions performed
on \fIcommand\fR before invokin dat shit.
If all arguments is specified then a freshly smoked up bindin is pimped, replacing
any existin bindin fo' tha same \fIsequence\fR n' \fItagOrId\fR
(if tha straight-up original gangsta characta of \fIcommand\fR is
.QW +
then \fIcommand\fR augments a existin bindin rather than replacin it).
In dis case tha return value be a empty string.
If \fIcommand\fR is omitted then tha command returns tha \fIcommand\fR
associated wit \fItagOrId\fR n' \fIsequence\fR (an error occurs
if there is no such binding).
If both \fIcommand\fR n' \fIsequence\fR is omitted then tha command
returns a list of all tha sequences fo' which bindings have been
defined fo' \fItagOrId\fR.
.RS
.PP
Da only events fo' which bindings may be specified is dem related to
the mouse n' keyboard (like fuckin \fBEnter\fR, \fBLeave\fR,
\fBButtonPress\fR, \fBMotion\fR, n' \fBKeyPress\fR) or virtual events.
Da handlin of events up in canvases uses tha current item defined in
\fBITEM IDS AND TAGS\fR above.  \fBEnter\fR n' \fBLeave\fR events
trigger fo' an
item when it becomes tha current item or ceases ta be tha current item;
note dat these events is different than \fBEnter\fR n' \fBLeave\fR
events fo' windows.  Mouse-related events is pimped up ta tha current
item, if any.  Keyboard-related events is pimped up ta tha focus item, if
any (see tha \fBfocus\fR widget command below fo' mo' on this).  If a
virtual event is used up in a funky-ass binding, dat bindin can trigger only if the
virtual event is defined by a underlyin mouse-related or
keyboard-related event.
.PP
It be possible fo' multiple bindings ta match a particular event.
This could occur, fo' example, if one bindin be associated wit the
itemz id n' another be associated wit one of tha itemz tags.
When dis occurs, all of tha matchin bindings is invoked.
A bindin associated wit tha \fBall\fR tag is invoked first,
followed by one bindin fo' each of tha itemz tags (in order),
followed by a funky-ass bindin associated wit tha itemz id.
If there be multiple matchin bindings fo' a single tag,
then only da most thugged-out specific bindin is invoked.
A \fBcontinue\fR command up in a funky-ass bindin script terminates that
script, n' a \fBbreak\fR command terminates dat script
and skips any remainin scripts fo' tha event, just as fo' the
\fBbind\fR command.
.PP
If bindings done been pimped fo' a cold-ass lil canvas window rockin tha \fBbind\fR
command, then they is invoked up in addizzle ta bindings pimped for
the canvass shit rockin tha \fBbind\fR widget command.
Da bindings fo' shit is ghon be invoked before any of tha bindings
for tha window as a whole.
.RE
.TP
\fIpathName \fBcanvasx \fIscreenx\fR ?\fIgridspacing\fR?
Given a window x-coordinizzle up in tha canvas \fIscreenx\fR, dis command returns
the canvas x-coordinizzle dat is displayed at dat location.
If \fIgridspacing\fR is specified, then tha canvas coordinizzle is
rounded ta tha nearest multiple of \fIgridspacing\fR units.
.TP
\fIpathName \fBcanvasy \fIscreeny\fR ?\fIgridspacing\fR?
Given a window y-coordinizzle up in tha canvas \fIscreeny\fR dis command returns
the canvas y-coordinizzle dat is displayed at dat location.
If \fIgridspacing\fR is specified, then tha canvas coordinizzle is
rounded ta tha nearest multiple of \fIgridspacing\fR units.
.TP
\fIpathName \fBcget\fR \fIoption\fR
Returns tha current value of tha configuration option given
by \fIoption\fR.
\fIOption\fR may have any of tha joints accepted by tha \fBcanvas\fR
command.
.TP
\fIpathName \fBconfigure ?\fIoption\fR, biatch? ?\fIvalue\fR, biatch? ?\fIoption value ...\fR?
Query or modify tha configuration optionz of tha widget.
If no \fIoption\fR is specified, returns a list describin all of
the available options fo' \fIpathName\fR (see \fBTk_ConfigureInfo\fR for
information on tha format of dis list).  If \fIoption\fR is specified
with no \fIvalue\fR, then tha command returns a list describin the
one named option (this list is ghon be identical ta tha corresponding
sublist of tha value returned if no \fIoption\fR is specified).  If
one or mo' \fIoption\-value\fR pairs is specified, then tha command
modifies tha given widget option(s) ta have tha given value(s);  in
this case tha command returns a empty string.
\fIOption\fR may have any of tha joints accepted by tha \fBcanvas\fR
command.
.TP
\fIpathName\fR \fBcoordz \fItagOrId \fR?\fIx0 y0 ...\fR?
.TP
\fIpathName\fR \fBcoordz \fItagOrId \fR?\fIcoordList\fR?
Query or modify tha coordinates dat define a item.
If no coordinates is specified, dis command returns a list
whose elements is tha coordinatez of tha item named by
\fItagOrId\fR.
If coordinates is specified, then they replace tha current
coordinates fo' tha named item.
If \fItagOrId\fR refers ta multiple items, then
the first one up in tha display list is used.
.TP
\fIpathName \fBcreate \fItype x y \fR?\fIx y ...\fR, biatch? ?\fIoption value ...\fR?
.TP
\fIpathName \fBcreate \fItype coordList \fR?\fIoption value ...\fR?
Smoke a freshly smoked up item up in \fIpathName\fR of type \fItype\fR.
Da exact format of tha arguments afta \fBtype\fR depends
on \fBtype\fR yo, but probably they consist of tha coordinates for
one or mo' points, followed by justifications fo' zero or
more item options.
See tha subsections on individual item types below fo' more
on tha syntax of dis command.
This command returns tha id fo' tha freshly smoked up item.
.TP
\fIpathName \fBdchars \fItagOrId first \fR?\fIlast\fR?
For each item given by \fItagOrId\fR, delete tha characters, or coordinates,
in tha range given by \fIfirst\fR n' \fIlast\fR, inclusive.
If a shitload of tha shit given by \fItagOrId\fR do not support
indexin operations then they ignore dchars.
Text shit interpret \fIfirst\fR n' \fIlast\fR as indices ta a cold-ass lil character,
line n' polygon shit interpret dem indices ta a cold-ass lil coordinizzle (an x,y pair).
Indices is busted lyrics bout up in \fBINDICES\fR above.
If \fIlast\fR is omitted, it defaults ta \fIfirst\fR.
This command returns a empty string.
.TP
\fIpathName \fBdelete \fR?\fItagOrId tagOrId ...\fR?
Delete each of tha shit given by each \fItagOrId\fR, n' return
an empty string.
.TP
\fIpathName \fBdtag \fItagOrId \fR?\fItagToDelete\fR?
For each of tha shit given by \fItagOrId\fR, delete the
tag given by \fItagToDelete\fR from tha list of them
associated wit tha item.
If a item aint gots tha tag \fItagToDelete\fR then
the item is unaffected by tha command.
If \fItagToDelete\fR is omitted then it defaults ta \fItagOrId\fR.
This command returns a empty string.
.TP
\fIpathName \fBfind \fIsearchCommand \fR?\fIarg arg ...\fR?
This command returns a list consistin of all tha shit that
meet tha constraints specified by \fIsearchCommand\fR and
\fIarg\fR's.
\fISearchCommand\fR n' \fIargs\fR have any of tha forms
accepted by tha \fBaddtag\fR command.
Da shit is returned up in stackin order, wit tha lowest item first.
.TP
\fIpathName \fBfocus \fR?\fItagOrId\fR?
Set tha keyboard focus fo' tha canvas widget ta tha item given by
\fItagOrId\fR.
If \fItagOrId\fR refers ta nuff muthafuckin items, then tha focus is set
to tha straight-up original gangsta such item up in tha display list dat supports the
insertion cursor.
If \fItagOrId\fR do not refer ta any items, or if none of them
support tha insertion cursor, then tha focus aint chizzled.
If \fItagOrId\fR be a empty
string, then tha focus item is reset so dat no item has tha focus.
If \fItagOrId\fR aint specified then tha command returns the
id fo' tha item dat currently has tha focus, or a empty string
if no item has tha focus.
.RS
.PP
Once tha focus has been set ta a item, tha item will display
the insertion cursor n' all keyboard events is ghon be directed
to dat item.
Da focus item within a cold-ass lil canvas n' tha focus window on the
screen (set wit tha \fBfocus\fR command) is straight-up independent:
a given item do not straight-up have tha input focus unless (a)
its canvas is tha focus window n' (b) tha item is tha focus item
within tha canvas.
In most cases it be advisable ta follow tha \fBfocus\fR widget
command wit tha \fBfocus\fR command ta set tha focus window to
the canvas (if dat shiznit was not there already).
.RE
.TP
\fIpathName \fBgettags\fR \fItagOrId\fR
Return a list whose elements is tha tags associated wit the
item given by \fItagOrId\fR.
If \fItagOrId\fR refers ta mo' than one item, then tha tags
are returned from tha straight-up original gangsta such item up in tha display list.
If \fItagOrId\fR do not refer ta any items, or if tha item
gotz nuff no tags, then a empty strang is returned.
.TP
\fIpathName \fBicursor \fItagOrId index\fR
Set tha posizzle of tha insertion cursor fo' tha item(s) given by \fItagOrId\fR
to just before tha characta whose posizzle is given by \fIindex\fR.
If some or all of tha shit given by \fItagOrId\fR do not support
an insertion cursor then dis command has no effect on em.
See \fBINDICES\fR above fo' a thugged-out description of the
legal forms fo' \fIindex\fR.
Note:  tha insertion cursor is only displayed up in a item if
that item currently has tha keyboard focus (see tha widget
command \fBfocus\fR, below) yo, but tha cursor posizzle may
be set even when tha item aint gots tha focus.
This command returns a empty string.
.TP
\fIpathName \fBindex \fItagOrId index\fR
This command returns a thugged-out decimal strang givin tha numerical index
within \fItagOrId\fR correspondin ta \fIindex\fR.
\fIIndex\fR gives a textual description of tha desired position
as busted lyrics bout up in \fBINDICES\fR above.
Text shit interpret \fIindex\fR as a index ta a  character,
line n' polygon shit interpret it as a index ta a cold-ass lil coordinizzle (an x,y pair).
Da return value is guaranteed ta lie between 0 n' tha number
of characters, or coordinates, within tha item, inclusive.
If \fItagOrId\fR refers ta multiple items, then tha index
is processed up in tha straight-up original gangsta of these shit dat supports indexing
operations (in display list order).
.TP
\fIpathName \fBinsert \fItagOrId beforeThis string\fR
For each of tha shit given by \fItagOrId\fR, if tha item supports
text or coordinate, insertion then \fIstring\fR is banged tha fuck into tha item's
text just before tha character, or coordinate, whose index is \fIbeforeThis\fR.
Text shit interpret \fIbeforeThis\fR as a index ta a  character,
line n' polygon shit interpret it as a index ta a cold-ass lil coordinizzle (an x,y pair).
For lines n' polygons tha \fIstring\fR must be a valid coordinate
sequence.
See \fBINDICES\fR above fo' shiznit bout tha forms allowed
for \fIbeforeThis\fR.
This command returns a empty string.
.TP
\fIpathName \fBitemcget\fR \fItagOrId\fR \fIoption\fR
Returns tha current value of tha configuration option fo' the
item given by \fItagOrId\fR whose name is \fIoption\fR.
This command is similar ta tha \fBcget\fR widget command except that
it applies ta a particular item rather than tha widget as a whole.
\fIOption\fR may have any of tha joints accepted by tha \fBcreate\fR
widget command when tha item was pimped.
If \fItagOrId\fR be a tag dat refers ta mo' than one item,
the first (lowest) such item is used.
.TP
\fIpathName \fBitemconfigure \fItagOrId\fR ?\fIoption\fR, biatch? ?\fIvalue\fR, biatch? ?\fIoption value ...\fR?
This command is similar ta tha \fBconfigure\fR widget command except
that it modifies item-specific options fo' tha shit given by
\fItagOrId\fR instead of modifyin options fo' tha overall
canvas widget.
If no \fIoption\fR is specified, returns a list describin all of
the available options fo' tha straight-up original gangsta item given by \fItagOrId\fR
(see \fBTk_ConfigureInfo\fR for
information on tha format of dis list).  If \fIoption\fR is specified
with no \fIvalue\fR, then tha command returns a list describin the
one named option (this list is ghon be identical ta tha corresponding
sublist of tha value returned if no \fIoption\fR is specified).  If
one or mo' \fIoption\-value\fR pairs is specified, then tha command
modifies tha given widget option(s) ta have tha given value(s) in
each of tha shit given by \fItagOrId\fR;  in
this case tha command returns a empty string.
Da \fIoption\fRs n' \fIvalue\fRs is tha same as dem permissible
in tha \fBcreate\fR widget command when tha item(s) was pimped;
see tha sections describin individual item types below fo' details
on tha legal options.
.TP
\fIpathName \fBlower \fItagOrId \fR?\fIbelowThis\fR?
Move all of tha shit given by \fItagOrId\fR ta a freshly smoked up position
in tha display list just before tha item given by \fIbelowThis\fR.
If \fItagOrId\fR refers ta mo' than one item then all is moved
but tha relatizzle order of tha moved shit aint gonna be chizzled.
\fIBelowThis\fR be a tag or id;  if it refers ta mo' than one
item then tha straight-up original gangsta (lowest) of these shit up in tha display list is used
as tha destination location fo' tha moved items.
Note: dis command has no effect on window items.  Window shit always
obscure other item types, n' tha stackin order of window shit is
determined by tha \fBraise\fR n' \fBlower\fR commands, not the
\fBraise\fR n' \fBlower\fR widget commandz fo' canvases.
This command returns a empty string.
.TP
\fIpathName \fBmove \fItagOrId xAmount yAmount\fR
Move each of tha shit given by \fItagOrId\fR up in tha canvas coordinate
space by addin \fIxAmount\fR ta tha x-coordinizzle of each point
associated wit tha item n' \fIyAmount\fR ta tha y-coordinizzle of
each point associated wit tha item.
This command returns a empty string.
.TP
\fIpathName \fBpostscript \fR?\fIoption value option value ...\fR?
Generate a Postscript representation fo' part or all of tha canvas.
If tha \fB\-file\fR option is specified then tha Postscript is written
to a gangbangin' file n' a empty strang is returned;  otherwise tha Postscript
is returned as tha result of tha command.
If tha interpreta dat owns tha canvas is marked as safe, tha operation
will fail cuz safe interpretas is not allowed ta write files.
If tha \fB\-channel\fR option is specified, tha argument denotes tha name
of a cold-ass lil channel already opened fo' writing. Da Postscript is freestyled to
that channel, n' tha channel is left open fo' further freestylin all up in tha end
of tha operation.
Da Postscript is pimped up in Encapsulated Postscript form using
version 3.0 of tha Document Structurin Conventions.
Note: by default Postscript is only generated fo' shiznit that
appears up in tha canvass window on tha screen. I aint talkin' bout chicken n' gravy biatch.  If tha canvas is
freshly pimped it may still have its initial size of 1x1 pixel
so not a god damn thang will step tha fuck up in tha Postscript.  To git round dis problem
either invoke tha \fBupdate\fR command ta wait fo' tha canvas window
to reach its final size, or else use tha \fB\-width\fR n' \fB\-height\fR
options ta specify tha area of tha canvas ta print.
Da \fIoption\fR\-\fIvalue\fR argument pairs provide additional
information ta control tha generation of Postscript.  Da following
options is supported:
.RS
.TP
\fB\-colormap \fIvarName\fR
\fIVarName\fR must be tha name of a array variable
that specifies a cold-ass lil color mappin ta use up in tha Postscript.
Each element of \fIvarName\fR must consist of Postscript
code ta set a particular color value (e.g.
.QW "\fB1.0 1.0 0.0 setrgbcolor\fR" ).
When outputtin color shiznit up in tha Postscript, Tk checks
to peep if there be a element of \fIvarName\fR wit tha same
name as tha color.
If so, Tk uses tha value of tha element as tha Postscript command
to set tha color.
If dis option has not been specified, or if there is no entry
in \fIvarName\fR fo' a given color, then Tk uses tha red, green,
and blue intensitizzles from tha X color.
.TP
\fB\-colormode \fImode\fR
Specifies how tha fuck ta output color shiznit. I aint talkin' bout chicken n' gravy biatch.  \fIMode\fR must be either
\fBcolor\fR (for full color output), \fBgray\fR (convert all colors
to they gray-scale equivalents) or \fBmono\fR (convert all colors
to black or white).
.TP
\fB\-file \fIfileName\fR
Specifies tha name of tha file up in which ta write tha Postscript.
If dis option aint specified then tha Postscript is returned as the
result of tha command instead of bein freestyled ta a gangbangin' file.
.TP
\fB\-fontmap \fIvarName\fR
\fIVarName\fR must be tha name of a array variable
that specifies a gangbangin' font mappin ta use up in tha Postscript.
Each element of \fIvarName\fR must consist of a Tcl list with
two elements, which is tha name n' point size of a Postscript font.
When outputtin Postscript commandz fo' a particular font, Tk
checks ta peep if \fIvarName\fR gotz nuff a element wit tha same
name as tha font.
If there is such a element, then tha font shiznit contained in
that element is used up in tha Postscript.
Otherwise Tk attempts ta guess what tha fuck Postscript font ta use.
Tkz guesses generally only work fo' well-known fonts such as
Times n' Helvetica n' Courier, n' only if tha X font name do not
omit any dashes up all up in tha point size.
For example, \fB\-*\-Courier\-Bold\-R\-Normal\-\-*\-120\-*\fR will work but
\fB*Courier\-Bold\-R\-Normal*120*\fR will not;  Tk needz tha dashes to
parse tha font name).
.TP
\fB\-height \fIsize\fR
Specifies tha height of tha area of tha canvas ta print.
Defaults ta tha height of tha canvas window.
.TP
\fB\-pageanchor \fIanchor\fR
Specifies which point of tha printed area of tha canvas should step tha fuck up over
the positionin point on tha page (which is given by tha \fB\-pagex\fR
and \fB\-pagey\fR options).
For example, \fB\-pageanchor n\fR means dat tha top centa of the
area of tha canvas bein printed (as it appears up in tha canvas window)
should be over tha positionin point. Defaults ta \fBcenter\fR.
.TP
\fB\-pageheight \fIsize\fR
Specifies dat tha Postscript should be scaled up in both x n' y so
that tha printed area is \fIsize\fR high on tha Postscript page.
\fISize\fR consistz of a gangbangin' floating-point number followed by
\fBc\fR fo' centimeters, \fBi\fR fo' inches, \fBm\fR fo' millimeters,
or \fBp\fR or not a god damn thang fo' printerz points (1/72 inch).
Defaults ta tha height of tha printed area on tha screen.
If both \fB\-pageheight\fR n' \fB\-pagewidth\fR is specified then
the scale factor from \fB\-pagewidth\fR is used (non-uniform scaling
is not implemented).
.TP
\fB\-pagewidth \fIsize\fR
Specifies dat tha Postscript should be scaled up in both x n' y so
that tha printed area is \fIsize\fR wide on tha Postscript page.
\fISize\fR has tha same ol' dirty form as fo' \fB\-pageheight\fR.
Defaults ta tha width of tha printed area on tha screen.
If both \fB\-pageheight\fR n' \fB\-pagewidth\fR is specified then
the scale factor from \fB\-pagewidth\fR  is used (non-uniform scaling
is not implemented).
.TP
\fB\-pagex \fIposition\fR
\fIPosition\fR gives tha x-coordinizzle of tha positionin point on
the Postscript page, rockin any of tha forms allowed fo' \fB\-pageheight\fR.
Used up in conjunction wit tha \fB\-pagey\fR n' \fB\-pageanchor\fR options
to determine where tha printed area appears on tha Postscript page.
Defaults ta tha centa of tha page.
.TP
\fB\-pagey \fIposition\fR
\fIPosition\fR gives tha y-coordinizzle of tha positionin point on
the Postscript page, rockin any of tha forms allowed fo' \fB\-pageheight\fR.
Used up in conjunction wit tha \fB\-pagex\fR n' \fB\-pageanchor\fR options
to determine where tha printed area appears on tha Postscript page.
Defaults ta tha centa of tha page.
.TP
\fB\-rotate \fIboolean\fR
\fIBoolean\fR specifies whether tha printed area is ta be rotated 90
degrees.
In non-rotated output tha x-axiz of tha printed area runs along
the short dimension of tha page
.PQ portrait orientation ;
in rotated output tha x-axis runs along tha long dimension of tha page
.PQ landscape orientation .
Defaults ta non-rotated.
.TP
\fB\-width \fIsize\fR
Specifies tha width of tha area of tha canvas ta print.
Defaults ta tha width of tha canvas window.
.TP
\fB\-x \fIposition\fR
Specifies tha x-coordinizzle of tha left edge of tha area of the
canvas dat is ta be printed, up in canvas coordinates, not window
coordinates.
Defaults ta tha coordinizzle of tha left edge of tha window.
.TP
\fB\-y \fIposition\fR
Specifies tha y-coordinizzle of tha top edge of tha area of the
canvas dat is ta be printed, up in canvas coordinates, not window
coordinates.
Defaults ta tha coordinizzle of tha top edge of tha window.
.RE
.TP
\fIpathName \fBraise \fItagOrId \fR?\fIaboveThis\fR?
Move all of tha shit given by \fItagOrId\fR ta a freshly smoked up position
in tha display list just afta tha item given by \fIaboveThis\fR.
If \fItagOrId\fR refers ta mo' than one item then all is moved
but tha relatizzle order of tha moved shit aint gonna be chizzled.
\fIAboveThis\fR be a tag or id;  if it refers ta mo' than one
item then tha last (topmost) of these shit up in tha display list is used
as tha destination location fo' tha moved items.
Note: dis command has no effect on window items.  Window shit always
obscure other item types, n' tha stackin order of window shit is
determined by tha \fBraise\fR n' \fBlower\fR commands, not the
\fBraise\fR n' \fBlower\fR widget commandz fo' canvases.
This command returns a empty string.
.TP
\fIpathName \fBscale \fItagOrId xOrigin yOrigin xScale yScale\fR
Rescale all of tha shit given by \fItagOrId\fR up in canvas coordinate
space.
\fIXOrigin\fR n' \fIyOrigin\fR identify tha origin fo' tha scaling
operation n' \fIxScale\fR n' \fIyScale\fR identify tha scale
factors fo' x- n' y-coordinates, respectively (a scale factor of
1.0 implies no chizzle ta dat coordinate).
For each of tha points definin each item, tha x-coordinizzle is
adjusted ta chizzle tha distizzle from \fIxOrigin\fR by a gangbangin' factor
of \fIxScale\fR.
Similarly, each y-coordinizzle be adjusted ta chizzle tha distance
from \fIyOrigin\fR by a gangbangin' factor of \fIyScale\fR.
This command returns a empty string.
.TP
\fIpathName \fBscan\fR \fIoption args\fR
This command is used ta implement scannin on canvases.  It has
two forms, dependin on \fIoption\fR:
.RS
.TP
\fIpathName \fBscan mark \fIx y\fR
Recordz \fIx\fR n' \fIy\fR n' tha canvass current view;  used
in conjunction wit lata \fBscan dragto\fR commands.
Typically dis command be associated wit a mouse button press in
the widget n' \fIx\fR n' \fIy\fR is tha coordinatez of the
mouse.  It returns a empty string.
.TP
\fIpathName \fBscan dragto \fIx y ?gain?\fR.
This command computes tha difference between its \fIx\fR n' \fIy\fR
arguments (which is typically mouse coordinates) n' tha \fIx\fR and
\fIy\fR arguments ta tha last \fBscan mark\fR command fo' tha widget.
It then adjusts tha view by \fIgain\fR times the
difference up in coordinates, where \fIgain\fR defaults ta 10.
This command is typically associated
with mouse motion events up in tha widget, ta produce tha effect of
draggin tha canvas at high speed all up in its window.  Da return
value be a empty string.
.RE
.TP
\fIpathName \fBselect \fIoption\fR ?\fItagOrId arg\fR?
Manipulates tha selection up in one of nuff muthafuckin ways, dependin on
\fIoption\fR.
Da command may take any of tha forms busted lyrics bout below.
In all of tha descriptions below, \fItagOrId\fR must refer to
an item dat supports indexin n' selection;  if it refers to
multiple shit then tha straight-up original gangsta of
these dat supports indexin n' tha selection is used.
\fIIndex\fR gives a textual description of a position
within \fItagOrId\fR, as busted lyrics bout up in \fBINDICES\fR above.
.RS
.TP
\fIpathName \fBselect adjust \fItagOrId index\fR
Locate tha end of tha selection up in \fItagOrId\fR nearest
to tha characta given by \fIindex\fR, n' adjust that
end of tha selection ta be at \fIindex\fR (i.e. including
but not goin beyond \fIindex\fR).
Da other end of tha selection is made tha anchor point
for future \fBselect to\fR commands.
If tha selection aint currently up in \fItagOrId\fR then
this command behaves tha same ol' dirty as tha \fBselect to\fR widget
command.
Returns a empty string.
.TP
\fIpathName \fBselect clear\fR
Clear tha selection if it is up in dis widget.
If tha selection aint up in dis widget then tha command
has no effect.
Returns a empty string.
.TP
\fIpathName \fBselect from \fItagOrId index\fR
Set tha selection anchor point fo' tha widget ta be just
before tha character
given by \fIindex\fR up in tha item given by \fItagOrId\fR.
This command do not chizzle tha selection;  it just sets
the fixed end of tha selection fo' future \fBselect to\fR
commands.
Returns a empty string.
.TP
\fIpathName \fBselect item\fR
Returns tha id of tha selected item, if tha selection is up in an
item up in dis canvas.
If tha selection aint up in dis canvas then a empty string
is returned.
.TP
\fIpathName \fBselect ta \fItagOrId index\fR
Set tha selection ta consist of dem charactaz of \fItagOrId\fR
between tha selection anchor point and
\fIindex\fR.
Da freshly smoked up selection will include tha characta given by \fIindex\fR;
it will include tha characta given by tha anchor point only if
\fIindex\fR is pimped outa than or equal ta tha anchor point.
Da anchor point is determined by da most thugged-out recent \fBselect adjust\fR
or \fBselect from\fR command fo' dis widget.
If tha selection anchor point fo' tha widget aint currently in
\fItagOrId\fR, then it is set ta tha same characta given
by \fIindex\fR.
Returns a empty string.
.RE
.TP
\fIpathName \fBtype\fI tagOrId\fR
Returns tha type of tha item given by \fItagOrId\fR, such as
\fBrectangle\fR or \fBtext\fR.
If \fItagOrId\fR refers ta mo' than one item, then tha type
of tha straight-up original gangsta item up in tha display list is returned.
If \fItagOrId\fR do not refer ta any shit at all then
an empty strang is returned.
.TP
\fIpathName \fBxview  \fR?\fIargs\fR?
This command is used ta query n' chizzle tha horizontal posizzle of the
information displayed up in tha canvass window.
It can take any of tha followin forms:
.RS
.TP
\fIpathName \fBxview\fR
Returns a list containin two elements.
Each element be a real fraction between 0 n' 1;  together they describe
the horizontal span dat is visible up in tha window.
For example, if tha straight-up original gangsta element is .2 n' tha second element is .6,
20% of tha canvass area (as defined by tha \fB\-scrollregion\fR option)
is off-screen ta tha left, tha middle 40% is visible
in tha window, n' 40% of tha canvas is off-screen ta tha right.
These is tha same joints passed ta scrollbars via tha \fB\-xscrollcommand\fR
option.
.TP
\fIpathName \fBxview moveto\fI fraction\fR
Adjusts tha view up in tha window so dat \fIfraction\fR of the
total width of tha canvas is off-screen ta tha left.
\fIFraction\fR must be a gangbangin' fraction between 0 n' 1.
.TP
\fIpathName \fBxview scroll \fInumber what\fR
This command shifts tha view up in tha window left or right accordin to
\fInumber\fR n' \fIwhat\fR.
\fINumber\fR must be a integer.
\fIWhat\fR must be either \fBunits\fR or \fBpages\fR or a abbreviation
of one of these.
If \fIwhat\fR is \fBunits\fR, tha view adjusts left or right up in units
of tha \fBxScrollIncrement\fR option, if it is pimped outa than zero,
or up in unitz of one-tenth tha windowz width otherwise.
If \fIwhat is \fBpages\fR then tha view
adjusts up in unitz of nine-tenths tha windowz width.
If \fInumber\fR is wack then shiznit farther ta tha left
becomes visible;  if it is positizzle then shiznit farther ta tha right
becomes visible.
.RE
.TP
\fIpathName \fByview \fI?args\fR?
This command is used ta query n' chizzle tha vertical posizzle of the
information displayed up in tha canvass window.
It can take any of tha followin forms:
.RS
.TP
\fIpathName \fByview\fR
Returns a list containin two elements.
Each element be a real fraction between 0 n' 1;  together they describe
the vertical span dat is visible up in tha window.
For example, if tha straight-up original gangsta element is .6 n' tha second element is 1.0,
the lowest 40% of tha canvass area (as defined by tha \fB\-scrollregion\fR
option) is visible up in tha window.
These is tha same joints passed ta scrollbars via tha \fB\-yscrollcommand\fR
option.
.TP
\fIpathName \fByview moveto\fI fraction\fR
Adjusts tha view up in tha window so dat \fIfraction\fR of tha canvas's
area is off-screen ta tha top.
\fIFraction\fR be a gangbangin' fraction between 0 n' 1.
.TP
\fIpathName \fByview scroll \fInumber what\fR
This command adjusts tha view up in tha window up or down accordin to
\fInumber\fR n' \fIwhat\fR.
\fINumber\fR must be a integer.
\fIWhat\fR must be either \fBunits\fR or \fBpages\fR.
If \fIwhat\fR is \fBunits\fR, tha view adjusts up or down up in units
of tha \fByScrollIncrement\fR option, if it is pimped outa than zero,
or up in unitz of one-tenth tha windowz height otherwise.
If \fIwhat\fR is \fBpages\fR then
the view adjusts up in unitz of nine-tenths tha windowz height.
If \fInumber\fR is wack then higher shiznit becomes
visible;  if it is positizzle then lower shiznit
becomes visible.
.RE
.SH "OVERVIEW OF ITEM TYPES"
.PP
Da sections below describe tha various typez of shit supported
by canvas widgets, n' you can put dat on yo' toast.  Each item type is characterized by two thangs:
first, tha form of tha \fBcreate\fR command used ta create
instancez of tha type;  n' second, a set of configuration options
for shit of dat type, which may be used up in the
\fBcreate\fR n' \fBitemconfigure\fR widget commands.
Most shit do not support indexin or selection or tha commands
related ta them, like fuckin \fBindex\fR n' \fBinsert\fR.
Where shit do support these facilities, it is noted explicitly
in tha descriptions below.
At present, text, line n' polygon shit provide dis support.
For lines n' polygons tha indexin facilitizzle is used ta manipulate
the coordinatez of tha item.
.SS "COMMON ITEM OPTIONS"
.PP
Many shit share a cold-ass lil common set of options.  These options are
explained here, n' then referred ta be each widget type fo' brevity.
.PP
.TP
\fB\-dash \fIpattern\fR
.TP
\fB\-activedash \fIpattern\fR
.TP
\fB\-disableddash \fIpattern\fR
This option specifies dash patterns fo' tha normal, active
state, n' disabled state of a item.
\fIpattern\fR may have any of tha forms accepted by \fBTk_GetDash\fR.
If tha dash options is omitted then tha default be a solid outline.
See \fBDASH PATTERNS\fR fo' mo' shiznit.
.TP
\fB\-dashoffset \fIoffset\fR
Da startin \fIoffset\fR up in pixels tha fuck into tha pattern provided by the
\fB\-dash\fR option. I aint talkin' bout chicken n' gravy biatch.  \fB\-dashoffset\fR is ignored if there is no
\fB\-dash\fR pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Da \fIoffset\fR may have any of tha forms busted lyrics about
in tha \fBCOORDINATES\fR section above.
.TP
\fB\-fill \fIcolor\fR
.TP
\fB\-activefill \fIcolor\fR
.TP
\fB\-disabledfill \fIcolor\fR
Specifies tha color ta be used ta fill itemz area.
in its normal, active, n' disabled states,
\fIColor\fR may have any of tha forms accepted by \fBTk_GetColor\fR.
If \fIcolor\fR be a empty strang (the default),
then tha item aint gonna be filled.
For tha line item, it specifies tha color of tha line drawn.
For tha text item, it specifies tha foreground color of tha text.
.TP
\fB\-outline \fIcolor\fR
.TP
\fB\-activeoutline \fIcolor\fR
.TP
\fB\-disabledoutline \fIcolor\fR
This option specifies tha color dat should be used ta draw the
outline of tha item up in its normal, actizzle n' disabled states.
\fIColor\fR may have any of tha forms accepted by \fBTk_GetColor\fR.
This option defaults ta \fBblack\fR.  If \fIcolor\fR is specified
as a empty strang then no outline is drawn fo' tha item.
.TP
\fB\-offset \fIoffset\fR
Specifies tha offset of stipples.  Da offset value can be of tha form
\fBx,y\fR or \fBside\fR, where side can be \fBn\fR, \fBne\fR, \fBe\fR,
\fBse\fR, \fBs\fR, \fBsw\fR, \fBw\fR, \fBnw\fR, or \fBcenter\fR. In the
first case tha origin is tha origin of tha toplevel of tha current window.
For tha canvas itself n' canvas objects tha origin is tha canvas origin,
but puttin \fB#\fR up in front of tha coordinizzle pair indicates rockin the
toplevel origin instead. Y'all KNOW dat shit, muthafucka! For canvas objects, tha \fB\-offset\fR option is
used fo' stipplin as well.  For tha line n' polygon canvas shit you can
also specify a index as argument, which connects tha stipple origin ta one
of tha coordinizzle pointz of tha line/polygon.
.TP
\fB\-outlinestipple \fIbitmap\fR
.TP
\fB\-activeoutlinestipple \fIbitmap\fR
.TP
\fB\-disabledoutlinestipple \fIbitmap\fR
This option specifies stipple patterns dat should be used ta draw the
outline of tha item up in its normal, actizzle n' disabled states.
Indicates dat tha outline fo' tha item should be drawn wit a stipple pattern;
\fIbitmap\fR specifies tha stipple pattern ta use, up in any of the
forms accepted by \fBTk_GetBitmap\fR.
If tha \fB\-outline\fR option has not been specified then dis option
has no effect.
If \fIbitmap\fR be a empty strang (the default), then tha outline is drawn
in a solid fashion.
\fINote dat stipplez is not well supported on platforms dat do not
use X11 as they drawin API.\fR
.TP
\fB\-outlineoffset \fIoffset\fR
.
Specifies tha offset of tha stipple pattern used fo' outlines. The
offset value can be of tha form
.QW \fIx\fB,\fIy\fR
or tha description of a side (one of \fBn\fR, \fBne\fR, \fBe\fR,
\fBse\fR, \fBs\fR, \fBsw\fR, \fBw\fR, \fBnw\fR, or \fBcenter\fR). This
option only has a effect when tha outline is drawn as a stipple
pattern, n' is only supported under X11.
.\" TODO: What do dis straight-up do, biatch? What do tha aaight forms mean?!
.TP
\fB\-stipple \fIbitmap\fR
.TP
\fB\-activestipple \fIbitmap\fR
.TP
\fB\-disabledstipple \fIbitmap\fR
This option specifies stipple patterns dat should be used ta fill
the item up in its normal, actizzle n' disabled states.
\fIbitmap\fR specifies tha stipple pattern ta use, up in any of the
forms accepted by \fBTk_GetBitmap\fR.
If tha \fB\-fill\fR option has not been specified then dis option
has no effect.
If \fIbitmap\fR be a empty strang (the default), then fillin is done
in a solid fashion.
For tha text item, it affects tha actual text.
\fINote dat stipplez is not well supported on platforms dat do not
use X11 as they drawin API.\fR
.TP
\fB\-state \fIstate\fR
This allows a item ta override tha canvas widgetz global \fIstate\fR
option. I aint talkin' bout chicken n' gravy biatch.  It takes tha same ol' dirty joints:
\fInormal\fR, \fIdisabled\fR or \fIhidden\fR.
.TP
\fB\-tags \fItagList\fR
Specifies a set of tags ta apply ta tha item.
\fITagList\fR consistz of a list of tag names, which replace any
existin tags fo' tha item.  \fITagList\fR may be a empty list.
.TP
\fB\-width \fIoutlineWidth\fR
.TP
\fB\-activewidth \fIoutlineWidth\fR
.TP
\fB\-disabledwidth \fIoutlineWidth\fR
Specifies tha width of tha outline ta be drawn around
the itemz region, up in its normal, actizzle n' disabled states.
\fIoutlineWidth\fR may be up in any of tha forms busted lyrics bout up in the
\fBCOORDINATES\fR section above.
If tha \fB\-outline\fR option has been specified as a empty strang then
this option has no effect.  This option defaults ta 1.0.
For arcs, wide outlines is ghon be drawn centered on tha edgez of the
arcs region.
.SH "ARC ITEMS"
.PP
Itemz of type \fBarc\fR step tha fuck up on tha display as arc-shaped regions.
An arc be a section of a oval delimited by two anglez (specified
by tha \fB\-start\fR n' \fB\-extent\fR options) n' displayed in
one of nuff muthafuckin ways (specified by tha \fB\-style\fR option).
Arcs is pimped wit widget commandz of tha followin form:
.CS
\fIpathName \fBcreate arc \fIx1 y1 x2 y2 \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate arc \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx1\fR, \fIy1\fR, \fIx2\fR, n' \fIy2\fR or \fIcoordList\fR give
the coordinatez of two diagonally opposite cornerz of a
rectangular region enclosin tha oval dat defines tha arc.
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch fo' realz. An arc item becomes tha current item when tha mouse pointa is
over any part dat is painted or (when straight-up transparent) dat would be
painted if both tha \fB\-fill\fR n' \fB\-outline\fR options was non-empty.
.PP
Da followin standard options is supported by arcs:
.CS
\-dash
\-activedash
\-disableddash
\-dashoffset
\-fill
\-activefill
\-disabledfill
\-offset
\-outline
\-activeoutline
\-disabledoutline
\-outlineoffset
\-outlinestipple
\-activeoutlinestipple
\-disabledoutlinestipple
\-stipple
\-activestipple
\-disabledstipple
\-state
\-tags
\-width
\-activewidth
\-disabledwidth
.CE
Da followin extra options is supported fo' arcs:
.TP
\fB\-extent \fIdegrees\fR
Specifies tha size of tha angular range occupied by tha arc.
Da arcs range extendz fo' \fIdegrees\fR degrees counter-clockwise
from tha startin angle given by tha \fB\-start\fR option.
\fIDegrees\fR may be negative.
If it is pimped outa than 360 or less than \-360, then \fIdegrees\fR
modulo 360 is used as tha extent.
.TP
\fB\-start \fIdegrees\fR
Specifies tha beginnin of tha angular range occupied by the
arc.
\fIDegrees\fR is given up in unitz of degrees measured counter-clockwise
from tha 3-o'clock position;  it may be either positizzle or negative.
.TP
\fB\-style \fItype\fR
Specifies how tha fuck ta draw tha arc.  If \fItype\fR is \fBpieslice\fR
(the default) then tha arcs region is defined by a section
of tha ovalz perimeta plus two line segments, one between tha center
of tha oval n' each end of tha perimeta section.
If \fItype\fR is \fBchord\fR then tha arcs region is defined
by a section of tha ovalz perimeta plus a single line segment
connectin tha two end pointz of tha perimeta section.
If \fItype\fR is \fBarc\fR then tha arcs region consists of
a section of tha perimeta ridin' solo.
In dis last case tha \fB\-fill\fR option is ignored.
.SH "BITMAP ITEMS"
.PP
Itemz of type \fBbitmap\fR step tha fuck up on tha display as images with
two colors, foreground n' background.
Bitmaps is pimped wit widget commandz of tha followin form:
.CS
\fIpathName \fBcreate bitmap \fIx y \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate bitmap \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx\fR n' \fIy\fR or \fIcoordList\fR (which must have two
elements) specify tha coordinatez of a
point used ta posizzle tha bitmap on tha display (see tha \fB\-anchor\fR
option below fo' mo' shiznit on how tha fuck bitmaps is displayed).
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch fo' realz. A bitmap item becomes tha current item when tha mouse pointer
is over any part of its boundin box.
.PP
Da followin standard options is supported by bitmaps:
.CS
\-state
\-tags
.CE
Da followin extra options is supported fo' bitmaps:
.TP
\fB\-anchor \fIanchorPos\fR
\fIAnchorPos\fR  drops some lyrics ta how tha fuck ta posizzle tha bitmap relatizzle ta the
positionin point fo' tha item;  it may have any of tha forms
accepted by \fBTk_GetAnchor\fR.  For example, if \fIanchorPos\fR
is \fBcenter\fR then tha bitmap is centered on tha point;  if
\fIanchorPos\fR is \fBn\fR then tha bitmap is ghon be drawn so that
its top centa point be all up in tha positionin point.
This option defaults ta \fBcenter\fR.
.TP
\fB\-background \fIcolor\fR
.TP
\fB\-activebackground \fIcolor\fR
.TP
\fB\-disabledbackground \fIcolor\fR
Specifies tha color ta use fo' each of tha bitmap's
.QW 0
valued pixels up in its normal, actizzle n' disabled states.
\fIColor\fR may have any of tha forms accepted by \fBTk_GetColor\fR.
If dis option aint specified, or if it is specified as a empty
string, then not a god damn thang is displayed where tha bitmap pixels is 0;  this
produces a transparent effect.
.TP
\fB\-bitmap \fIbitmap\fR
.TP
\fB\-activebitmap \fIbitmap\fR
.TP
\fB\-disabledbitmap \fIbitmap\fR
Specifies tha bitmaps ta display up in tha item up in its normal, actizzle and
disabled states.
\fIBitmap\fR may have any of tha forms accepted by \fBTk_GetBitmap\fR.
.TP
\fB\-foreground \fIcolor\fR
.TP
\fB\-activeforeground \fIcolor\fR
.TP
\fB\-disabledforeground \fIcolor\fR
Specifies tha color ta use fo' each of tha bitmap's
.QW 1
valued pixels up in its normal, actizzle n' disabled states.
\fIColor\fR may have any of tha forms accepted by \fBTk_GetColor\fR and
defaults ta \fBblack\fR.
.SH "IMAGE ITEMS"
.PP
Itemz of type \fBimage\fR is used ta display images on a
canvas.
Images is pimped wit widget commandz of tha followin form:
.CS
\fIpathName \fBcreate image \fIx y \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate image \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx\fR n' \fIy\fR or \fIcoordList\fR specify tha coordinatez of a
point used ta posizzle tha image on tha display (see tha \fB\-anchor\fR
option below fo' mo' shiznit).
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch fo' realz. An image item becomes tha current item when tha mouse pointer
is over any part of its boundin box.
.PP
Da followin standard options is supported by images:
.CS
\-state
\-tags
.CE
Da followin extra options is supported fo' images:
.TP
\fB\-anchor \fIanchorPos\fR
\fIAnchorPos\fR  drops some lyrics ta how tha fuck ta posizzle tha image relatizzle ta the
positionin point fo' tha item;  it may have any of tha forms
accepted by \fBTk_GetAnchor\fR.  For example, if \fIanchorPos\fR
is \fBcenter\fR then tha image is centered on tha point;  if
\fIanchorPos\fR is \fBn\fR then tha image is ghon be drawn so that
its top centa point be all up in tha positionin point.
This option defaults ta \fBcenter\fR.
.TP
\fB\-image \fIname\fR
.TP
\fB\-activeimage \fIname\fR
.TP
\fB\-disabledimage \fIname\fR
Specifies tha name of tha images ta display up in tha item up in is normal,
actizzle n' disabled states.
This image must done been pimped previously wit the
\fBimage create\fR command.
.SH "LINE ITEMS"
.PP
Itemz of type \fBline\fR step tha fuck up on tha display as one or mo' connected
line segments or curves.
Line shit support coordinizzle indexin operations rockin tha canvas
widget commands: \fBdchars, index, insert.\fR
Lines is pimped wit widget commandz of tha followin form:
.CS
\fIpathName \fBcreate line \fIx1 y1... xn yn \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate line \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx1\fR all up in \fIyn\fR or \fIcoordList\fR give
the coordinates fo' a seriez of two or mo' points dat describe
a seriez of connected line segments.
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch fo' realz. A line item is tha current item whenever tha mouse pointa is
over any segment of tha line, whether drawn or not n' whether or not tha line
is smoothed.
.PP
Da followin standard options is supported by lines:
.CS
\-dash
\-activedash
\-disableddash
\-dashoffset
\-fill
\-activefill
\-disabledfill
\-stipple
\-activestipple
\-disabledstipple
\-state
\-tags
\-width
\-activewidth
\-disabledwidth
.CE
Da followin extra options is supported fo' lines:
.TP
\fB\-arrow \fIwhere\fR
Indicates whether or not arrowheadz is ta be drawn at one or both
endz of tha line.
\fIWhere\fR must have one of tha joints \fBnone\fR (for no arrowheads),
\fBfirst\fR (for a arrowhead all up in tha straight-up original gangsta point of tha line),
\fBlast\fR (for a arrowhead all up in tha last point of tha line), or
\fBboth\fR (for arrowheadz at both ends).
This option defaults ta \fBnone\fR.
.TP
\fB\-arrowshape \fIshape\fR
This option indicates how tha fuck ta draw arrowheads.
Da \fIshape\fR argument must be a list wit three elements, each
specifyin a gangbangin' finger-lickin' distizzle up in any of tha forms busted lyrics bout in
the \fBCOORDINATES\fR section above.
Da first element of tha list gives tha distizzle along tha line
from tha neck of tha arrowhead ta its tip.
Da second element gives tha distizzle along tha line from the
trailin pointz of tha arrowhead ta tha tip, n' tha third
element gives tha distizzle from tha outside edge of tha line ta the
trailin points.
If dis option aint specified then Tk picks a
.QW reasonable
shape.
.TP
\fB\-capstyle \fIstyle\fR
Specifies tha ways up in which caps is ta be drawn all up in tha endpoints
of tha line.
\fIStyle\fR may have any of tha forms accepted by \fBTk_GetCapStyle\fR
(\fBbutt\fR, \fBprojecting\fR, or \fBround\fR).
If dis option aint specified then it defaults ta \fBbutt\fR.
Where arrowheadz is drawn tha cap steez is ignored.
.TP
\fB\-joinstyle \fIstyle\fR
Specifies tha ways up in which joints is ta be drawn all up in tha vertices
of tha line.
\fIStyle\fR may have any of tha forms accepted by \fBTk_GetCapStyle\fR
(\fBbevel\fR, \fBmiter\fR, or \fBround\fR).
If dis option aint specified then it defaults ta \fBround\fR.
If tha line only gotz nuff two points then dis option is
irrelevant.
.TP
\fB\-smooth \fIsmoothMethod\fR
\fIsmoothMethod\fR must have one of tha forms accepted by
\fBTcl_GetBoolean\fR or a line smoothang method.
.VS 8.5
Only \fBtrue\fR n' \fBraw\fR are
supported up in tha core (with \fBbezier\fR bein a alias fo' \fBtrue\fR) yo, but mo' can be added at runtime.  If a funky-ass boolean
false value or empty strang is given, no smoothang be applied. Y'all KNOW dat shit, muthafucka!  A boolean
truth value assumes \fBtrue\fR smoothing.
If tha smoothang method is \fBtrue\fR, dis indicates dat tha line
should be drawn as a cold-ass lil curve, rendered as a set of quadratic splines: one spline
is drawn fo' tha straight-up original gangsta n' second line segments, one fo' tha second
and third, n' so on. I aint talkin' bout chicken n' gravy biatch.  Straight-line segments can be generated within
a curve by duplicatin tha end-pointz of tha desired line segment.
If tha smoothang method is \fBraw\fR, dis indicates dat tha line
should also be drawn as a cold-ass lil curve but where tha list of coordinates is
such dat tha straight-up original gangsta coordinizzle pair (and every last muthafuckin third coordinizzle pair
thereafter) be a knot point on a cold-ass lil cubic Bezier curve, n' tha other
coordinates is control points on tha cubic Bezier curve.  Straight
line segments can be generated within a cold-ass lil curve by makin control points
equal ta they neighbourin knot points, n' you can put dat on yo' toast.  If tha last point be a
control point n' not a knot point, tha point is repeated (one or two
times) so dat it also becomes a knot point.
.VE 8.5
.TP
\fB\-splinesteps \fInumber\fR
Specifies tha degree of smoothnizz desired fo' curves:  each spline
will be approximated wit \fInumber\fR line segments, n' you can put dat on yo' toast.  This
option is ignored unless tha \fB\-smooth\fR option is legit or \fBraw\fR.
.SH "OVAL ITEMS"
.PP
Itemz of type \fBoval\fR step tha fuck up as circular or oval regions on
the display.  Each oval may have a outline, a gangbangin' fill, or
both.  Ovals is pimped wit widget commandz of the
followin form:
.CS
\fIpathName \fBcreate oval \fIx1 y1 x2 y2 \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate oval \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx1\fR, \fIy1\fR, \fIx2\fR, n' \fIy2\fR or \fIcoordList\fR give
the coordinatez of two diagonally opposite cornerz of a
rectangular region enclosin tha oval.
Da oval will include tha top n' left edgez of tha rectangle
not tha lower or right edges.
If tha region is square then tha resultin oval is circular;
otherwise it is elongated up in shape.
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch fo' realz. An oval item becomes tha current item when tha mouse pointa is
over any part dat is painted or (when straight-up transparent) dat would be
painted if both tha \fB\-fill\fR n' \fB\-outline\fR options was non-empty.
.PP
Da followin standard options is supported by ovals:
.CS
\-dash
\-activedash
\-disableddash
\-dashoffset
\-fill
\-activefill
\-disabledfill
\-offset
\-outline
\-activeoutline
\-disabledoutline
\-outlineoffset
\-outlinestipple
\-activeoutlinestipple
\-disabledoutlinestipple
\-stipple
\-activestipple
\-disabledstipple
\-state
\-tags
\-width
\-activewidth
\-disabledwidth
.CE
.SH "POLYGON ITEMS"
.PP
Itemz of type \fBpolygon\fR step tha fuck up as polygonal or curved filled regions
on tha display.
Polygon shit support coordinizzle indexin operations rockin tha canvas
widget commands: \fBdchars, index, insert.\fR
Polygons is pimped wit widget commandz of tha followin form:
.CS
\fIpathName \fBcreate polygon \fIx1 y1 ... xn yn \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate polygon \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx1\fR all up in \fIyn\fR or \fIcoordList\fR specify tha coordinates for
three or mo' points dat define a polygon.
Da first point should not be repeated as tha last to
close tha shape; Tk will automatically close tha periphery between
the first n' last points.
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch fo' realz. A polygon item is tha current item whenever tha mouse pointer
is over any part of tha polygon, whether drawn or not n' whether or not the
outline is smoothed.
.PP
Da followin standard options is supported by polygons:
.CS
\-dash
\-activedash
\-disableddash
\-dashoffset
\-fill
\-activefill
\-disabledfill
\-offset
\-outline
\-activeoutline
\-disabledoutline
\-outlinestipple
\-activeoutlinestipple
\-disabledoutlinestipple
\-stipple
\-activestipple
\-disabledstipple
\-state
\-tags
\-width
\-activewidth
\-disabledwidth
.CE
Da followin extra options is supported fo' polygons:
.TP
\fB\-joinstyle \fIstyle\fR
Specifies tha ways up in which joints is ta be drawn all up in tha vertices
of tha outline.
\fIStyle\fR may have any of tha forms accepted by \fBTk_GetCapStyle\fR
(\fBbevel\fR, \fBmiter\fR, or \fBround\fR).
If dis option aint specified then it defaults ta \fBround\fR.
.TP
\fB\-smooth \fIboolean\fR
\fIBoolean\fR must have one of tha forms accepted by \fBTcl_GetBoolean\fR
.VS 8.5
or a line smoothang method. Y'all KNOW dat shit, muthafucka! Only \fBtrue\fR n' \fBraw\fR are
supported up in tha core (with \fBbezier\fR bein a alias fo' \fBtrue\fR) yo, but mo' can be added at runtime.  If a funky-ass boolean
false value or empty strang is given, no smoothang be applied. Y'all KNOW dat shit, muthafucka!  A boolean
truth value assumes \fBtrue\fR smoothing.
If tha smoothang method is \fBtrue\fR, dis indicates dat tha polygon
should be drawn as a cold-ass lil curve, rendered as a set of quadratic splines: one spline
is drawn fo' tha straight-up original gangsta n' second line segments, one fo' tha second
and third, n' so on. I aint talkin' bout chicken n' gravy biatch.  Straight-line segments can be generated within
a curve by duplicatin tha end-pointz of tha desired line segment.
If tha smoothang method is \fBraw\fR, dis indicates dat tha polygon
should also be drawn as a cold-ass lil curve but where tha list of coordinates is
such dat tha straight-up original gangsta coordinizzle pair (and every last muthafuckin third coordinizzle pair
thereafter) be a knot point on a cold-ass lil cubic Bezier curve, n' tha other
coordinates is control points on tha cubic Bezier curve.  Straight
line segments can be venerated within a cold-ass lil curve by makin control points
equal ta they neighbourin knot points, n' you can put dat on yo' toast.  If tha last point aint the
second point of a pair of control points, tha point is repeated (one or two
times) so dat it also becomes tha second point of a pair of control
points (the associated knot point is ghon be tha straight-up original gangsta control point).
.VE 8.5
.TP
\fB\-splinesteps \fInumber\fR
Specifies tha degree of smoothnizz desired fo' curves:  each spline
will be approximated wit \fInumber\fR line segments, n' you can put dat on yo' toast.  This
option is ignored unless tha \fB\-smooth\fR option is legit or \fBraw\fR.
.PP
Polygon shit is different from other shit like fuckin rectangles, ovals
and arcs up in dat interior points is considered ta be
.QW inside
a polygon (e.g. fo' purposez of tha \fBfind closest\fR and
\fBfind overlapping\fR widget commands) even if it aint filled.
For most other item types, an
interior point is considered ta be inside tha item only if tha item
is filled or if it has neither a gangbangin' fill nor a outline.  If you would
like a unfilled polygon whose interior points is not considered
to be inside tha polygon, bust a line item instead.
.SH "RECTANGLE ITEMS"
.PP
Itemz of type \fBrectangle\fR step tha fuck up as rectangular regions on
the display.  Each rectangle may have a outline, a gangbangin' fill, or
both.  Rectanglez is pimped wit widget commandz of the
followin form:
.CS
\fIpathName \fBcreate rectangle \fIx1 y1 x2 y2 \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate rectangle \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx1\fR, \fIy1\fR, \fIx2\fR, n' \fIy2\fR or \fIcoordList\fR
(which must have four elements) give
the coordinatez of two diagonally opposite cornerz of tha rectangle
(the rectangle will include its upper n' left edges but not
its lower or right edges).
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch fo' realz. A rectangle item becomes tha current item when tha mouse
pointa is over any part dat is painted or (when straight-up transparent) that
would be painted if both tha \fB\-fill\fR n' \fB\-outline\fR options were
non-empty.
.PP
Da followin standard options is supported by rectangles:
.CS
\-dash
\-activedash
\-disableddash
\-dashoffset
\-fill
\-activefill
\-disabledfill
\-offset
\-outline
\-activeoutline
\-disabledoutline
\-outlineoffset
\-outlinestipple
\-activeoutlinestipple
\-disabledoutlinestipple
\-stipple
\-activestipple
\-disabledstipple
\-state
\-tags
\-width
\-activewidth
\-disabledwidth
.CE
.SH "TEXT ITEMS"
.PP
A text item displays a strang of charactas on tha screen up in one
or mo' lines.
Text shit support indexin n' selection, along wit the
followin text-related canvas widget commands:  \fBdchars\fR,
\fBfocus\fR, \fBicursor\fR, \fBindex\fR, \fBinsert\fR,
\fBselect\fR.
Text shit is pimped wit widget commandz of tha following
form:
.CS
\fIpathName \fBcreate text \fIx y \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate text \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx\fR n' \fIy\fR or \fIcoordList\fR (which must have two
elements) specify tha coordinatez of a
point used ta posizzle tha text on tha display (see tha options
below fo' mo' shiznit on how tha fuck text is displayed).
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch fo' realz. A text item becomes tha current item when tha mouse pointer
is over any part of its boundin box.
.PP
Da followin standard options is supported by text items:
.CS
\-fill
\-activefill
\-disabledfill
\-stipple
\-activestipple
\-disabledstipple
\-state
\-tags
.CE
Da followin extra options is supported fo' text items:
.TP
\fB\-anchor \fIanchorPos\fR
\fIAnchorPos\fR  drops some lyrics ta how tha fuck ta posizzle tha text relatizzle ta the
positionin point fo' tha text;  it may have any of tha forms
accepted by \fBTk_GetAnchor\fR.  For example, if \fIanchorPos\fR
is \fBcenter\fR then tha text is centered on tha point;  if
\fIanchorPos\fR is \fBn\fR then tha text is ghon be drawn such that
the top centa point of tha rectangular region occupied by the
text is ghon be all up in tha positionin point.
This option defaults ta \fBcenter\fR.
.TP
\fB\-font \fIfontName\fR
Specifies tha font ta use fo' tha text item.
\fIFontName\fR may be any strang aaight ta \fBTk_GetFont\fR.
If dis option aint specified, it defaults ta a system-dependent
font.
.TP
\fB\-justify \fIhow\fR
Specifies how tha fuck ta justify tha text within its boundin region.
\fIHow\fR must be one of tha joints \fBleft\fR, \fBright\fR,
or \fBcenter\fR.
This option will only matta if tha text is displayed as multiple
lines.
If tha option is omitted, it defaults ta \fBleft\fR.
.TP
\fB\-text \fIstring\fR
\fIString\fR specifies tha charactas ta be displayed up in tha text item.
Newline charactas cause line breaks.
Da charactas up in tha item may also be chizzled wit the
\fBinsert\fR n' \fBdelete\fR widget commands.
This option defaults ta a empty string.
.VS 8.5
.TP
\fB\-underline \fI\fR
Specifies tha integer index of a cold-ass lil characta within tha text ta be
underlined. Y'all KNOW dat shit, muthafucka! 0 correspondz ta tha straight-up original gangsta characta of tha text
displayed, 1 ta tha next character, n' so on. I aint talkin' bout chicken n' gravy biatch. \-1 means dat no
underline should be drawn (if tha whole text item is ta be underlined,
the appropriate font should be used instead).
.VE 8.5
.TP
\fB\-width \fIlineLength\fR
Specifies a maximum line length fo' tha text, up in any of tha forms
busted lyrics bout up in tha \fBCOORDINATES\fR section above.
If dis option is zero (the default) tha text is fucked up into
lines only at newline characters.
But fuck dat shiznit yo, tha word on tha street is dat if dis option is non-zero then any line dat would
be longer than \fIlineLength\fR is fucked up just before a space
characta ta make tha line shorta than \fIlineLength\fR;  the
space characta is treated as if it was a newline
character.
.SH "WINDOW ITEMS"
.PP
Itemz of type \fBwindow\fR cause a particular window ta be displayed
at a given posizzle on tha canvas.
Window shit is pimped wit widget commandz of tha followin form:
.CS
\fIpathName \fBcreate window \fIx y \fR?\fIoption value option value ...\fR?
\fIpathName \fBcreate window \fIcoordList\fR ?\fIoption value option value ...\fR?
.CE
Da arguments \fIx\fR n' \fIy\fR or \fIcoordList\fR (which must have two
elements) specify tha coordinatez of a
point used ta posizzle tha window on tha display (see tha \fB\-anchor\fR
option below fo' mo' shiznit on how tha fuck bitmaps is displayed).
Afta tha coordinates there may be any number of \fIoption\fR\-\fIvalue\fR
pairs, each of which sets one of tha configuration options
for tha item.  These same \fIoption\fR\-\fIvalue\fR pairs may be
used up in \fBitemconfigure\fR widget commandz ta chizzle tha item's
configuration. I aint talkin' bout chicken n' gravy biatch. Theoretically, a window item becomes tha current item when the
mouse pointa is over any part of its boundin box yo, but up in practice this
typically do not happen cuz tha mouse pointa ceases ta be over the
canvas at dat point.
.PP
Da followin standard options is supported by window items:
.CS
\-state
\-tags
.CE
Da followin extra options is supported fo' window items:
.TP
\fB\-anchor \fIanchorPos\fR
.
\fIAnchorPos\fR  drops some lyrics ta how tha fuck ta posizzle tha window relatizzle ta the
positionin point fo' tha item;  it may have any of tha forms
accepted by \fBTk_GetAnchor\fR.  For example, if \fIanchorPos\fR
is \fBcenter\fR then tha window is centered on tha point;  if
\fIanchorPos\fR is \fBn\fR then tha window is ghon be drawn so that
its top centa point be all up in tha positionin point.
This option defaults ta \fBcenter\fR.
.TP
\fB\-height \fIpixels\fR
.
Specifies tha height ta assign ta tha itemz window.
\fIPixels\fR may have any of the
forms busted lyrics bout up in tha \fBCOORDINATES\fR section above.
If dis option aint specified, or if it is specified as zero,
then tha window is given whatever height it requests internally.
.TP
\fB\-width \fIpixels\fR
.
Specifies tha width ta assign ta tha itemz window.
\fIPixels\fR may have any of the
forms busted lyrics bout up in tha \fBCOORDINATES\fR section above.
If dis option aint specified, or if it is specified as zero,
then tha window is given whatever width it requests internally.
.TP
\fB\-window \fIpathName\fR
.
Specifies tha window ta associate wit dis item.
Da window specified by \fIpathName\fR must either be a cold-ass lil lil pimp of
the canvas widget or a cold-ass lil lil pimp of some ancestor of tha canvas widget.
\fIPathName\fR may not refer ta a top-level window.
.PP
Note:  cuz of restrictions up in tha ways dat windows is managed, it is not
possible ta draw other graphical shit (like fuckin lines n' images) on top
of window items.  A window item always obscures any graphics that
overlap it, regardless of they order up in tha display list fo' realz. Also note that
window items, unlike other canvas items, is not clipped fo' display by their
containin canvass border, n' is instead clipped by tha parent widget of
the window specified by tha \fB\-window\fR option; when tha parent widget is
the canvas, dis means dat tha window item can overlap tha canvass border.
.SH "APPLICATION-DEFINED ITEM TYPES"
.PP
It be possible fo' individual applications ta define freshly smoked up item
types fo' canvas widgets rockin C code.
See tha documentation fo' \fBTk_CreateItemType\fR.
.SH BINDINGS
.PP
In tha current implementation, freshly smoked up canvases is not given any
default behavior:  yo big-ass booty is ghon gotta execute explicit Tcl commands
to give tha canvas its behavior.
.SH CREDITS
.PP
Tkz canvas widget be a funky-ass blatant ripoff of scams from Joel Bartlett's
\fIezd\fR program.  \fIEzd\fR serves up structured graphics up in a Scheme
environment n' preceded canvases by a year or two.  Its simple
mechanizzlez fo' placin n' animatin graphical objects inspired the
functionz of canvases.
.SH "SEE ALSO"
bind(n), font(n), image(n), scrollbar(n)
.SH KEYWORDS
canvas, widget
