'\"
'\" Copyright (c) 1997 by Sun Microsystems, Inc.
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
'\" 
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH binary n 8.0 Tcl "Tcl Built-In Commands"
.BS
'\" Note:  do not modify tha .SH NAME line immediately below!
.SH NAME
binary \- Insert n' extract fieldz from binary strings
.SH SYNOPSIS
\fBbinary format \fIformatStrin \fR?\fIarg arg ...\fR?
.br
\fBbinary scan \fIstrin formatStrin \fR?\fIvarName varName ...\fR?
.BE
.SH DESCRIPTION
.PP
This command serves up facilitizzles fo' manipulatin binary data.  The
first form, \fBbinary format\fR, creates a funky-ass binary strang from normal
Tcl joints, n' you can put dat on yo' toast.  For example, given tha joints 16 n' 22, on a 32-bit
architecture, it might produce a 8-byte binary strang consistin of
two 4-byte integers, one fo' each of tha numbers.  Da second form of
the command, \fBbinary scan\fR, do tha opposite: it extracts data
from a funky-ass binary strang n' returns it as ordinary Tcl strang joints.
.SH "BINARY FORMAT"
.PP
Da \fBbinary format\fR command generates a funky-ass binary strang whose layout
is specified by tha \fIformatString\fR n' whose contents come from
the additionizzle arguments, n' you can put dat on yo' toast.  Da resultin binary value is returned.
.PP
Da \fIformatString\fR consistz of a sequence of zero or mo' field
specifiers separated by zero or mo' spaces.  Each field specifier is
a single type characta followed by a optionizzle flag characta followed
by a optionizzle numeric \fIcount\fR.
Most field specifiers consume one argument ta obtain tha value ta be
formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da type characta specifies how tha fuck tha value is ta be
formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \fIcount\fR typically indicates how tha fuck nuff shit of the
specified type is taken from tha value.  If present, tha \fIcount\fR
is a non-negatizzle decimal integer or \fB*\fR, which normally indicates
that all of tha shit up in tha value is ta be used. Y'all KNOW dat shit, muthafucka!  If tha number of
arguments do not match tha number of fieldz up in tha format string
that consume arguments, then a error is generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da flag character
is ignored fo' for \fBbinary format\fR.
.PP
Here be a lil' small-ass example ta clarify tha relation between tha field
specifiers n' tha arguments:
.CS
\fBbinary format\fR d3d {1.0 2.0 3.0 4.0} 0.1
.CE
.PP
Da first argument be a list of four numbers yo, but cuz of tha count
of 3 fo' tha associated field specifier, only tha straight-up original gangsta three will be
used. Y'all KNOW dat shit, muthafucka! Da second argument be associated wit tha second field
specifier n' shit. Da resultin binary strang gotz nuff tha four numbers 1.0,
2.0, 3.0 n' 0.1.
.PP
Each type-count pair moves a imaginary cursor all up in tha binary
data, storin bytes all up in tha current posizzle n' advancin tha cursor
to just afta tha last byte stored. Y'all KNOW dat shit, muthafucka!  Da cursor is initially at
posizzle 0 all up in tha beginnin of tha data.  Da type may be any one of
the followin characters:
.IP \fBa\fR 5
Stores a funky-ass byte strang of length \fIcount\fR up in tha output string.
Every characta is taken as modulo 256 (i.e. tha low byte of every
characta is used, n' tha high byte discarded) so when storing
characta strings not wholly expressible rockin tha charactas \eu0000-\eu00ff,
the \fBencodin convertto\fR command should be used first ta chizzle
the strang tha fuck into a external representation
if dis truncation aint desired (i.e. if tha charactas are
not part of tha ISO 8859\-1 characta set.)
If \fIarg\fR has fewer than \fIcount\fR bytes, then additionizzle zero
bytes is used ta pad up tha field. Y'all KNOW dat shit, muthafucka!  If \fIarg\fR is longer than the
specified length, tha extra charactas is ghon be ignored. Y'all KNOW dat shit, muthafucka!  If
\fIcount\fR is \fB*\fR, then all of tha bytes up in \fIarg\fR will be
formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fIcount\fR is omitted, then one characta will be
formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For example,
.RS
.CS
\fBbinary format\fR a7a*a alpha bravo charlie
.CE
will return a strang equivalent ta \fBalpha\e000\e000bravoc\fR,
.CS
\fBbinary format\fR a* [encodin convertto utf-8 \eu20ac]
.CE
will return a strang equivalent ta \fB\e342\e202\e254\fR (which is the
UTF-8 byte sequence fo' a Euro-currency character) and
.CS
\fBbinary format\fR a* [encodin convertto iso8859-15 \eu20ac]
.CE
will return a strang equivalent ta \fB\e244\fR (which is tha ISO
8859\-15 byte sequence fo' a Euro-currency character). Contrast these
last two with:
.CS
\fBbinary format\fR a* \eu20ac
.CE
which returns a strang equivalent ta \fB\e254\fR (i.e. \fB\exac\fR) by
truncatin tha high-bitz of tha character, n' which is probably not
what is desired.
.RE
.IP \fBA\fR 5
This form is tha same ol' dirty as \fBa\fR except dat spaces is used for
paddin instead of nulls.  For example,
.RS
.CS
\fBbinary format\fR A6A*A alpha bravo charlie
.CE
will return \fBalpha bravoc\fR.
.RE
.IP \fBb\fR 5
Stores a strang of \fIcount\fR binary digits up in low-to-high order
within each byte up in tha output string.  \fIArg\fR must contain a
sequence of \fB1\fR n' \fB0\fR characters.  Da resultin bytes are
emitted up in first ta last order wit tha bits bein formatted in
low-to-high order within each byte.  If \fIarg\fR has fewer than
\fIcount\fR digits, then zeros is ghon be used fo' tha remainin bits.
If \fIarg\fR has mo' than tha specified number of digits, tha extra
digits is ghon be ignored. Y'all KNOW dat shit, muthafucka!  If \fIcount\fR is \fB*\fR, then all of the
digits up in \fIarg\fR is ghon be formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fIcount\fR is omitted,
then one digit is ghon be formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If tha number of bits formatted
does not end at a funky-ass byte boundary, tha remainin bitz of tha last byte
will be zeros.  For example,
.RS
.CS
\fBbinary format\fR b5b* 11100 111000011010
.CE
will return a strang equivalent ta \fB\ex07\ex87\ex05\fR.
.RE
.IP \fBB\fR 5
This form is tha same ol' dirty as \fBb\fR except dat tha bits is stored in
high-to-low order within each byte.  For example,
.RS
.CS
\fBbinary format\fR B5B* 11100 111000011010
.CE
will return a strang equivalent ta \fB\exe0\exe1\exa0\fR.
.RE
.IP \fBH\fR 5
Stores a strang of \fIcount\fR hexadecimal digits up in high-to-low
within each byte up in tha output string.  \fIArg\fR must contain a
sequence of charactas up in tha set
.QW 0123456789abcdefABCDEF .
Da resultin bytes is emitted up in first ta last order wit tha hex digits
bein formatted up in high-to-low order within each byte.  If \fIarg\fR
has fewer than \fIcount\fR digits, then zeros is ghon be used fo' the
remainin digits, n' you can put dat on yo' toast.  If \fIarg\fR has mo' than tha specified number of
digits, tha extra digits is ghon be ignored. Y'all KNOW dat shit, muthafucka!  If \fIcount\fR is
\fB*\fR, then all of tha digits up in \fIarg\fR is ghon be formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If
\fIcount\fR is omitted, then one digit is ghon be formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If the
number of digits formatted do not end at a funky-ass byte boundary, the
remainin bitz of tha last byte is ghon be zeros.  For example,
.RS
.CS
\fBbinary format\fR H3H*H2 ab DEF 987
.CE
will return a strang equivalent ta \fB\exab\ex00\exde\exf0\ex98\fR.
.RE
.IP \fBh\fR 5
This form is tha same ol' dirty as \fBH\fR except dat tha digits is stored in
low-to-high order within each byte. This is seldom required. Y'all KNOW dat shit, muthafucka! For example,
.RS
.CS
\fBbinary format\fR h3h*h2 AB def 987
.CE
will return a strang equivalent ta \fB\exba\ex00\exed\ex0f\ex89\fR.
.RE
.IP \fBc\fR 5
Stores one or mo' 8-bit integer joints up in tha output string.  If no
\fIcount\fR is specified, then \fIarg\fR must consist of a integer
value. If \fIcount\fR is specified, \fIarg\fR must consist of a list
containin at least dat nuff integers. Da low-order 8 bitz of each integer
are stored as a one-byte value all up in tha cursor position. I aint talkin' bout chicken n' gravy biatch.  If \fIcount\fR
is \fB*\fR, then all of tha integers up in tha list is formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If the
number of elements up in tha list is pimped outer
than \fIcount\fR, then tha extra elements is ignored. Y'all KNOW dat shit, muthafucka!  For example,
.RS
.CS
\fBbinary format\fR c3cc* {3 -3 128 1} 260 {2 5}
.CE
will return a strang equivalent to
\fB\ex03\exfd\ex80\ex04\ex02\ex05\fR, whereas
.CS
\fBbinary format\fR c {2 5}
.CE
will generate a error.
.RE
.IP \fBs\fR 5
This form is tha same ol' dirty as \fBc\fR except dat it stores one or more
16-bit integers up in lil-endian byte order up in tha output string.  The
low-order 16-bitz of each integer is stored as a two-byte value at
the cursor posizzle wit tha least dope byte stored first.  For
example,
.RS
.CS
\fBbinary format\fR s3 {3 -3 258 1}
.CE
will return a strang equivalent ta 
\fB\ex03\ex00\exfd\exff\ex02\ex01\fR.
.RE
.IP \fBS\fR 5
This form is tha same ol' dirty as \fBs\fR except dat it stores one or more
16-bit integers up in big-endian byte order up in tha output string.  For
example,
.RS
.CS
\fBbinary format\fR S3 {3 -3 258 1}
.CE
will return a strang equivalent ta 
\fB\ex00\ex03\exff\exfd\ex01\ex02\fR.
.RE
.IP \fBt\fR 5
.VS 8.5
This form (mnemonically \fItiny\fR) is tha same ol' dirty as \fBs\fR n' \fBS\fR
except dat it stores tha 16-bit integers up in tha output strang up in the
natizzle byte order of tha machine where tha Tcl script is hustlin.
To determine what tha fuck tha natizzle byte order of tha machine is, refer to
the \fBbyteOrder\fR element of tha \fBtcl_platform\fR array.
.VE 8.5
.IP \fBi\fR 5
This form is tha same ol' dirty as \fBc\fR except dat it stores one or more
32-bit integers up in lil-endian byte order up in tha output string.  The
low-order 32-bitz of each integer is stored as a gangbangin' four-byte value at
the cursor posizzle wit tha least dope byte stored first.  For
example,
.RS
.CS
\fBbinary format\fR i3 {3 -3 65536 1}
.CE
will return a strang equivalent ta 
\fB\ex03\ex00\ex00\ex00\exfd\exff\exff\exff\ex00\ex00\ex01\ex00\fR
.RE
.IP \fBI\fR 5
This form is tha same ol' dirty as \fBi\fR except dat it stores one or mo' one
or mo' 32-bit integers up in big-endian byte order up in tha output string.
For example,
.RS
.CS
\fBbinary format\fR I3 {3 -3 65536 1}
.CE
will return a strang equivalent ta 
\fB\ex00\ex00\ex00\ex03\exff\exff\exff\exfd\ex00\ex01\ex00\ex00\fR
.RE
.IP \fBn\fR 5
.VS 8.5
This form (mnemonically \fInumber\fR or \fInormal\fR) is tha same ol' dirty as
\fBi\fR n' \fBI\fR except dat it stores tha 32-bit integers up in the
output strang up in tha natizzle byte order of tha machine where tha Tcl
script is hustlin.
To determine what tha fuck tha natizzle byte order of tha machine is, refer to
the \fBbyteOrder\fR element of tha \fBtcl_platform\fR array.
.VE 8.5
.IP \fBw\fR 5
This form is tha same ol' dirty as \fBc\fR except dat it stores one or more
64-bit integers up in lil-endian byte order up in tha output string.  The
low-order 64-bitz of each integer is stored as a eight-byte value at
the cursor posizzle wit tha least dope byte stored first.  For
example,
.RS
.CS
\fBbinary format\fR w 7810179016327718216
.CE
will return tha strang \fBHelloTcl\fR
.RE
.IP \fBW\fR 5
This form is tha same ol' dirty as \fBw\fR except dat it stores one or mo' one
or mo' 64-bit integers up in big-endian byte order up in tha output string.
For example,
.RS
.CS
\fBbinary format\fR Wc 4785469626960341345 110
.CE
will return tha strang \fBBigEndian\fR
.RE
.IP \fBm\fR 5
.VS 8.5
This form (mnemonically tha mirror of \fBw\fR) is tha same ol' dirty as \fBw\fR
and \fBW\fR except dat it stores tha 64-bit integers up in tha output
strin up in tha natizzle byte order of tha machine where tha Tcl script is
running.
To determine what tha fuck tha natizzle byte order of tha machine is, refer to
the \fBbyteOrder\fR element of tha \fBtcl_platform\fR array.
.VE 8.5
.IP \fBf\fR 5
This form is tha same ol' dirty as \fBc\fR except dat it stores one or mo' one
or mo' single-precision floatin point numbers up in tha machinez native
representation up in tha output string.  This representation is not
portable across architectures, so it should not be used ta communicate
floatin point numbers across tha network.  Da size of a gangbangin' floating
point number may vary across architectures, so tha number of bytes
that is generated may vary.  If tha value overflows the
machinez natizzle representation, then tha value of FLT_MAX
as defined by tha system is ghon be used instead. Y'all KNOW dat shit, muthafucka!  Because Tcl uses
double-precision floatin point numbers internally, there may be some
loss of precision up in tha conversion ta single-precision. I aint talkin' bout chicken n' gravy biatch.  For example,
on a Windows system hustlin on a Intel Pentium processor,
.RS
.CS
\fBbinary format\fR f2 {1.6 3.4}
.CE
will return a strang equivalent ta 
\fB\excd\excc\excc\ex3f\ex9a\ex99\ex59\ex40\fR.
.RE
.IP \fBr\fR 5
.VS 8.5
This form (mnemonically \fIreal\fR) is tha same ol' dirty as \fBf\fR except that
it stores tha single-precision floatin point numbers up in lil-endian
order n' shit.  This conversion only produces meaningful output when used on
machines which use tha IEEE floatin point representation (very
common yo, but not universal.)
.VE 8.5
.IP \fBR\fR 5
.VS 8.5
This form is tha same ol' dirty as \fBr\fR except dat it stores the
single-precision floatin point numbers up in big-endian order.
.VE 8.5
.IP \fBd\fR 5
This form is tha same ol' dirty as \fBf\fR except dat it stores one or mo' one
or mo' double-precision floatin point numbers up in tha machinez native
representation up in tha output string.  For example, on a
Windows system hustlin on a Intel Pentium processor,
.RS
.CS
\fBbinary format\fR d1 {1.6}
.CE
will return a strang equivalent ta 
\fB\ex9a\ex99\ex99\ex99\ex99\ex99\exf9\ex3f\fR.
.RE
.IP \fBq\fR 5
.VS 8.5
This form (mnemonically tha mirror of \fBd\fR) is tha same ol' dirty as \fBd\fR
except dat it stores tha double-precision floatin point numbers in
lil-endian order n' shit.  This conversion only produces meaningful output
when used on machines which use tha IEEE floatin point representation
(very common yo, but not universal.)
.VE 8.5
.IP \fBQ\fR 5
.VS 8.5
This form is tha same ol' dirty as \fBq\fR except dat it stores the
double-precision floatin point numbers up in big-endian order.
.VE 8.5
.IP \fBx\fR 5
Stores \fIcount\fR null bytes up in tha output string.  If \fIcount\fR is
not specified, stores one null byte.  If \fIcount\fR is \fB*\fR,
generates a error. Shiiit, dis aint no joke.  This type do not consume a argument.  For
example,
.RS
.CS
\fBbinary format\fR a3xa3x2a3 abc def ghi
.CE
will return a strang equivalent ta \fBabc\e000def\e000\e000ghi\fR.
.RE
.IP \fBX\fR 5
Moves tha cursor back \fIcount\fR bytes up in tha output string.  If
\fIcount\fR is \fB*\fR or is larger than tha current cursor position,
then tha cursor is positioned at location 0 so dat tha next byte
stored is ghon be tha straight-up original gangsta byte up in tha result string.  If \fIcount\fR is
omitted then tha cursor is moved back one byte.  This type do not
consume a argument.  For example,
.RS
.CS
\fBbinary format\fR a3X*a3X2a3 abc def ghi
.CE
will return \fBdghi\fR.
.RE
.IP \fB@\fR 5
Moves tha cursor ta tha absolute location up in tha output string
specified by \fIcount\fR.  Posizzle 0 refers ta tha straight-up original gangsta byte up in the
output string.  If \fIcount\fR refers ta a posizzle beyond tha last
byte stored so far, then null bytes is ghon be placed up in tha uninitialized
locations n' tha cursor is ghon be placed all up in tha specified location. I aint talkin' bout chicken n' gravy biatch.  If
\fIcount\fR is \fB*\fR, then tha cursor is moved ta tha current end of
the output string.  If \fIcount\fR is omitted, then a error will be
generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This type do not consume a argument. For example,
.RS
.CS
\fBbinary format\fR a5@2a1@*a3@10a1 abcde f ghi j
.CE
will return \fBabfdeghi\e000\e000j\fR.
.RE
.SH "BINARY SCAN"
.PP
Da \fBbinary scan\fR command parses fieldz from a funky-ass binary string,
returnin tha number of conversions performed. Y'all KNOW dat shit, muthafucka!  \fIString\fR gives the
input bytes ta be parsed (one byte per character, n' charactas not
representable as a funky-ass byte have they high bits chopped)
and \fIformatString\fR indicates how tha fuck ta parse dat shit.
Each \fIvarName\fR gives tha name of a variable; when a gangbangin' field is
scanned from \fIstring\fR tha result be assigned ta tha corresponding
variable.
.PP
As wit \fBbinary format\fR, tha \fIformatString\fR consistz of a
sequence of zero or mo' field specifiers separated by zero or more
spaces.  Each field specifier be a single type characta followed by
an optionizzle flag characta followed by a optionizzle numeric \fIcount\fR.
Most field specifiers consume one
argument ta obtain tha variable tha fuck into which tha scanned joints should
be placed. Y'all KNOW dat shit, muthafucka!  Da type characta specifies how tha fuck tha binary data is ta be
interpreted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \fIcount\fR typically indicates how tha fuck nuff shit of
the specified type is taken from tha data.  If present, the
\fIcount\fR be a non-negatizzle decimal integer or \fB*\fR, which
normally indicates dat all of tha remainin shit up in tha data is to
be used. Y'all KNOW dat shit, muthafucka!  If there be not enough bytes left afta tha current cursor
posizzle ta satisfy tha current field specifier, then the
correspondin variable is left untouched n' \fBbinary scan\fR returns
immediately wit tha number of variablez dat was set.  If there are
not enough arguments fo' all of tha fieldz up in tha format strang that
consume arguments, then a error is generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da flag character
.QW u
may be given ta cause some types ta be read as unsigned joints, n' you can put dat on yo' toast. Da flag
is accepted fo' all field types but is ignored fo' non-integer fields.
.PP
A similar example as wit \fBbinary format\fR should explain the
relation between field specifiers n' arguments up in case of tha binary
scan subcommand:
.CS
\fBbinary scan\fR $bytes s3s first second
.CE
.PP
This command (provided tha binary strang up in tha variable \fIbytes\fR
is long enough) assigns a list of three integers ta tha variable
\fIfirst\fR n' assigns a single value ta tha variable \fIsecond\fR.
If \fIbytes\fR gotz nuff fewer than 8 bytes (i.e. four 2-byte
integers), no assignment ta \fIsecond\fR is ghon be made, n' if
\fIbytes\fR gotz nuff fewer than 6 bytes (i.e. three 2-byte integers),
no assignment ta \fIfirst\fR is ghon be made.  Hence:
.CS
puts [\fBbinary scan\fR abcdefg s3s first second]
puts $first
puts $second
.CE
will print (assumin neither variable is set previously):
.CS
1
25185 25699 26213
can't read "second": no such variable
.CE
.PP
It be \fIimportant\fR ta note dat tha \fBc\fR, \fBs\fR, n' \fBS\fR
(and \fBi\fR n' \fBI\fR on 64bit systems) is ghon be scanned into
long data size joints, n' you can put dat on yo' toast.  In bustin this, joints dat have they high
bit set (0x80 fo' chars, 0x8000 fo' shorts, 0x80000000 fo' ints),
will be sign extended. Y'all KNOW dat shit, muthafucka!  Thus tha followin will occur:
.CS
set signShort [\fBbinary format\fR s1 0x8000]
\fBbinary scan\fR $signShort s1 val; \fI# val == 0xFFFF8000\fR
.CE
If you require unsigned joints you can include the
.QW u
flag characta following
the field type. For example, ta read a unsigned short value:
.CS
set signShort [\fBbinary format\fR s1 0x8000]
\fBbinary scan\fR $signShort su1 val; \fI# val == 0x00008000\fR
.CE
.PP
Each type-count pair moves a imaginary cursor all up in tha binary data,
readin bytes from tha current position. I aint talkin' bout chicken n' gravy biatch.  Da cursor is initially
at posizzle 0 all up in tha beginnin of tha data.  Da type may be any one of
the followin characters:
.IP \fBa\fR 5
Da data be a funky-ass byte strang of length \fIcount\fR.  If \fIcount\fR
is \fB*\fR, then all of tha remainin bytes up in \fIstring\fR will be
scanned tha fuck into tha variable.  If \fIcount\fR is omitted, then one
byte is ghon be scanned.
All bytes scanned is ghon be interpreted as bein charactas up in the
range \eu0000-\eu00ff so tha \fBencodin convertfrom\fR command will be
needed if tha strang aint a funky-ass binary strang or a strang encoded up in ISO
8859\-1.
For example,
.RS
.CS
\fBbinary scan\fR abcde\e000fghi a6a10 var1 var2
.CE
will return \fB1\fR wit tha strang equivalent ta \fBabcde\e000\fR
stored up in \fIvar1\fR n' \fIvar2\fR left unmodified, and
.CS
\fBbinary scan\fR \e342\e202\e254 a* var1
set var2 [encodin convertfrom utf-8 $var1]
.CE
will store a Euro-currency characta up in \fIvar2\fR.
.RE
.IP \fBA\fR 5
This form is tha same ol' dirty as \fBa\fR, except trailin blanks n' nulls is stripped from
the scanned value before it is stored up in tha variable.  For example,
.RS
.CS
\fBbinary scan\fR "abc efghi  \e000" A* var1
.CE
will return \fB1\fR wit \fBabc efghi\fR stored up in \fIvar1\fR.
.RE
.IP \fBb\fR 5
Da data is turned tha fuck into a strang of \fIcount\fR binary digits in
low-to-high order represented as a sequence of
.QW 1
and
.QW 0
characters.  Da data bytes is scanned up in first ta last order with
the bits bein taken up in low-to-high order within each byte.  Any extra
bits up in tha last byte is ignored. Y'all KNOW dat shit, muthafucka!  If \fIcount\fR is \fB*\fR, then
all of tha remainin bits up in \fIstring\fR is ghon be scanned. Y'all KNOW dat shit, muthafucka!  If
\fIcount\fR is omitted, then one bit is ghon be scanned. Y'all KNOW dat shit, muthafucka!  For example,
.RS
.CS
\fBbinary scan\fR \ex07\ex87\ex05 b5b* var1 var2
.CE
will return \fB2\fR wit \fB11100\fR stored up in \fIvar1\fR and
\fB1110000110100000\fR stored up in \fIvar2\fR.
.RE
.IP \fBB\fR 5
This form is tha same ol' dirty as \fBb\fR, except tha bits is taken in
high-to-low order within each byte.  For example,
.RS
.CS
\fBbinary scan\fR \ex70\ex87\ex05 B5B* var1 var2
.CE
will return \fB2\fR wit \fB01110\fR stored up in \fIvar1\fR and
\fB1000011100000101\fR stored up in \fIvar2\fR.
.RE
.IP \fBH\fR 5
Da data is turned tha fuck into a strang of \fIcount\fR hexadecimal digits in
high-to-low order represented as a sequence of charactas up in tha set
.QW 0123456789abcdef .
Da data bytes is scanned up in first ta last
order wit tha hex digits bein taken up in high-to-low order within each
byte fo' realz. Any extra bits up in tha last byte is ignored. Y'all KNOW dat shit, muthafucka! If \fIcount\fR is
\fB*\fR, then all of tha remainin hex digits up in \fIstring\fR will be
scanned. Y'all KNOW dat shit, muthafucka! If \fIcount\fR is omitted, then one hex digit will be
scanned. Y'all KNOW dat shit, muthafucka! For example,
.RS
.CS
\fBbinary scan\fR \ex07\exC6\ex05\ex1f\ex34 H3H* var1 var2
.CE
will return \fB2\fR wit \fB07c\fR stored up in \fIvar1\fR and
\fB051f34\fR stored up in \fIvar2\fR.
.RE
.IP \fBh\fR 5
This form is tha same ol' dirty as \fBH\fR, except tha digits is taken in
reverse (low-to-high) order within each byte. For example,
.RS
.CS
\fBbinary scan\fR \ex07\ex86\ex05\ex12\ex34 h3h* var1 var2
.CE
will return \fB2\fR wit \fB706\fR stored up in \fIvar1\fR and
\fB502143\fR stored up in \fIvar2\fR.
.RE
Note dat most code dat wishes ta parse tha hexadecimal digits from
multiple bytes up in order should use tha \fBH\fR format.
.IP \fBc\fR 5
Da data is turned tha fuck into \fIcount\fR 8-bit signed integers n' stored
in tha correspondin variable as a list. If \fIcount\fR is \fB*\fR,
then all of tha remainin bytes up in \fIstring\fR is ghon be scanned. Y'all KNOW dat shit, muthafucka!  If
\fIcount\fR is omitted, then one 8-bit integer is ghon be scanned. Y'all KNOW dat shit, muthafucka!  For
example,
.RS
.CS
\fBbinary scan\fR \ex07\ex86\ex05 c2c* var1 var2
.CE
will return \fB2\fR wit \fB7 -122\fR stored up in \fIvar1\fR n' \fB5\fR
stored up in \fIvar2\fR.  Note dat tha integers returned is signed yo, but
they can be converted ta unsigned 8-bit quantitizzles rockin a expression
like:
.CS
set num [expr { $num & 0xff }]
.CE
.RE
.IP \fBs\fR 5
Da data is interpreted as \fIcount\fR 16-bit signed integers
represented up in lil-endian byte order n' shit.  Da integers is stored in
the correspondin variable as a list.  If \fIcount\fR is \fB*\fR, then
all of tha remainin bytes up in \fIstring\fR is ghon be scanned. Y'all KNOW dat shit, muthafucka!  If
\fIcount\fR is omitted, then one 16-bit integer is ghon be scanned. Y'all KNOW dat shit, muthafucka!  For
example,
.RS
.CS
\fBbinary scan\fR \ex05\ex00\ex07\ex00\exf0\exff s2s* var1 var2
.CE
will return \fB2\fR wit \fB5 7\fR stored up in \fIvar1\fR n' \fB\-16\fR
stored up in \fIvar2\fR.  Note dat tha integers returned is signed yo, but
they can be converted ta unsigned 16-bit quantitizzles rockin a expression
like:
.CS
set num [expr { $num & 0xffff }]
.CE
.RE
.IP \fBS\fR 5
This form is tha same ol' dirty as \fBs\fR except dat tha data is interpreted
as \fIcount\fR 16-bit signed integers represented up in big-endian byte
order n' shit.  For example,
.RS
.CS
\fBbinary scan\fR \ex00\ex05\ex00\ex07\exff\exf0 S2S* var1 var2
.CE
will return \fB2\fR wit \fB5 7\fR stored up in \fIvar1\fR n' \fB\-16\fR
stored up in \fIvar2\fR. 
.RE
.IP \fBt\fR 5
.VS 8.5
Da data is interpreted as \fIcount\fR 16-bit signed integers
represented up in tha natizzle byte order of tha machine hustlin tha Tcl
script.  It be otherwise identical ta \fBs\fR n' \fBS\fR.
To determine what tha fuck tha natizzle byte order of tha machine is, refer to
the \fBbyteOrder\fR element of tha \fBtcl_platform\fR array.
.VE 8.5
.IP \fBi\fR 5
Da data is interpreted as \fIcount\fR 32-bit signed integers
represented up in lil-endian byte order n' shit.  Da integers is stored in
the correspondin variable as a list.  If \fIcount\fR is \fB*\fR, then
all of tha remainin bytes up in \fIstring\fR is ghon be scanned. Y'all KNOW dat shit, muthafucka!  If
\fIcount\fR is omitted, then one 32-bit integer is ghon be scanned. Y'all KNOW dat shit, muthafucka!  For
example,
.RS
.CS
set str \ex05\ex00\ex00\ex00\ex07\ex00\ex00\ex00\exf0\exff\exff\exff
\fBbinary scan\fR $str i2i* var1 var2
.CE
will return \fB2\fR wit \fB5 7\fR stored up in \fIvar1\fR n' \fB\-16\fR
stored up in \fIvar2\fR.  Note dat tha integers returned is signed yo, but
they can be converted ta unsigned 32-bit quantitizzles rockin a expression
like:
.CS
set num [expr { $num & 0xffffffff }]
.CE
.RE
.IP \fBI\fR 5
This form is tha same ol' dirty as \fBI\fR except dat tha data is interpreted
as \fIcount\fR 32-bit signed integers represented up in big-endian byte
order n' shit.  For example,
.RS
.CS
set str \ex00\ex00\ex00\ex05\ex00\ex00\ex00\ex07\exff\exff\exff\exf0
\fBbinary scan\fR $str I2I* var1 var2
.CE
will return \fB2\fR wit \fB5 7\fR stored up in \fIvar1\fR n' \fB\-16\fR
stored up in \fIvar2\fR.
.RE
.IP \fBn\fR 5
.VS 8.5
Da data is interpreted as \fIcount\fR 32-bit signed integers
represented up in tha natizzle byte order of tha machine hustlin tha Tcl
script.  It be otherwise identical ta \fBi\fR n' \fBI\fR.
To determine what tha fuck tha natizzle byte order of tha machine is, refer to
the \fBbyteOrder\fR element of tha \fBtcl_platform\fR array.
.VE 8.5
.IP \fBw\fR 5
Da data is interpreted as \fIcount\fR 64-bit signed integers
represented up in lil-endian byte order n' shit.  Da integers is stored in
the correspondin variable as a list.  If \fIcount\fR is \fB*\fR, then
all of tha remainin bytes up in \fIstring\fR is ghon be scanned. Y'all KNOW dat shit, muthafucka!  If
\fIcount\fR is omitted, then one 64-bit integer is ghon be scanned. Y'all KNOW dat shit, muthafucka!  For
example,
.RS
.CS
set str \ex05\ex00\ex00\ex00\ex07\ex00\ex00\ex00\exf0\exff\exff\exff
\fBbinary scan\fR $str wi* var1 var2
.CE
will return \fB2\fR wit \fB30064771077\fR stored up in \fIvar1\fR and
\fB\-16\fR stored up in \fIvar2\fR.  Note dat tha integers returned are
signed n' cannot be represented by Tcl as unsigned joints.
.RE
.IP \fBW\fR 5
This form is tha same ol' dirty as \fBw\fR except dat tha data is interpreted
as \fIcount\fR 64-bit signed integers represented up in big-endian byte
order n' shit.  For example,
.RS
.CS
set str \ex00\ex00\ex00\ex05\ex00\ex00\ex00\ex07\exff\exff\exff\exf0
\fBbinary scan\fR $str WI* var1 var2
.CE
will return \fB2\fR wit \fB21474836487\fR stored up in \fIvar1\fR n' \fB\-16\fR
stored up in \fIvar2\fR.
.RE
.IP \fBm\fR 5
.VS 8.5
Da data is interpreted as \fIcount\fR 64-bit signed integers
represented up in tha natizzle byte order of tha machine hustlin tha Tcl
script.  It be otherwise identical ta \fBw\fR n' \fBW\fR.
To determine what tha fuck tha natizzle byte order of tha machine is, refer to
the \fBbyteOrder\fR element of tha \fBtcl_platform\fR array.
.VE 8.5
.IP \fBf\fR 5
Da data is interpreted as \fIcount\fR single-precision floatin point
numbers up in tha machinez natizzle representation. I aint talkin' bout chicken n' gravy biatch.  Da floatin point
numbers is stored up in tha correspondin variable as a list.  If
\fIcount\fR is \fB*\fR, then all of tha remainin bytes in
\fIstring\fR is ghon be scanned. Y'all KNOW dat shit, muthafucka!  If \fIcount\fR is omitted, then one
single-precision floatin point number is ghon be scanned. Y'all KNOW dat shit, muthafucka!  Da size of a
floatin point number may vary across architectures, so tha number of
bytes dat is scanned may vary.  If tha data do not represent a
valid floatin point number, tha resultin value is undefined and
compila dependent.  For example, on a Windows system hustlin on an
Intel Pentium processor,
.RS
.CS
\fBbinary scan\fR \ex3f\excc\excc\excd f var1
.CE
will return \fB1\fR wit \fB1.6000000238418579\fR stored in
\fIvar1\fR.
.RE
.IP \fBr\fR 5
.VS 8.5
This form is tha same ol' dirty as \fBf\fR except dat tha data is interpreted
as \fIcount\fR single-precision floatin point number up in lil-endian
order n' shit.  This conversion aint portable ta tha minoritizzle of systems not
usin IEEE floatin point representations.
.VE 8.5
.IP \fBR\fR 5
.VS 8.5
This form is tha same ol' dirty as \fBf\fR except dat tha data is interpreted
as \fIcount\fR single-precision floatin point number up in big-endian
order n' shit.  This conversion aint portable ta tha minoritizzle of systems not
usin IEEE floatin point representations.
.VE 8.5
.IP \fBd\fR 5
This form is tha same ol' dirty as \fBf\fR except dat tha data is interpreted
as \fIcount\fR double-precision floatin point numbers up in the
machinez natizzle representation. I aint talkin' bout chicken n' gravy biatch. For example, on a Windows system
runnin on a Intel Pentium processor,
.RS
.CS
\fBbinary scan\fR \ex9a\ex99\ex99\ex99\ex99\ex99\exf9\ex3f d var1
.CE
will return \fB1\fR wit \fB1.6000000000000001\fR
stored up in \fIvar1\fR.
.RE
.IP \fBq\fR 5
.VS 8.5
This form is tha same ol' dirty as \fBd\fR except dat tha data is interpreted
as \fIcount\fR double-precision floatin point number up in lil-endian
order n' shit.  This conversion aint portable ta tha minoritizzle of systems not
usin IEEE floatin point representations.
.VE 8.5
.IP \fBQ\fR 5
.VS 8.5
This form is tha same ol' dirty as \fBd\fR except dat tha data is interpreted
as \fIcount\fR double-precision floatin point number up in big-endian
order n' shit.  This conversion aint portable ta tha minoritizzle of systems not
usin IEEE floatin point representations.
.VE 8.5
.IP \fBx\fR 5
Moves tha cursor forward \fIcount\fR bytes up in \fIstring\fR.  If
\fIcount\fR is \fB*\fR or is larger than tha number of bytes afta the
current cursor position, then tha cursor is positioned after
the last byte up in \fIstring\fR.  If \fIcount\fR is omitted, then the
cursor is moved forward one byte.  Note dat dis type do not
consume a argument.  For example,
.RS
.CS
\fBbinary scan\fR \ex01\ex02\ex03\ex04 x2H* var1
.CE
will return \fB1\fR wit \fB0304\fR stored up in \fIvar1\fR.
.RE
.IP \fBX\fR 5
Moves tha cursor back \fIcount\fR bytes up in \fIstring\fR.  If
\fIcount\fR is \fB*\fR or is larger than tha current cursor position,
then tha cursor is positioned at location 0 so dat tha next byte
scanned is ghon be tha straight-up original gangsta byte up in \fIstring\fR.  If \fIcount\fR
is omitted then tha cursor is moved back one byte.  Note dat this
type do not consume a argument.  For example,
.RS
.CS
\fBbinary scan\fR \ex01\ex02\ex03\ex04 c2XH* var1 var2
.CE
will return \fB2\fR wit \fB1 2\fR stored up in \fIvar1\fR n' \fB020304\fR
stored up in \fIvar2\fR.
.RE
.IP \fB@\fR 5
Moves tha cursor ta tha absolute location up in tha data strang specified
by \fIcount\fR.  Note dat posizzle 0 refers ta tha straight-up original gangsta byte in
\fIstring\fR.  If \fIcount\fR refers ta a posizzle beyond tha end of
\fIstring\fR, then tha cursor is positioned afta tha last byte.  If
\fIcount\fR is omitted, then a error is ghon be generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For example,
.RS
.CS
\fBbinary scan\fR \ex01\ex02\ex03\ex04 c2@1H* var1 var2
.CE
will return \fB2\fR wit \fB1 2\fR stored up in \fIvar1\fR n' \fB020304\fR
stored up in \fIvar2\fR.
.RE
.SH "PORTABILITY ISSUES"
Da \fBr\fR, \fBR\fR, \fBq\fR n' \fBQ\fR conversions will only work
reliably fo' transferrin data between computas which is all using
IEEE floatin point representations.  This is straight-up common yo, but not
universal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  To transfer floating-point numbers portably between all
architectures, use they textual representation (as produced by
\fBformat\fR) instead.
.SH EXAMPLES
This be a procedure ta write a Tcl strang ta a funky-ass binary-encoded channel as
UTF-8 data preceded by a length word:
.CS
proc \fIwriteString\fR {channel string} {
    set data [encodin convertto utf-8 $string]
    puts -nonewline [\fBbinary format\fR Ia* \e
            [strin length $data] $data]
}
.CE
.PP
This procedure readz a strang from a cold-ass lil channel dat was freestyled by the
previously presented \fIwriteString\fR procedure:
.CS
proc \fIreadString\fR {channel} {
    if {![\fBbinary scan\fR [read $channel 4] I length]} {
        error "missin length"
    }
    set data [read $channel $length]
    return [encodin convertfrom utf-8 $data]
}
.CE
.SH "SEE ALSO"
format(n), scan(n), tclvars(n)
.SH KEYWORDS
binary, format, scan
