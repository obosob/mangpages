'\"
'\" Copyright (c) 1993-1997 Bell Labs Innovations fo' Lucent Technologies
'\" Copyright (c) 1997 Sun Microsystems, Inc.
'\" Copyright (c) 2000 Scriptics Corporation.
'\" Copyright (c) 2004-2005 Donal K. Fellows.
'\"
'\" See tha file "license.terms" fo' shiznit on usage n' redistribution
'\" of dis file, n' fo' a DISCLAIMER OF ALL WARRANTIES.
'\"
.\" Da -*- nroff -*- definitions below is fo' supplemenstrual macros used
.\" up in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describin a argument ta a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" ta describe whether procedure readz or modifies arg,
.\"	and indent is equivalent ta second arg of .IP (shouldn't eva be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizez of arguments fo' settin tab stops.  Type and
.\"	name is examplez of phattest possible arguments dat is ghon be passed
.\"	to .AP later n' shit.  If args is omitted, default tab stops is used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, every last muthafuckin thang will be
.\"	enclosed up in one big-ass box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, fo' use up in markin newly-changed parts
.\"	of playa pages.  Da first argument is ignored n' used fo' recording
.\"	the version when tha .VS was added, so dat tha sidebars can be
.\"	found n' removed when they reach a cold-ass lil certain age.  If another argument
.\"	is present, then a line break is forced before startin tha sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin a indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options fo' a Tk widget. Da manpage
.\"	argument defines where ta look up tha standard options; if
.\"	omitted, defaults ta "options". Da options follow on successive
.\"	lines, up in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options fo' a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option. I aint talkin' bout chicken n' gravy biatch.  cmdName gives the
.\"	optionz name as specified up in tha class command, dbName gives
.\"	the optionz name up in tha option database, n' dbClass gives
.\"	the optionz class up in tha option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 up in quotes, then arg2 normally (for trailin punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print a open parenthesis, arg1 up in quotes, then arg2 normally
.\"	(for trailin punctuation) n' then a cold-ass lil closin parenthesis.
.\"
.\"	# Set up traps n' other miscellaneous shiznit fo' Tcl/Tk playa pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start a argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbin joints fo' .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = startin y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally yo, but don't draw top of
.\"	box if tha box started on a earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = startin y location
.\"	# ^v = 1 (for troff;  fo' nroff dis don't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro ta handle page bottom:  finish off current
.\"	# box/sidebar if up in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if dis is tha boxz first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See tha \\*(So manual entry fo' details on tha standard options.
..
.\"	# OP - start of full description fo' a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks ta word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens n' quotation marks ta word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH namespace n 8.5 Tcl "Tcl Built-In Commands"
.BS
'\" Note:  do not modify tha .SH NAME line immediately below!
.SH NAME
namespace \- create n' manipulate contexts fo' commandz n' variables
.SH SYNOPSIS
\fBnamespace \fR?\fIsubcommand\fR? ?\fIarg ...\fR?
.BE
.SH DESCRIPTION
.PP
Da \fBnamespace\fR command lets you create, access, n' destroy
separate contexts fo' commandz n' variables.
See tha section \fBWHAT IS A NAMESPACE?\fR below
for a funky-ass brief overview of namespaces.
Da legal jointz of \fIsubcommand\fR is listed below.
Note dat you can abbreviate tha \fIsubcommand\fRs.
.TP
\fBnamespace lil pimps \fR?\fInamespace\fR? ?\fIpattern\fR?
Returns a list of all lil pimp namespaces dat belong ta the
namespace \fInamespace\fR.
If \fInamespace\fR aint specified,
then tha lil pimps is returned fo' tha current namespace.
This command returns fully-qualified names,
which start wit a thugged-out double colon (\fB::\fR).
If tha optionizzle \fIpattern\fR is given,
then dis command returns only tha names dat match tha glob-style pattern.
Da actual pattern used is determined as bigs up:
a pattern dat starts wit double colon (\fB::\fR) is used directly,
otherwise tha namespace \fInamespace\fR
(or tha fully-qualified name of tha current namespace)
is prepended onto tha pattern.
.TP
\fBnamespace code \fIscript\fR
Captures tha current namespace context fo' lata execution
of tha script \fIscript\fR.
It returns a freshly smoked up script up in which \fIscript\fR has been wrapped
in a \fBnamespace inscope\fR command.
Da freshly smoked up script has two blingin properties.
First, it can be evaluated up in any namespace n' will cause
\fIscript\fR ta be evaluated up in tha current namespace
(the one where tha \fBnamespace code\fR command was invoked).
Second, additionizzle arguments can be appended ta tha resultin script
and they is ghon be passed ta \fIscript\fR as additionizzle arguments.
For example, suppose tha command
\fBset script [namespace code {foo bar}]\fR
is invoked up in namespace \fB::a::b\fR.
Then \fBeval $script [list x y]\fR
can be executed up in any namespace (assumin tha value of
\fBscript\fR has been passed up in properly)
and gonna git tha same effect as tha command
\fB::namespace eval ::a::b {foo bar x y}\fR.
This command is needed cuz
extensions like Tk normally execute callback scripts
in tha global namespace.
A scoped command captures a cold-ass lil command together wit its namespace context
in a way dat allows it ta be executed properly later.
See tha section \fBSCOPED SCRIPTS\fR fo' some examples
of how tha fuck dis is used ta create callback scripts.
.TP
\fBnamespace current\fR
Returns tha fully-qualified name fo' tha current namespace.
Da actual name of tha global namespace is
.MT
(i.e., a empty string),
but dis command returns \fB::\fR fo' tha global namespace
as a cold-ass lil convenience ta programmers.
.TP
\fBnamespace delete \fR?\fInamespace namespace ...\fR?
Each namespace \fInamespace\fR is deleted
and all variables, procedures, n' lil pimp namespaces
contained up in tha namespace is deleted.
If a procedure is currently executin inside tha namespace,
the namespace is ghon be kept kickin it until tha procedure returns;
however, tha namespace is marked ta prevent other code from
lookin it up by name.
If a namespace do not exist, dis command returns a error.
If no namespace names is given, dis command do nothing.
.TP
\fBnamespace ensemble\fR \fIsubcommand\fR ?\fIarg ...\fR?
.VS 8.5
Creates n' manipulates a cold-ass lil command dat is formed outta a ensemble of
subcommands.  See tha section \fBENSEMBLES\fR below fo' further
details.
.VE 8.5
.TP
\fBnamespace eval\fR \fInamespace arg\fR ?\fIarg ...\fR?
Activates a namespace called \fInamespace\fR n' evaluates some code
in dat context.
If tha namespace do not already exist, it is pimped.
If mo' than one \fIarg\fR argument is specified,
the arguments is concatenated together wit a space between each one
in tha same fashizzle as tha \fBeval\fR command,
and tha result is evaluated.
.RS
.PP
If \fInamespace\fR has leadin namespace qualifiers
and any leadin namespaces do not exist,
they is automatically pimped.
.RE
.TP
\fBnamespace exists\fR \fInamespace\fR
Returns \fB1\fR if \fInamespace\fR be a valid namespace up in tha current
context, returns \fB0\fR otherwise.
.TP
\fBnamespace export \fR?\-\fBclear\fR? ?\fIpattern pattern ...\fR?
Specifies which commandz is exported from a namespace.
Da exported commandz is dem dat can be lata imported
into another namespace rockin a \fBnamespace import\fR command.
Both commandz defined up in a namespace and
commandz tha namespace has previously imported
can be exported by a namespace.
Da commandz do not gotta be defined
at tha time tha \fBnamespace export\fR command is executed.
Each \fIpattern\fR may contain glob-style special characters,
but it may not include any namespace qualifiers.
That is, tha pattern can only specify commands
in tha current (exporting) namespace.
Each \fIpattern\fR be appended onto tha namespacez list of export patterns.
If tha \fB\-clear\fR flag is given,
the namespacez export pattern list is reset ta empty before any
\fIpattern\fR arguments is appended.
If no \fIpattern\fRs is given n' tha \fB\-clear\fR flag aint given,
this command returns tha namespacez current export list.
.TP
\fBnamespace forget \fR?\fIpattern pattern ...\fR?
Removes previously imported commandz from a namespace.
Each \fIpattern\fR be a simple or qualified name such as
\fBx\fR, \fBfoo::x\fR or \fBa::b::p*\fR.
Qualified names contain double colons (\fB::\fR) n' qualify a name
with tha name of one or mo' namespaces.
Each
.QW "qualified pattern"
is qualified wit tha name of a exportin namespace
and may have glob-style special charactas up in tha command name
at tha end of tha qualified name.
Glob charactas may not step tha fuck up in a namespace name.
For each
.QW "simple pattern"
this command deletes tha matchin commandz of the
current namespace dat was imported from a gangbangin' finger-lickin' different namespace.
For
.QW "qualified patterns" ,
this command first findz tha matchin exported commands.
It then checks whether any of dem commands
were previously imported by tha current namespace.
If so, dis command deletes tha correspondin imported commands.
In effect, dis un-does tha action of a \fBnamespace import\fR command.
.TP
\fBnamespace import \fR?\fB\-force\fR? ?\fIpattern\fR \fIpattern ...\fR?
.VS 8.5
Imports commandz tha fuck into a namespace, or queries tha set of imported
commandz up in a namespace.  When no arguments is present,
\fBnamespace import\fR returns tha list of commandz in
the current namespace dat done been imported from other
namespaces.  Da commandz up in tha returned list is in
the format of simple names, wit no namespace qualifiers at all.
This format is suitable fo' composizzle wit \fBnamespace forget\fR
(see \fBEXAMPLES\fR below).
.VE 8.5
When \fIpattern\fR arguments is present,
each \fIpattern\fR be a qualified name like
\fBfoo::x\fR or \fBa::p*\fR.
That is, it includes tha name of a exportin namespace
and may have glob-style special charactas up in tha command name
at tha end of tha qualified name.
Glob charactas may not step tha fuck up in a namespace name.
All tha commandz dat match a \fIpattern\fR string
and which is currently exported from they namespace
are added ta tha current namespace.
This is done by bustin a freshly smoked up command up in tha current namespace
that points ta tha exported command up in its original gangsta namespace;
when tha freshly smoked up imported command is called, it invokes tha exported command.
This command normally returns a error
if a imported command conflicts wit a existin command.
But fuck dat shiznit yo, tha word on tha street is dat if tha \-\fBforce\fR option is given,
imported commandz will silently replace existin commands.
Da \fBnamespace import\fR command has snapshot semantics:
that is, only axed commandz dat is currently defined
in tha exportin namespace is imported.
In other lyrics, you can import only tha commandz dat is up in a namespace
at tha time when tha \fBnamespace import\fR command is executed.
If another command is defined n' exported up in dis namespace lata on,
it aint gonna be imported.
.TP
\fBnamespace inscope\fR \fInamespace\fR \fIscript\fR ?\fIarg ...\fR?
Executes a script up in tha context of tha specified \fInamespace\fR.
This command aint sposed ta fuckin be used directly by programmers;
calls ta it is generated implicitly when applications
use \fBnamespace code\fR commandz ta create callback scripts
that tha applications then regista with, e.g., Tk widgets.
Da \fBnamespace inscope\fR command is much like tha \fBnamespace eval\fR
command except dat tha \fInamespace\fR must already exist,
and \fBnamespace inscope\fR appendz additionizzle \fIarg\fRs
as proper list elements.
.RS
.PP
.CS
\fBnamespace inscope ::foo $script $x $y $z\fR
.CE
is equivalent to
.CS
\fBnamespace eval ::foo [concat $script [list $x $y $z]]\fR
.CE
thus additionizzle arguments aint gonna undergo a second round of substitution,
as is tha case wit \fBnamespace eval\fR.
.RE
.TP
\fBnamespace origin \fIcommand\fR
Returns tha fully-qualified name of tha original gangsta command
to which tha imported command \fIcommand\fR refers.
When a cold-ass lil command is imported tha fuck into a namespace,
a freshly smoked up command is pimped up in dat namespace
that points ta tha actual command up in tha exportin namespace.
If a cold-ass lil command is imported tha fuck into a sequence of namespaces
\fIa, b,...,n\fR where each successive namespace
just imports tha command from tha previous namespace,
this command returns tha fully-qualified name of tha original gangsta command
in tha straight-up original gangsta namespace, \fIa\fR.
If \fIcommand\fR do not refer ta a imported command,
the commandz own fully-qualified name is returned.
.TP
\fBnamespace parent\fR ?\fInamespace\fR?
Returns tha fully-qualified name of tha parent namespace
for namespace \fInamespace\fR.
If \fInamespace\fR aint specified,
the fully-qualified name of tha current namespacez parent is returned.
.TP
\fBnamespace path\fR ?\fInamespaceList\fR?
.\" Should straight-up have tha .TP inside tha .VS yo, but dat triggers a groff bug
.VS 8.5
Returns tha command resolution path of tha current namespace. If
\fInamespaceList\fR is specified as a list of named namespaces, the
current namespacez command resolution path is set ta dem namespaces
and returns tha empty list. Da default command resolution path is
always empty. Right back up in yo muthafuckin ass. See tha section \fBNAME RESOLUTION\fR below fo' an
explanation of tha rulez regardin name resolution.
.VE 8.5
.TP
\fBnamespace qualifiers\fR \fIstring\fR
Returns any leadin namespace qualifiers fo' \fIstring\fR.
Qualifiers is namespace names separated by double colons (\fB::\fR).
For tha \fIstring\fR \fB::foo::bar::x\fR,
this command returns \fB::foo::bar\fR,
and fo' \fB::\fR it returns a empty string.
This command is tha complement of tha \fBnamespace tail\fR command.
Note dat it do not check whether the
namespace names are, up in fact,
the namez of currently defined namespaces.
.TP
\fBnamespace tail\fR \fIstring\fR
Returns tha simple name all up in tha end of a qualified string.
Qualifiers is namespace names separated by double colons (\fB::\fR).
For tha \fIstring\fR \fB::foo::bar::x\fR,
this command returns \fBx\fR,
and fo' \fB::\fR it returns a empty string.
This command is tha complement of tha \fBnamespace qualifiers\fR command.
It do not check whether tha namespace names are, up in fact,
the namez of currently defined namespaces.
.TP
\fBnamespace upvar\fR \fInamespace\fR \fIotherVar myVar \fR?\fIotherVar myVar \fR...
This command arranges fo' one or mo' local variablez up in tha current
procedure ta refer ta variablez up in \fInamespace\fR. Da namespace name is
resolved as busted lyrics bout up in section \fBNAME RESOLUTION\fR.
Da command
\fBnamespace upvar $ns a funky-ass b\fR has tha same ol' dirty behaviour as
\fBupvar 0 ${ns}::a b\fR, wit tha sole exception of tha resolution rules
used fo' qualified namespace or variable names.
\fBnamespace upvar\fR returns a empty string.
.TP
\fBnamespace unknown\fR ?\fIscript\fR?
Sets or returns tha unknown command handlez fo' tha current namespace.
Da handlez is invoked when a cold-ass lil command called from within tha namespace
cannot be found (in either tha current namespace or tha global namespace).
Da \fIscript\fR argument, if given, should be a well
formed list representin a cold-ass lil command name n' optionizzle arguments, n' you can put dat on yo' toast. When
the handlez is invoked, tha full invocation line is ghon be appended ta the
script n' tha result evaluated up in tha context of tha namespace. The
default handlez fo' all namespaces is \fB::unknown\fR. If no argument
is given, it returns tha handlez fo' tha current namespace.
.TP
\fBnamespace which\fR ?\-\fBcommand\fR? ?\-\fBvariable\fR? \fIname\fR
Looks up \fIname\fR as either a cold-ass lil command or variable
and returns its fully-qualified name.
For example, if \fIname\fR do not exist up in tha current namespace
but do exist up in tha global namespace,
this command returns a gangbangin' fully-qualified name up in tha global namespace.
If tha command or variable do not exist,
this command returns a empty string.  If tha variable has been
created but not defined, like fuckin wit tha \fBvariable\fR command
or all up in a \fBtrace\fR on tha variable, dis command will return the
fully-qualified name of tha variable.
If no flag is given, \fIname\fR is treated as a cold-ass lil command name.
See tha section \fBNAME RESOLUTION\fR below fo' a explanation of
the rulez regardin name resolution.
.SH "WHAT IS A NAMESPACE?"
.PP
A namespace be a cold-ass lil collection of commandz n' variables.
It encapsulates tha commandz n' variablez ta ensure dat they
will not interfere wit tha commandz n' variablez of other namespaces.
Tcl has always had one such collection,
which we refer ta as tha \fIglobal namespace\fR.
Da global namespace holdz all global variablez n' commands.
Da \fBnamespace eval\fR command lets you create freshly smoked up namespaces.
For example,
.CS
\fBnamespace eval\fR Counta {
   \fBnamespace export\fR bump
   variable num 0

   proc bump {} {
      variable num
      incr num
   }
}
.CE
creates a freshly smoked up namespace containin tha variable \fBnum\fR and
the procedure \fBbump\fR.
Da commandz n' variablez up in dis namespace is separate from
other commandz n' variablez up in tha same program.
If there be a cold-ass lil command named \fBbump\fR up in tha global namespace,
for example, it is ghon be different from tha command \fBbump\fR
in tha \fBCounter\fR namespace.
.PP
Namespace variablez resemble global variablez up in Tcl.
They exist outside of tha procedures up in a namespace
but can be accessed up in a procedure via tha \fBvariable\fR command,
as shown up in tha example above.
.PP
Namespaces is dynamic.
Yo ass can add n' delete commandz n' variablez at any time,
so you can build up tha contentz of a
namespace over time rockin a seriez of \fBnamespace eval\fR commands.
For example, tha followin seriez of commandz has tha same ol' dirty effect
as tha namespace definizzle shown above:
.CS
\fBnamespace eval\fR Counta {
   variable num 0
   proc bump {} {
      variable num
      return [incr num]
   }
}
\fBnamespace eval\fR Counta {
   proc test {args} {
      return $args
   }
}
\fBnamespace eval\fR Counta {
    rename test ""
}
.CE
Note dat tha \fBtest\fR procedure be added ta tha \fBCounter\fR namespace,
and lata removed via tha \fBrename\fR command.
.PP
Namespaces can have other namespaces within them,
so they nest hierarchically.
A nested namespace is encapsulated inside its parent namespace
and can not interfere wit other namespaces.
.SH "QUALIFIED NAMES"
.PP
Each namespace has a textual name such as
\fBhistory\fR or \fB::safe::interp\fR.
Since namespaces may nest,
qualified names is used ta refer to
commands, variables, n' lil pimp namespaces contained inside namespaces.
Qualified names is similar ta tha hierarchical path names for
Unix filez or Tk widgets,
except dat \fB::\fR is used as tha separator
instead of \fB/\fR or \fB.\fR.
Da topmost or global namespace has tha name
.MT
(i.e., a empty string), although \fB::\fR be a synonym.
As a example, tha name \fB::safe::interp::create\fR
refers ta tha command \fBcreate\fR up in tha namespace \fBinterp\fR
that be a cold-ass lil lil pimp of namespace \fB::safe\fR,
which up in turn be a cold-ass lil lil pimp of tha global namespace, \fB::\fR.
.PP
If you wanna access commandz n' variablez from another namespace,
you must use some extra syntax.
Names must be qualified by tha namespace dat gotz nuff em.
From tha global namespace,
we might access tha \fBCounter\fR procedures like this:
.CS
Counter::bump 5
Counter::Reset
.CE
We could access tha current count like this:
.CS
puts "count = $Counter::num"
.CE
When one namespace gotz nuff another, you may need mo' than one
qualifier ta reach its elements.
If our crazy asses had a namespace \fBFoo\fR dat contained tha namespace \fBCounter\fR,
you could invoke its \fBbump\fR procedure
from tha global namespace like this:
.CS
Foo::Counter::bump 3
.CE
.PP
Yo ass can also use qualified names when you create n' rename commands.
For example, you could add a procedure ta tha \fBFoo\fR
namespace like this:
.CS
proc Foo::Test {args} {return $args}
.CE
And you could move tha same procedure ta another namespace like this:
.CS
rename Foo::Test Bar::Test
.CE
.PP
There is all dem remainin points bout qualified names
that we should cover.
Namespaces have nonempty names except fo' tha global namespace.
\fB::\fR is disallowed up in simple command, variable, n' namespace names
except as a namespace separator.
Extra colons up in any separator part of a qualified name is ignored;
i.e. two or mo' colons is treated as a namespace separator.
A trailin \fB::\fR up in a qualified variable or command name
refers ta tha variable or command named {}.
But fuck dat shiznit yo, tha word on tha street is dat a trailin \fB::\fR up in a qualified namespace name is ignored.
.SH "NAME RESOLUTION"
.PP
In general, all Tcl commandz dat take variable n' command names
support qualified names.
This means you can give qualified names ta such commandz as
\fBset\fR, \fBproc\fR, \fBrename\fR, n' \fBinterp alias\fR.
If you provide a gangbangin' fully-qualified name dat starts wit a \fB::\fR,
there is no question bout what tha fuck command, variable, or namespace
you mean.
But fuck dat shiznit yo, tha word on tha street is dat if tha name do not start wit a \fB::\fR
(i.e., is \fIrelative\fR),
Tcl bigs up basic rulez fo' lookin it up:
Variable names is always resolved
by lookin first up in tha current namespace,
and then up in tha global namespace.
.VS 8.5
Command names is also always resolved by lookin up in tha current
namespace first. If not found there, they is searched fo' up in every
namespace on tha current namespacez command path (which is empty by
default). If not found there, command names is looked up in the
global namespace (or, failin that, is processed by tha \fBunknown\fR
command.)
.VE 8.5
Namespace names, on tha other hand, is always resolved
by lookin up in only tha current namespace.
.PP
In tha followin example,
.CS
set traceLevel 0
\fBnamespace eval\fR Debug {
   printTrace $traceLevel
}
.CE
Tcl looks fo' \fBtraceLevel\fR up in tha namespace \fBDebug\fR
and then up in tha global namespace.
It looks up tha command \fBprintTrace\fR up in tha same way.
If a variable or command name aint found up in either context,
the name is undefined.
To make dis point straight-up clear, consider tha followin example:
.CS
set traceLevel 0
\fBnamespace eval\fR Foo {
   variable traceLevel 3

   \fBnamespace eval\fR Debug {
      printTrace $traceLevel
   }
}
.CE
Here Tcl looks fo' \fBtraceLevel\fR first up in tha namespace \fBFoo::Debug\fR.
Since it aint found there, Tcl then looks fo' it
in tha global namespace.
Da variable \fBFoo::traceLevel\fR is straight-up ignored
durin tha name resolution process.
.PP
Yo ass can use tha \fBnamespace which\fR command ta clear up any question
about name resolution.
For example, tha command:
.CS
\fBnamespace eval\fR Foo::Debug {\fBnamespace which\fR \-variable traceLevel}
.CE
returns \fB::traceLevel\fR.
On tha other hand, tha command,
.CS
\fBnamespace eval\fR Foo {\fBnamespace which\fR \-variable traceLevel}
.CE
returns \fB::Foo::traceLevel\fR.
.PP
As mentioned above,
namespace names is looked up differently
than tha namez of variablez n' commands.
Namespace names is always resolved up in tha current namespace.
This means, fo' example,
that a \fBnamespace eval\fR command dat creates a freshly smoked up namespace
always creates a cold-ass lil lil pimp of tha current namespace
unless tha freshly smoked up namespace name begins wit \fB::\fR.
.PP
Tcl has no access control ta limit what tha fuck variables, commands,
or namespaces you can reference.
If you provide a qualified name dat resolves ta a element
by tha name resolution rule above,
you can access tha element.
.PP
Yo ass can access a namespace variable
from a procedure up in tha same namespace
by rockin tha \fBvariable\fR command.
Much like tha \fBglobal\fR command,
this creates a local link ta tha namespace variable.
If necessary, it also creates tha variable up in tha current namespace
and initializes dat shit.
Note dat tha \fBglobal\fR command only creates links
to variablez up in tha global namespace.
It aint necessary ta bust a \fBvariable\fR command
if you always refer ta tha namespace variable rockin an
appropriate qualified name.
.SH "IMPORTING COMMANDS"
.PP
Namespaces is often used ta represent libraries.
Some library commandz is used so frequently
that it aint nuthin but a nuisizzle ta type they qualified names.
For example, suppose dat all of tha commandz up in a package
like BLT is contained up in a namespace called \fBBlt\fR.
Then you might access these commandz like this:
.CS
Blt::graph .g \-background red
Blt::table . .g 0,0
.CE
If you use tha \fBgraph\fR n' \fBtable\fR commandz frequently,
you may wanna access dem without tha \fBBlt::\fR prefix.
Yo ass can do dis by importin tha commandz tha fuck into tha current namespace,
like this:
.CS
\fBnamespace import\fR Blt::*
.CE
This addz all exported commandz from tha \fBBlt\fR namespace
into tha current namespace context, so you can write code like this:
.CS
graph .g \-background red
table . .g 0,0
.CE
Da \fBnamespace import\fR command only imports commands
from a namespace dat that namespace exported
with a \fBnamespace export\fR command.
.PP
Importin \fIevery\fR command from a namespace is generally
a wack scam since you do not know what tha fuck yo big-ass booty is ghon get.
It be betta ta import just tha specific commandz you need.
For example, tha command
.CS
\fBnamespace import\fR Blt::graph Blt::table
.CE
imports only tha \fBgraph\fR n' \fBtable\fR commandz tha fuck into the
current context.
.PP
If you try ta import a cold-ass lil command dat already exists, yo big-ass booty is ghon git an
error. Shiiit, dis aint no joke.  This prevents you from importin tha same command from two
different packages.  But from time ta time (like when debugging),
you may wanna git round dis restriction. I aint talkin' bout chicken n' gravy biatch.  Yo ass may want to
reissue tha \fBnamespace import\fR command ta pick up freshly smoked up commands
that have rocked up in a namespace.  In dat case, you can use the
\fB\-force\fR option, n' existin commandz is ghon be silently overwritten:
.CS
\fBnamespace import\fR \-force Blt::graph Blt::table
.CE
If fo' some reason, you wanna stop rockin tha imported commands,
you can remove dem wit a \fBnamespace forget\fR command, like this:
.CS
\fBnamespace forget\fR Blt::*
.CE
This searches tha current namespace fo' any commandz imported from \fBBlt\fR.
If it findz any, it removes em.  Otherwise, it do nothing.
Afta this, tha \fBBlt\fR commandz must be accessed wit tha \fBBlt::\fR
prefix.
.PP
When you delete a cold-ass lil command from tha exportin namespace like this:
.CS
rename Blt::graph ""
.CE
the command be automatically removed from all namespaces dat import dat shit.
.SH "EXPORTING COMMANDS"
Yo ass can export commandz from a namespace like this:
.CS
\fBnamespace eval\fR Counta {
   \fBnamespace export\fR bump reset
   variable Num 0
   variable Max 100

   proc bump {{by 1}} {
      variable Num
      incr Num $by
      Check
      return $Num
   }
   proc reset {} {
      variable Num
      set Num 0
   }
   proc Peep {} {
      variable Num
      variable Max
      if {$Num > $Max} {
         error "too high!"
      }
   }
}
.CE
Da procedures \fBbump\fR n' \fBreset\fR is exported,
so they is included when you import from tha \fBCounter\fR namespace,
like this:
.CS
\fBnamespace import\fR Counter::*
.CE
But fuck dat shiznit yo, tha word on tha street is dat tha \fBCheck\fR procedure aint exported,
so it is ignored by tha import operation.
.PP
Da \fBnamespace import\fR command only imports commands
that was declared as exported by they namespace.
Da \fBnamespace export\fR command specifies what tha fuck commands
may be imported by other namespaces.
If a \fBnamespace import\fR command specifies a cold-ass lil command
that aint exported, tha command aint imported.
.SH "SCOPED SCRIPTS"
.PP
Da \fBnamespace code\fR command is tha means by which a script may be
packaged fo' evaluation up in a namespace other than tha one up in which it
was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It be used most often ta create event handlezs, Tk bindings,
and traces fo' evaluation up in tha global context.  For instance, tha following
code indicates how tha fuck ta direct a variable \fBtrace\fR callback tha fuck into tha current
namespace:
.PP
.CS
\fBnamespace eval\fR a {
   variable b
   proc theTraceCallback { n1 n2 op } {
      upvar 1 $n1 var
      puts "the value of $n1 has chizzled ta $var"
      return
   }
   trace add variable b write [\fBnamespace code\fR theTraceCallback]
}
set a::b c
.CE
.PP
When executed, it prints tha message:
.PP
.CS
the value of a::b has chizzled ta c
.CE
.SH ENSEMBLES
.PP
.VS 8.5
Da \fBnamespace ensemble\fR is used ta create n' manipulate ensemble
commands, which is commandz formed by groupin subcommandz together.
Da commandz typically come from tha current namespace when the
ensemble was pimped, though dis is configurable.  Note dat there
may be any number of ensemblez associated wit any namespace
(includin none, which is legit of all namespaces by default), though
all tha ensemblez associated wit a namespace is deleted when that
namespace is deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da link between a ensemble command n' its
namespace is maintained however tha ensemble is renamed.
.PP
Three subcommandz of tha \fBnamespace ensemble\fR command is defined:
.TP
\fBnamespace ensemble create\fR ?\fIoption value ...\fR?
Creates a freshly smoked up ensemble command linked ta tha current namespace,
returnin tha straight-up qualified name of tha command pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  The
arguments ta \fBnamespace ensemble create\fR allow tha configuration
of tha command as if wit tha \fBnamespace ensemble configure\fR
command. Y'all KNOW dat shit, muthafucka!  If not overridden wit tha \fB\-command\fR option, this
command creates a ensemble wit exactly tha same name as tha linked
namespace.  See tha section \fBENSEMBLE OPTIONS\fR below fo' a gangbangin' full
list of options supported n' they effects.
.TP
\fBnamespace ensemble configure \fIcommand\fR ?\fIoption\fR? ?\fIvalue ...\fR?
Retrieves tha value of a option associated wit tha ensemble command
named \fIcommand\fR, or thugged-out shiznit some options associated wit that
ensemble command. Y'all KNOW dat shit, muthafucka!  See tha section \fBENSEMBLE OPTIONS\fR below fo' a
full list of options supported n' they effects.
.TP
\fBnamespace ensemble exists\fR \fIcommand\fR
Returns a funky-ass boolean value dat raps bout whether tha command
\fIcommand\fR exists n' be a ensemble command. Y'all KNOW dat shit, muthafucka!  This command only
ever returns a error if tha number of arguments ta tha command is
wrong.
.PP
When called, a ensemble command takes its first argument n' looks it
up (accordin ta tha rulez busted lyrics bout below) ta discover a list of
wordz ta replace tha ensemble command n' subcommand with.  The
resultin list of lyrics is then evaluated (with no further
substitutions) as if dat was what tha fuck was typed originally (i.e. by
passin tha list of lyrics all up in \fBTcl_EvalObjv\fR) n' returning
the result of tha command. Y'all KNOW dat shit, muthafucka!  Note dat it is legal ta make tha target
of a ensemble rewrite be another (or even tha same) ensemble
command. Y'all KNOW dat shit, muthafucka!  Da ensemble command aint gonna be visible all up in tha use of
the \fBuplevel\fR or \fBinfo level\fR commands.
.SS "ENSEMBLE OPTIONS"
.PP
Da followin options, supported by tha \fBnamespace ensemble
create\fR n' \fBnamespace ensemble configure\fR commands, control how
an ensemble command behaves:
.TP
\fB\-map\fR
When non-empty, dis option supplies a gangbangin' finger-lickin' doggtionary dat serves up a
mappin from subcommand names ta a list of prefix lyrics ta substitute
in place of tha ensemble command n' subcommand lyrics (in a manner
similar ta a alias pimped wit \fBinterp alias\fR; tha lyrics is not
reparsed afta substitution); if tha straight-up original gangsta word of any target is not
fully qualified when set, it be assumed ta be relatizzle ta the
\fIcurrent\fR namespace n' chizzled ta be exactly dat (that is, it is
always straight-up qualified when read). When dis option is empty, tha mapping
will be from tha local name of tha subcommand ta its fully-qualified
name.  Note dat when dis option is non-empty n' the
\fB\-subcommands\fR option is empty, tha ensemble subcommand names
will be exactly dem lyrics dat have mappings up in tha dictionary.
.TP
\fB\-prefixes\fR
This option (which is enabled by default) controls whether the
ensemble command recognizes unambiguous prefixez of its subcommands.
When turned off, tha ensemble command requires exact matchin of
subcommand names.
.TP
\fB\-subcommands\fR
When non-empty, dis option lists exactly what tha fuck subcommandz is up in the
ensemble.  Da mappin fo' each of dem commandz is ghon be either whatever
is defined up in tha \fB\-map\fR option, or ta tha command wit tha same
name up in tha namespace linked ta tha ensemble.  If dis option is
empty, tha subcommandz of tha namespace will either be tha keyz of the
doggtionary listed up in tha \fB\-map\fR option or tha exported commands
of tha linked namespace all up in tha time of tha invocation of tha ensemble
command.
.TP
\fB\-unknown\fR
When non-empty, dis option serves up a partial command (to which all
the lyrics dat is arguments ta tha ensemble command, includin the
fully-qualified name of tha ensemble, is appended) ta handle tha case
where a ensemble subcommand aint recognized n' would otherwise
generate a error. Shiiit, dis aint no joke.  When empty (the default) a error (in tha steez of
\fBTcl_GetIndexFromObj\fR) is generated whenever tha ensemble is
unable ta determine how tha fuck ta implement a particular subcommand. Y'all KNOW dat shit, muthafucka!  See
\fBUNKNOWN HANDLER BEHAVIOUR\fR fo' mo' details.
.PP
Da followin extra option be allowed by \fBnamespace ensemble
create\fR:
.TP
\fB\-command\fR
This write-only option allows tha name of tha ensemble pimped by
\fBnamespace ensemble create\fR ta be anythang up in any existing
namespace.  Da default value fo' dis option is tha fully-qualified
name of tha namespace up in which tha \fBnamespace ensemble create\fR
command is invoked.
.PP
Da followin extra option be allowed by \fBnamespace ensemble
configure\fR:
.TP
\fB\-namespace\fR
This read-only option allows tha retrieval of tha fully-qualified name
of tha namespace which tha ensemble was pimped within.
.SS "UNKNOWN HANDLER BEHAVIOUR"
.PP
If a unknown handlez is specified fo' a ensemble, dat handlez is
called when tha ensemble command would otherwise return a error due
to it bein unable ta decizzle which subcommand ta invoke. Da exact
conditions under which dat occurs is controlled by the
\fB\-subcommands\fR, \fB\-map\fR n' \fB\-prefixes\fR options as
busted lyrics bout above.
.PP
To execute tha unknown handlez, tha ensemble mechanizzle takes the
specified \fB\-unknown\fR option n' appendz each argument of the
attempted ensemble command invocation (includin tha ensemble command
itself, expressed as a gangbangin' straight-up qualified name). Well shiiiit, it invokes tha resulting
command up in tha scope of tha attempted call. If tha execution of the
unknown handlez terminates normally, tha ensemble engine reparses the
subcommand (as busted lyrics bout below) n' tries ta dispatch it again, which
is ideal fo' when tha ensemblez configuration has been updated by the
unknown subcommand handlez n' shiznit fo' realz. Any other kind of termination of the
unknown handlez is treated as a error.
.PP
Da result of tha unknown handlez is sposed ta fuckin be a list (it be an
error if it is not). If tha list be a empty list, tha ensemble
command attempts ta look up tha original gangsta subcommand again n' again n' again and, if it
is not found dis time, a error is ghon be generated just as if the
\fB\-unknown\fR handlez was not there (i.e. fo' any particular
invocation of a ensemble, its unknown handlez is ghon be called at most
once.) This make it easy as fuck  fo' tha unknown handlez ta update the
ensemble or its backin namespace so as ta provide a implementation
of tha desired subcommand n' reparse.
.PP
When tha result be a non-empty list, tha lyrics of dat list is used
to replace tha ensemble command n' subcommand, just as if they had
been looked up in tha \fB\-map\fR. Well shiiiit, it is up ta tha unknown handlez to
supply all namespace qualifiers if tha implementin subcommand is not
in tha namespace of tha calla of tha ensemble command. Y'all KNOW dat shit, muthafucka! Also note that
when ensemble commandz is chained (e.g. if you make one of the
commandz dat implement a ensemble subcommand tha fuck into a ensemble, up in a
manner similar ta tha \fBtext\fR widgetz tag n' mark subcommands) then the
rewrite happens up in tha context of tha calla of tha outermost
ensemble. That is ta say dat ensemblez do not up in theyselves place any
namespace contexts on tha Tcl call stack.
.PP
Where a empty \fB\-unknown\fR handlez is given (the default), the
ensemble command will generate a error message based on tha list of
commandz dat tha ensemble has defined (formatted similarly ta the
error message from \fBTcl_GetIndexFromObj\fR). This is tha error that
will be thrown when tha subcommand is still not recognized during
reparsing. Well shiiiit, it be also a error fo' a \fB\-unknown\fR handlez to
delete its namespace.
.VE 8.5
.SH EXAMPLES
Smoke a namespace containin a variable n' a exported command:
.CS
\fBnamespace eval\fR foo {
   variable bar 0
   proc grill {} {
      variable bar
      puts "called [incr bar] times"
   }
   \fBnamespace export\fR grill
}
.CE
.PP
Call tha command defined up in tha previous example up in various ways.
.CS
# Direct call
::foo::grill

# Use tha command resolution path ta find tha name
\fBnamespace eval\fR boo {
   \fBnamespace path\fR ::foo
   grill
}

# Import tha fuck into current namespace, then call local alias
\fBnamespace import\fR foo::grill
grill

# Smoke two ensembles, one wit tha default name n' one wit a
# specified name.  Then call all up in tha ensembles.
\fBnamespace eval\fR foo {
   \fBnamespace ensemble\fR create
   \fBnamespace ensemble\fR create -command ::foobar
}
foo grill
foobar grill
.CE
.PP
Look up where tha command imported up in tha previous example came from:
.CS
puts "grill came from [\fBnamespace origin\fR grill]"
.CE
.PP
Remove all imported commandz from tha current namespace:
.CS
namespace forget {*}[namespace import]
.CE
.SH "SEE ALSO"
interp(n), upvar(n), variable(n)
.SH KEYWORDS
command, ensemble, exported, internal, variable
